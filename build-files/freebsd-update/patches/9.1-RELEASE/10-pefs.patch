diff --git lib/libpam/modules/modules.inc lib/libpam/modules/modules.inc
index c570cfd..da1391b 100644
--- lib/libpam/modules/modules.inc
+++ lib/libpam/modules/modules.inc
@@ -19,6 +19,7 @@ MODULES		+= pam_login_access
 MODULES		+= pam_nologin
 MODULES		+= pam_opie
 MODULES		+= pam_opieaccess
+MODULES		+= pam_pefs
 MODULES		+= pam_passwdqc
 MODULES		+= pam_permit
 MODULES		+= pam_radius
diff --git lib/libpam/modules/pam_pefs/Makefile lib/libpam/modules/pam_pefs/Makefile
new file mode 100644
index 0000000..ff43ec6
--- /dev/null
+++ lib/libpam/modules/pam_pefs/Makefile
@@ -0,0 +1,27 @@
+# PAM module for pefs
+# $FreeBSD$
+
+SYS=		${.CURDIR}/../../../../sys
+PEFSDIR=	${.CURDIR}/../../../../sbin/pefs
+
+LIB=	pam_pefs
+MAN=	pam_pefs.8
+SRCS=	pam_pefs.c
+SRCS+=	pefs_key.c pefs_keychain.c pefs_subr.c
+SRCS+=	hmac.c
+SRCS+=	pkcs5v2.c
+SRCS+=	rijndael-api.c rijndael-api-fst.c rijndael-alg-fst.c
+SRCS+=	sha2.c
+
+CFLAGS+= -I${PEFSDIR}
+CFLAGS+= -I${SYS}
+WARNS?=	2
+
+DPADD= ${LIBUTIL}
+LDADD= -lutil
+
+.include <bsd.lib.mk>
+
+.PATH: ${PEFSDIR}
+.PATH: ${SYS}/crypto/hmac ${SYS}/crypto/pkcs5v2 ${SYS}/crypto/rijndael
+.PATH: ${SYS}/crypto/sha2
diff --git lib/libpam/modules/pam_pefs/pam_pefs.8 lib/libpam/modules/pam_pefs/pam_pefs.8
new file mode 100644
index 0000000..6af0456
--- /dev/null
+++ lib/libpam/modules/pam_pefs/pam_pefs.8
@@ -0,0 +1,147 @@
+.\" Copyright (c) 2001 Mark R V Murray
+.\" Copyright (c) 2001-2003 Networks Associates Technology, Inc.
+.\" Copyright (c) 2009 Gleb Kurtsou
+.\" All rights reserved.
+.\"
+.\" This software was developed for the FreeBSD Project by ThinkSec AS and
+.\" NAI Labs, the Security Research Division of Network Associates, Inc.
+.\" under DARPA/SPAWAR contract N66001-01-C-8035 ("CBOSS"), as part of the
+.\" DARPA CHATS research program.
+.\"
+.\" Redistribution and use in source and binary forms, with or without
+.\" modification, are permitted provided that the following conditions
+.\" are met:
+.\" 1. Redistributions of source code must retain the above copyright
+.\"    notice, this list of conditions and the following disclaimer.
+.\" 2. Redistributions in binary form must reproduce the above copyright
+.\"    notice, this list of conditions and the following disclaimer in the
+.\"    documentation and/or other materials provided with the distribution.
+.\" 3. The name of the author may not be used to endorse or promote
+.\"    products derived from this software without specific prior written
+.\"    permission.
+.\"
+.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+.\" SUCH DAMAGE.
+.\"
+.\" $FreeBSD$
+.\"
+.Dd December 1, 2009
+.Dt PAM_PEFS 8
+.Os
+.Sh NAME
+.Nm pam_pefs
+.Nd pefs PAM module
+.Sh SYNOPSIS
+.Op Ar service-name
+.Ar module-type
+.Ar control-flag
+.Pa pam_pefs
+.Op Ar options
+.Sh DESCRIPTION
+The
+pefs
+authentication service module for PAM,
+.Nm
+provides functionality for two PAM categories:
+authentication
+and session management.
+In terms of the
+.Ar module-type
+parameter, they are the
+.Dq Li auth
+and
+.Dq Li session
+features.
+.Pp
+Module expects pefs file system to be mounted on user home directory
+and fails otherwise.
+.Ss Pefs Authentication Module
+The
+pefs
+authentication component
+provides a function to verify the identity of a user
+.Pq Fn pam_sm_authenticate ,
+by prompting the user for a passphrase and verifying that it exists in
+pefs key chain database.
+.Pp
+The following options may be passed to the authentication module:
+.Bl -tag -width ".Cm use_first_pass"
+.It Cm use_first_pass
+If the authentication module
+is not the first in the stack,
+and a previous module
+obtained the user's password,
+that password is used
+to authenticate the user.
+If this fails,
+the authentication module returns failure
+without prompting the user for a password.
+This option has no effect
+if the authentication module
+is the first in the stack,
+or if no previous modules
+obtained the user's password.
+.It Cm try_first_pass
+This option is similar to the
+.Cm use_first_pass
+option,
+except that if the previously obtained password fails,
+the user is prompted for another password.
+.It Cm ignore_missing
+Accept any passphrase provided by the user.
+This option is used not to authenticate user, but to preserve keys that
+should be added to pefs file system by session management module.
+Option is incompatible with
+.Cm try_first_pass
+option and should be used with
+.Cm use_first_pass
+option.
+.It Cm delkeys
+Remove keys at the end of last session.
+Module tracks the number of concurrent sessions, removing all keys from
+file system when session count reaches zero.
+.El
+.Ss Pefs Session Management Module
+The
+pefs
+session management component
+provides functions to initiate
+.Pq Fn pam_sm_open_session
+and terminate
+.Pq Fn pam_sm_close_session
+sessions.
+The
+.Fn pam_sm_open_session
+function adds key or key chain decrypted during the authentication phase
+to the pefs file system mounted on user home directory.
+.Sh FILES
+.Bl -tag -width ".Pa $HOME/.pefs.conf" -compact
+.It Pa $HOME/.pefs.conf
+pefs configuration file
+.It Pa $HOME/.pefs.db
+pefs key chain database file
+.El
+.Sh SEE ALSO
+.Xr pam.conf 5 ,
+.Xr pam 8
+.Xr pefs 8
+.Sh AUTHORS
+The
+.Nm
+module was written by
+.An -nosplit
+.An "Gleb Kurtsou" Aq gk@FreeBSD.org .
+.Sh BUGS
+.Fn pam_sm_close_session
+function
+doesn't delete keys added during by
+.Fn pam_sm_open_session .
diff --git lib/libpam/modules/pam_pefs/pam_pefs.c lib/libpam/modules/pam_pefs/pam_pefs.c
new file mode 100644
index 0000000..eafeb31
--- /dev/null
+++ lib/libpam/modules/pam_pefs/pam_pefs.c
@@ -0,0 +1,526 @@
+/*-
+ * Copyright (c) 2003 Networks Associates Technology, Inc.
+ * Copyright (c) 2009 Gleb Kurtsou <gleb@FreeBSD.org>
+ * All rights reserved.
+ *
+ * This software was developed for the FreeBSD Project by ThinkSec AS and
+ * NAI Labs, the Security Research Division of Network Associates, Inc.
+ * under DARPA/SPAWAR contract N66001-01-C-8035 ("CBOSS"), as part of the
+ * DARPA CHATS research program.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/ioctl.h>
+#include <sys/wait.h>
+#include <sys/stat.h>
+
+#include <errno.h>
+#include <fcntl.h>
+#include <libgen.h>
+#include <libutil.h>
+#include <paths.h>
+#include <pwd.h>
+#include <signal.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <syslog.h>
+#include <unistd.h>
+
+#define	PAM_SM_AUTH
+#define	PAM_SM_SESSION
+
+#include <security/pam_appl.h>
+#include <security/pam_modules.h>
+#include <security/pam_mod_misc.h>
+#include <security/openpam.h>
+
+#include <fs/pefs/pefs.h>
+
+#include "pefs_ctl.h"
+#include "pefs_keychain.h"
+
+#define	PEFS_OPT_IGNORE_MISSING		"ignore_missing"
+#define	PEFS_OPT_DELKEYS		"delkeys"
+
+#define	PAM_PEFS_KEYS			"pam_pefs_keys"
+
+#define	PEFS_SESSION_DIR		"/var/run/pefs"
+#define	PEFS_SESSION_DIR_MODE		0700
+#define	PEFS_SESSION_FILE_MODE		0600
+#define	PEFS_SESSION_FILE_FLAGS		\
+	(O_RDWR | O_NONBLOCK | O_CREAT | O_EXLOCK)
+
+static int pam_pefs_debug;
+
+void
+pefs_warn(const char *fmt, ...)
+{
+	static const char *label = "pam_pefs: ";
+	char buf[BUFSIZ];
+        va_list ap;
+
+	if (pam_pefs_debug == 0)
+		return;
+
+        va_start(ap, fmt);
+	if (strlen(fmt) + sizeof(label) >= sizeof(buf)) {
+		vsyslog(LOG_DEBUG, fmt, ap);
+	} else {
+		strlcpy(buf, label, sizeof(buf));
+		strlcat(buf, fmt, sizeof(buf));
+		vsyslog(LOG_DEBUG, buf, ap);
+	}
+        va_end(ap);
+}
+
+static int
+flopen_retry(const char *filename)
+{
+	int fd, try;
+
+	for (try = 1; try <= 1024; try *= 2) {
+		fd = flopen(filename, PEFS_SESSION_FILE_FLAGS,
+		    PEFS_SESSION_FILE_MODE);
+		if (fd != -1)
+			return (fd);
+		else if (errno != EWOULDBLOCK)
+			return (-1);
+		// Exponential back-off up to 1 second
+		usleep(try * 1000000 / 1024);
+	}
+	errno = ETIMEDOUT;
+	return (-1);
+}
+
+static int
+pefs_session_count_incr(const char *user, bool incr)
+{
+	struct stat sb;
+	struct timespec tp_uptime, tp_now;
+	ssize_t offset;
+	int fd, total = 0;
+	char filename[MAXPATHLEN], buf[16];
+	const char *errstr;
+
+	snprintf(filename, sizeof(filename), "%s/%s", PEFS_SESSION_DIR, user);
+
+	if (lstat(PEFS_SESSION_DIR, &sb) == -1) {
+		if (errno != ENOENT) {
+			pefs_warn("unable to access session directory %s: %s",
+			    PEFS_SESSION_DIR, strerror(errno));
+			return (-1);
+		}
+		if (mkdir(PEFS_SESSION_DIR, PEFS_SESSION_DIR_MODE) == -1) {
+			pefs_warn("unable to create session directory %s: %s",
+			    PEFS_SESSION_DIR, strerror(errno));
+			return (-1);
+		}
+	} else if (!S_ISDIR(sb.st_mode)) {
+		pefs_warn("%s is not a directory", PEFS_SESSION_DIR);
+		return (-1);
+	}
+
+	if ((fd = flopen_retry(filename)) == -1) {
+		pefs_warn("unable to create session counter file %s: %s",
+		    filename, strerror(errno));
+		return (-1);
+	}
+
+	if ((offset = pread(fd, buf, sizeof(buf) - 1, 0)) == -1) {
+		pefs_warn("unable to read from the session counter file %s: %s",
+		    filename, strerror(errno));
+		close(fd);
+		return (-1);
+	}
+	buf[offset] = '\0';
+	if (offset != 0) {
+		total = strtonum(buf, 0, INT_MAX, &errstr);
+		if (errstr != NULL)
+			pefs_warn("corrupted session counter file: %s: %s",
+			    filename, errstr);
+	}
+
+	/*
+	 * Determine if this is the first increment of the session file.
+	 *
+	 * It is considered the first increment if the session file has not
+	 * been modified since the last boot time.
+	 */
+	if (incr && total > 0) {
+		if (fstat(fd, &sb) == -1) {
+			pefs_warn("unable to access session counter file %s: %s",
+			    filename, strerror(errno));
+			close(fd);
+			return (-1);
+		}
+		/*
+		 * Check is messy and will fail if wall clock isn't monotonical
+		 * (e.g. because of ntp, DST, leap seconds)
+		 */
+		clock_gettime(CLOCK_REALTIME_FAST, &tp_now);
+		clock_gettime(CLOCK_UPTIME_FAST, &tp_uptime);
+		if (sb.st_mtime < tp_now.tv_sec - tp_uptime.tv_sec) {
+			pefs_warn("stale session counter file: %s",
+			    filename);
+			total = 0;
+		}
+	}
+
+	lseek(fd, 0L, SEEK_SET);
+	ftruncate(fd, 0L);
+
+	total += incr ? 1 : -1;
+	if (total < 0) {
+		pefs_warn("corrupted session counter file: %s",
+		    filename);
+		total = 0;
+	} else
+		pefs_warn("%s: session count %d", user, total);
+
+	buf[0] = '\0';
+	snprintf(buf, sizeof(buf), "%d", total);
+	pwrite(fd, buf, strlen(buf), 0);
+	close(fd);
+
+	return (total);
+}
+
+static int
+pam_pefs_checkfs(const char *homedir)
+{
+	char fsroot[MAXPATHLEN];
+	int error;
+
+	error = pefs_getfsroot(homedir, 0, fsroot, sizeof(fsroot));
+	if (error != 0) {
+		pefs_warn("file system is not mounted: %s", homedir);
+		return (PAM_USER_UNKNOWN);
+	} if (strcmp(fsroot, homedir) != 0) {
+		pefs_warn("file system is not mounted on home dir: %s", fsroot);
+		return (PAM_USER_UNKNOWN);
+	}
+
+	return (PAM_SUCCESS);
+}
+
+/*
+ * Perform key lookup in ~/.pefs;
+ * returns PAM_AUTH_ERR if and only if key wasn't found in database.
+ */
+static int
+pam_pefs_getkeys(struct pefs_keychain_head *kch,
+    const char *homedir, const char *passphrase, int chainflags)
+{
+	struct pefs_xkey k;
+	struct pefs_keyparam kp;
+	int error;
+
+	pefs_keyparam_create(&kp);
+	pefs_keyparam_init(&kp, homedir);
+
+	error = pefs_key_generate(&k, passphrase, &kp);
+	if (error != 0)
+		return (PAM_SERVICE_ERR);
+
+	error = pefs_keychain_get(kch, homedir, chainflags, &k);
+	bzero(&k, sizeof(k));
+	if (error != 0)
+		return (error == PEFS_ERR_NOENT ? PAM_AUTH_ERR :
+		    PAM_SERVICE_ERR);
+
+	return (PAM_SUCCESS);
+}
+
+static int
+pam_pefs_addkeys(const char *homedir, struct pefs_keychain_head *kch)
+{
+	struct pefs_keychain *kc;
+	int fd;
+
+	fd = open(homedir, O_RDONLY);
+	if (fd == -1) {
+		pefs_warn("cannot open homedir %s: %s",
+		    homedir, strerror(errno));
+		return (PAM_USER_UNKNOWN);
+	}
+
+	TAILQ_FOREACH(kc, kch, kc_entry) {
+		if (ioctl(fd, PEFS_ADDKEY, &kc->kc_key) == -1) {
+			pefs_warn("cannot add key: %s: %s",
+			    homedir, strerror(errno));
+			break;
+		}
+	}
+	close(fd);
+
+	return (PAM_SUCCESS);
+}
+
+static int
+pam_pefs_delkeys(const char *homedir)
+{
+	struct pefs_xkey k;
+	int fd;
+
+	fd = open(homedir, O_RDONLY);
+	if (fd == -1) {
+		pefs_warn("cannot open homedir %s: %s",
+		    homedir, strerror(errno));
+		return (PAM_USER_UNKNOWN);
+	}
+
+	bzero(&k, sizeof(k));
+	while (1) {
+		if (ioctl(fd, PEFS_GETKEY, &k) == -1)
+			break;
+
+		if (ioctl(fd, PEFS_DELKEY, &k) == -1) {
+			pefs_warn("cannot del key: %s: %s",
+			    homedir, strerror(errno));
+			k.pxk_index++;
+		}
+	}
+	close(fd);
+
+	return (PAM_SUCCESS);
+}
+
+static void
+pam_pefs_freekeys(pam_handle_t *pamh __unused, void *data, int pam_err __unused)
+{
+	struct pefs_keychain_head *kch = data;
+
+	pefs_keychain_free(kch);
+	free(kch);
+}
+
+PAM_EXTERN int
+pam_sm_authenticate(pam_handle_t *pamh, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+	struct pefs_keychain_head *kch;
+	struct passwd *pwd;
+	const char *passphrase, *user;
+	const void *item;
+	int pam_err, canretry, chainflags;
+
+	/* Get user name and home directory */
+	pam_err = pam_get_user(pamh, &user, NULL);
+	if (pam_err != PAM_SUCCESS)
+		return (pam_err);
+	pwd = getpwnam(user);
+	if (pwd == NULL)
+		return (PAM_USER_UNKNOWN);
+	if (pwd->pw_dir == NULL)
+		return (PAM_AUTH_ERR);
+
+	pam_pefs_debug = (openpam_get_option(pamh, PAM_OPT_DEBUG) != NULL);
+
+	chainflags = PEFS_KEYCHAIN_USE;
+	if (openpam_get_option(pamh, PEFS_OPT_IGNORE_MISSING) != NULL)
+		chainflags = PEFS_KEYCHAIN_IGNORE_MISSING;
+
+	canretry = (pam_get_item(pamh, PAM_AUTHTOK, &item) == PAM_SUCCESS &&
+	    item != NULL && chainflags != PEFS_KEYCHAIN_IGNORE_MISSING);
+
+	pam_err = openpam_borrow_cred(pamh, pwd);
+	if (pam_err != PAM_SUCCESS)
+		return (pam_err);
+
+	/*
+	 * Check to see if the passwd db is available, avoids asking for
+	 * password if we cannot even validate it.
+	 */
+	pam_err = pam_pefs_checkfs(pwd->pw_dir);
+	openpam_restore_cred(pamh);
+	if (pam_err != PAM_SUCCESS)
+		return (pam_err);
+
+
+retry:
+	/* Get passphrase */
+	pam_err = pam_get_authtok(pamh, PAM_AUTHTOK,
+	    &passphrase, NULL);
+	if (pam_err != PAM_SUCCESS)
+		return (pam_err);
+
+	if (*passphrase != '\0') {
+		kch = calloc(1, sizeof(*kch));
+		if (kch == NULL)
+			return (PAM_SYSTEM_ERR);
+
+		/* Switch to user credentials */
+		pam_err = openpam_borrow_cred(pamh, pwd);
+		if (pam_err != PAM_SUCCESS)
+			return (pam_err);
+
+		pam_err = pam_pefs_getkeys(kch, pwd->pw_dir, passphrase,
+		    chainflags);
+		if (pam_err == PAM_SUCCESS)
+			pam_set_data(pamh, PAM_PEFS_KEYS, kch,
+			    pam_pefs_freekeys);
+		else
+			free(kch);
+
+		/* Switch back to arbitrator credentials */
+		openpam_restore_cred(pamh);
+	} else
+		pam_err = PAM_AUTH_ERR;
+
+	/*
+	 * If we tried an old token and didn't get anything, and
+	 * try_first_pass was specified, try again after prompting the
+	 * user for a new passphrase.
+	 */
+	if (pam_err == PAM_AUTH_ERR && canretry != 0 &&
+	    openpam_get_option(pamh, "try_first_pass") != NULL) {
+		pam_set_item(pamh, PAM_AUTHTOK, NULL);
+		canretry = 0;
+		goto retry;
+	}
+
+	return (pam_err);
+}
+
+PAM_EXTERN int
+pam_sm_setcred(pam_handle_t *pamh __unused, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+
+	return (PAM_SUCCESS);
+}
+
+PAM_EXTERN int
+pam_sm_open_session(pam_handle_t *pamh, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+	struct pefs_keychain_head *kch = NULL;
+	struct passwd *pwd;
+	const char *user;
+	int pam_err, opt_delkeys;
+
+	pam_err = pam_get_user(pamh, &user, NULL);
+	if (pam_err != PAM_SUCCESS)
+		return (pam_err);
+	pwd = getpwnam(user);
+	if (pwd == NULL)
+		return (PAM_USER_UNKNOWN);
+	if (pwd->pw_dir == NULL)
+		return (PAM_SYSTEM_ERR);
+
+	pam_pefs_debug = (openpam_get_option(pamh, PAM_OPT_DEBUG) != NULL);
+	opt_delkeys = (openpam_get_option(pamh, PEFS_OPT_DELKEYS) != NULL);
+
+	pam_err = pam_get_data(pamh, PAM_PEFS_KEYS,
+	    (const void **)(void *)&kch);
+	if (pam_err != PAM_SUCCESS || kch == NULL || TAILQ_EMPTY(kch)) {
+		pam_err = PAM_SUCCESS;
+		opt_delkeys = 0;
+		goto out;
+	}
+
+	/* Switch to user credentials */
+	pam_err = openpam_borrow_cred(pamh, pwd);
+	if (pam_err != PAM_SUCCESS)
+		goto out;
+
+	pam_err = pam_pefs_checkfs(pwd->pw_dir);
+	if (pam_err != PAM_SUCCESS) {
+		openpam_restore_cred(pamh);
+		pam_err = PAM_SUCCESS;
+		opt_delkeys = 0;
+		goto out;
+	}
+
+	pam_err = pam_pefs_addkeys(pwd->pw_dir, kch);
+
+	/* Switch back to arbitrator credentials */
+	openpam_restore_cred(pamh);
+
+out:
+	/* Remove keys from memory */
+	if (kch != NULL)
+		pefs_keychain_free(kch);
+
+	/* Increment login count */
+	if (pam_err == PAM_SUCCESS && opt_delkeys)
+		pefs_session_count_incr(user, true);
+
+	return (pam_err);
+}
+
+PAM_EXTERN int
+pam_sm_close_session(pam_handle_t *pamh, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+	struct passwd *pwd;
+	const char *user;
+	int pam_err, opt_delkeys;
+
+	pam_err = pam_get_user(pamh, &user, NULL);
+	if (pam_err != PAM_SUCCESS)
+		return (pam_err);
+
+	pwd = getpwnam(user);
+	if (pwd == NULL)
+		return (PAM_USER_UNKNOWN);
+	if (pwd->pw_dir == NULL)
+		return (PAM_SYSTEM_ERR);
+
+	pam_pefs_debug = (openpam_get_option(pamh, PAM_OPT_DEBUG) != NULL);
+	opt_delkeys = (openpam_get_option(pamh, PEFS_OPT_DELKEYS) != NULL);
+	if (!opt_delkeys)
+		return PAM_SUCCESS;
+
+	pam_err = openpam_borrow_cred(pamh, pwd);
+	if (pam_err != PAM_SUCCESS)
+		return (pam_err);
+	pam_err = pam_pefs_checkfs(pwd->pw_dir);
+	openpam_restore_cred(pamh);
+	if (pam_err != PAM_SUCCESS)
+		return (PAM_SUCCESS);
+
+	/* Decrease login count and remove keys if at zero */
+	pam_err = PAM_SUCCESS;
+	if (pefs_session_count_incr(user, false) == 0) {
+		pam_err = openpam_borrow_cred(pamh, pwd);
+		if (pam_err != PAM_SUCCESS)
+			return (pam_err);
+		pam_err = pam_pefs_delkeys(pwd->pw_dir);
+		openpam_restore_cred(pamh);
+	}
+
+	return (pam_err);
+}
+
+PAM_MODULE_ENTRY("pam_pefs");
diff --git sbin/Makefile sbin/Makefile
index f9ba4ca..e2119a05 100644
--- sbin/Makefile
+++ sbin/Makefile
@@ -58,6 +58,7 @@ SUBDIR=adjkerntz \
 	newfs_msdos \
 	nfsiod \
 	nos-tun \
+	pefs \
 	ping \
 	rcorder \
 	reboot \
diff --git sbin/pefs/Makefile sbin/pefs/Makefile
new file mode 100644
index 0000000..cc240ee
--- /dev/null
+++ sbin/pefs/Makefile
@@ -0,0 +1,24 @@
+# $FreeBSD$
+
+SYS=	${.CURDIR}/../../sys
+.PATH:	${SYS}/crypto/hmac ${SYS}/crypto/pkcs5v2
+.PATH:	${SYS}/crypto/rijndael ${SYS}/crypto/sha2
+
+PROG=	pefs
+SRCS=	pefs_ctl.c pefs_key.c pefs_keychain.c pefs_subr.c
+SRCS+=	hmac.c
+SRCS+=	pkcs5v2.c
+SRCS+=	rijndael-api.c rijndael-api-fst.c rijndael-alg-fst.c
+SRCS+=	sha2.c
+
+MAN=	pefs.8
+
+CFLAGS+=-I${SYS}
+WARNS?=	2
+
+DPADD=  ${LIBUTIL}
+LDADD=  -lutil
+
+BINDIR?= /sbin
+
+.include <bsd.prog.mk>
diff --git sbin/pefs/pefs.8 sbin/pefs/pefs.8
new file mode 100644
index 0000000..291f8ac
--- /dev/null
+++ sbin/pefs/pefs.8
@@ -0,0 +1,466 @@
+.\" Copyright (c) 2005-2008 Pawel Jakub Dawidek <pjd@FreeBSD.org>
+.\" Copyright (c) 2009 Gleb Kurtsou
+.\" All rights reserved.
+.\"
+.\" Redistribution and use in source and binary forms, with or without
+.\" modification, are permitted provided that the following conditions
+.\" are met:
+.\" 1. Redistributions of source code must retain the above copyright
+.\"    notice, this list of conditions and the following disclaimer.
+.\" 2. Redistributions in binary form must reproduce the above copyright
+.\"    notice, this list of conditions and the following disclaimer in the
+.\"    documentation and/or other materials provided with the distribution.
+.\"
+.\" THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND
+.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE
+.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+.\" SUCH DAMAGE.
+.\"
+.\" $FreeBSD$
+.\"
+.Dd December 1, 2009
+.Dt PEFS 8
+.Os
+.Sh NAME
+.Nm pefs
+.Nd configure pefs file systems
+.Sh SYNOPSIS
+.Nm
+.Cm mount
+.Op Fl o Ar options
+.Op Ar from filesystem
+.Nm
+.Cm unmount
+.Op Fl fv
+.Ar filesystem
+.Pp
+.Nm
+.Cm addkey
+.Op Fl cCpv
+.Op Fl a Ar alg
+.Op Fl i Ar iterations
+.Op Fl j Ar passfile
+.Op Fl k Ar keyfile
+.Ar filesystem
+.Nm
+.Cm delkey
+.Op Fl cCpv
+.Op Fl i Ar iterations
+.Op Fl j Ar passfile
+.Op Fl k Ar keyfile
+.Ar filesystem
+.Nm
+.Cm flushkeys
+.Ar filesystem
+.Nm
+.Cm getkey
+.Op Fl t
+.Ar file
+.Nm
+.Cm setkey
+.Op Fl cCpvx
+.Op Fl a Ar alg
+.Op Fl i Ar iterations
+.Op Fl j Ar passfile
+.Op Fl k Ar keyfile
+.Ar directory
+.Nm
+.Cm showkeys
+.Op Fl t
+.Ar filesystem
+.Pp
+.Nm
+.Cm addchain
+.Op Fl fpPvZ
+.Op Fl a Ar alg
+.Op Fl i Ar iterations
+.Op Fl j Ar passfile
+.Op Fl k Ar keyfile
+.Op Fl A Ar alg
+.Op Fl I Ar iterations
+.Op Fl J Ar passfile
+.Op Fl K Ar keyfile
+.Ar filesystem
+.Nm
+.Cm delchain
+.Op Fl fFpv
+.Op Fl i Ar iterations
+.Op Fl j Ar passfile
+.Op Fl k Ar keyfile
+.Ar filesystem
+.Nm
+.Cm randomchain
+.Op Fl fv
+.Op Fl i Ar iterations
+.Op Fl j Ar passfile
+.Op Fl k Ar keyfile
+.Ar filesystem
+.Nm
+.Cm showchains
+.Op Fl fp
+.Op Fl i Ar iterations
+.Op Fl j Ar passfile
+.Op Fl k Ar keyfile
+.Ar filesystem
+.Pp
+.Nm
+.Cm showalgs
+.Sh DESCRIPTION
+The
+.Nm
+utility is the user interface for configuring stacked cryptographic file system.
+.Pp
+The following is a list of the most important file system features:
+.Bl -bullet -offset indent -compact
+.It
+Kernel level file system, no user level daemons needed.
+Transparently runs on top of existing file systems.
+.It
+Random per file tweak value used for encryption, which guaranties different
+cipher texts for the same encrypted files.
+.It
+Saves metadata only in encrypted file name, but not in file itself.
+.It
+Supports arbitrary number of keys per file system, default directory key,
+mixing files encrypted with different keys in same directory.
+.It
+Allows defining key chains, can be used to add/delete several keys by
+specifying only master key.
+.It
+Uses modern cryptographic algorithms: AES and Camellia in XTS mode,
+PKCS#5v2 and HKDF for key generation.
+.El
+.Pp
+First argument of
+.Nm
+utility indicates the command to be performed (see the
+.Sx COMMAND OPTIONS
+section for information on options):
+.Bl -tag -width indent
+.It Cm mount
+Mount file system.
+Encryption keys should be specified separately after mounting the file system.
+If no agrumnt specified prints all mounted
+.Nm
+file systems.
+See
+.Xr mount 8
+for more information.
+.It Cm unmount Ar filesystem
+Unmount
+.Ar filesystem .
+.Fl f
+and
+.Fl v
+options can be specified to force unmount or enable verbose mode respectively.
+See
+.Xr umount 8
+for more information.
+.It Cm addkey Ar filesystem
+Add key to the
+.Ar filesystem
+.It Cm delkey Ar filesystem
+Delete key from
+.Ar filesystem .
+Command doesn't accept
+.Fl a Ar alg
+argument because the key fingerprint generated from the key doesn't depend on
+encryption algorithm.
+.It Cm getkey Ar file
+Print fingerprint of the key used by
+.Ar file .
+.It Cm flushkeys Ar filesystem
+Delete all keys from
+.Ar filesystem .
+After the command all opened files would become unavailable.
+.It Cm setkey Ar directory
+Change default key for the
+.Ar directory .
+Default key is used as a new key for files and directories created in the
+.Ar directory .
+Technically just a rename takes place on underlaying file system.
+Keys for entries in the
+.Ar directory
+are not changed and no data is re-encrypted with new key.
+.Fl x
+option can be used to add a new key to file system if it isn't found.
+.It Cm showkeys Ar filesystem
+Print fingerprints if all active keys.
+.It Cm addchain Ar filesystem
+Add a new key chain element.
+Element consists of parent and child keys.
+Parent key is defined by
+.Fl a , Fl i
+and
+.Fl p
+options and child key by equivalent
+.Fl A , Fl I
+and
+.Fl P
+options.
+Element consisting only of a parent key can be constructed by specifying
+.Fl Z
+option.
+.Fl f
+option disables file system type checks making manipulation on key chains
+possible without mounting
+.Nm
+file system.
+See
+.Sx KEY CHAINS
+section for more information.
+.It Cm delchain Ar filesystem
+Delete key chain element defined by parent key.
+Use
+.Fl F
+option to delete all elements from the chain.
+.It Cm randomchain Ar filesystem
+Create random key chain elements.
+Minimum and maximum number of elements is controlled by
+.Fl n Ar min
+and
+.Fl N Ar max
+options.
+The command can be used to add false elements into key chain database, which
+would complicate analysis of key usage patterns by attacker.
+It can also be used be achieve some approximation of deniable encryption.
+.It Cm showchains Ar filesystem
+Print all elements of the key chain staring with given parent key.
+.It Cm showalgs
+Print list of all supported algorithms.
+.El
+.Pp
+.Ss COMMAND OPTIONS
+The following options are available when invoking
+.Nm :
+.Bl -tag -width indent
+.It Fl a Ar alg
+Encryption algorithm to use.
+Use
+.Cm showalgs
+command to get list of supported algorithms.
+The default algorithm is AES-128.
+.It Fl A Ar alg
+Specifies algorithm for the secondary/child key.
+.It Fl c
+Forces key chain lookup.
+Error returned if chain is not found for the key.
+By default lookup errors are silently ignored.
+.It Fl C
+Disables key chain lookup.
+By default if chain is found, keys it consists of are also used for operation.
+.It Fl i Ar iterations
+Number of
+.Ar iterations
+to use with PKCS#5v2.
+If this option is not specified default value of 50000 is used.
+.It Fl I Ar iterations
+Specifies number of
+.Ar iterations
+for the secondary/child key.
+.It Fl j Ar passfile
+Specifies a file which contains the passphrase.
+If
+.Ar passfile
+is given as -, standard input will be used.
+Only the first line (excluding new-line character) is taken from the given
+file.
+This argument can be specified multiple times, which has the effect of
+reassembling a single passphrase split across multiple files.
+Cannot be combined with the
+.Fl p
+option.
+.It Fl J Ar passfile
+Specifies a file which contains the passphrase for secondary/child key.
+Cannot be combined with
+.Fl P
+option.
+.It Fl f
+Forces operation.
+Use to force
+.Cm unmount
+or to disable file system type check for key chain commands.
+.It Fl F
+Used with
+.Cm delchain
+command to delete all elements from a key chain.
+.It Fl k Ar keyfile
+Specifies a file which contains part of the key.
+If
+.Ar keyfile
+is given as -, standard input will be used.
+.It Fl K Ar keyfile
+Specifies a file which contains part of the secondary/child key.
+.It Fl o Ar options
+Mount options passed to
+.Xr mount 8
+utility.
+.It Fl p
+Do not ask for passphrase.
+.It Fl P
+Do not ask for passphrase for secondary/child key.
+.It Fl t
+Test-only mode.
+Do not perform actual operation but check if it can be performed.
+Usable for scripting.
+.It Fl v
+Verbose mode.
+.It Fl x
+Used with
+.Cm setkey
+command.
+Forces adding of the key if it is not specified for the file system.
+.It Fl Z
+Create chain with zero child key.
+Can be useful for
+.Cm addkey Fl c
+command to verify the key before adding it.
+.El
+.Pp
+.Ss KEY CHAINS
+Key chain consists of one or several elements.
+Each element is defined by a
+.Em parent key
+and a
+.Em child key .
+All elements are stored encrypted in a database file.
+.Pp
+Parent key fingerprint is used as an index to access child key in database.
+Chaining is achieved by reusing child key fingerprint as next index.
+.Pp
+.Ss CONFIGURATION FILE
+In addition to command line options some options can be specified in per file
+system configuration file:
+.Em <filesystem>/.pefs.conf .
+.Em .pefs.conf
+is not a regular file, but a symbolic link.
+.Dq Li Name
+of the file referenced by the link consists of a list of options separated by
+colon.
+Supported option list is the following:
+.Bd -literal -offset indent
+.Em algorithm:iterations
+.Ed
+.Pp
+Note that key chain database entries already contain algorithm used, and
+expected use of the configuration file is to specify
+.Em iterations
+option for
+.Xr pam_pefs 8
+or default
+.Em algorithm ,
+if one adds/removes keys often without using key chain database.
+.Pp
+.Sh SYSCTL VARIABLES
+The following
+.Xr sysctl 8
+variables can be used to control the behavior of
+.Nm
+file systems or monitor
+them.
+.Bl -tag -width indent
+.It Va vfs.pefs.nodes
+Number of active nodes.
+Unlike
+.Xr nullfs 8
+.Nm
+doesn't recycle vnodes as early as possible, but expects kernel to recycle
+vnodes when necessary.
+.It Va vfs.pefs.dircache.enable
+Enable directory content caching.
+Content caching can only be enabled for file systems that are known to properly
+propagate changes to upper levels, and it's permanently disabled for the rest.
+When disabled directory cache subsystem is still used as a file name decryption
+cache for all underlying file systems.
+.It Va vfs.pefs.dircache.entries
+Number of entries in directory cache.
+Directory cache is mainly used as a file name decryption cache, but can also be
+used to cache directory content if underlying file system is known to propagate
+changes to upper levels properly.
+.It Va vfs.pefs.dircache.buckets
+Number of dircache hash table buckets.
+Value can be set as a kernel environment variable by specifying it in
+.Ar /boot/loader.conf
+file, or using
+.Xr kenv 1
+utility
+before loading
+.Nm
+kernel module.
+.El
+.Sh EXAMPLES
+Encrypting a directory:
+.Bd -literal -offset indent
+% mkdir ~/Private
+% pefs mount ~/Private ~/Private
+% pefs addkey ~/Private
+Enter passphrase:
+\&...
+% pefs unmount ~/Private
+.Ed
+.Pp
+In such setup one has to manually check if passphrase valid, because
+.Nm
+would accept any key for a file system.
+Key chaining can be used to verify keys:
+.Bd -literal -offset indent
+% mkdir ~/Private
+% pefs addchain -fZ ~/Private
+Enter parent key passphrase:
+Reenter parent key passphrase:
+% pefs mount ~/Private ~/Private
+% pefs addkey -c ~/Private
+Enter passphrase:
+\&...
+% pefs unmount ~/Private
+.Ed
+.Pp
+In the example key chain database file (~/Private/.pefs.db) is created on
+unencrypted underlying file.
+And
+.Cm addkey Fl c
+is used to force key verification.
+Key chain database file is not encrypted by
+.Nm ,
+but it's is internally encrypted by the utility and there should be no risk.
+.Pp
+Set default number of PKCS#5v2 iterations to 100000 for home directory not
+changing default algorithm:
+.Bd -literal -offset indent
+# make sure ~/ is not encrypted
+% ln -s :100000 ~/.pefs.conf
+.Ed
+.Pp
+.Sh DATA AUTHENTICATION
+.Nm
+provides no data integrity checking.
+Thus it's strongly advised to use additional data integrity checking tools.
+.Sh FILES
+.Bl -tag -width <filesystem>/.pefs.conf -compact
+.It Pa <filesystem>/.pefs.conf
+Configuration file (symbolic link).
+.It Pa <filesystem>/.pefs.db
+Key chain database file.
+.El
+.Sh SEE ALSO
+.Xr kenv 1 ,
+.Xr crypto 4 ,
+.Xr nullfs 5 ,
+.Xr geli 8 ,
+.Xr mount 8 ,
+.Xr sysctl 8
+.Xr umount 8
+.Sh HISTORY
+The
+.Nm
+utility appeared in
+.Fx x.0 .
+.Sh AUTHORS
+.An Gleb Kurtsou Aq gk@FreeBSD.org
diff --git sbin/pefs/pefs_ctl.c sbin/pefs/pefs_ctl.c
new file mode 100644
index 0000000..3a3e952
--- /dev/null
+++ sbin/pefs/pefs_ctl.c
@@ -0,0 +1,1173 @@
+/*-
+ * Copyright (c) 2009 Gleb Kurtsou <gleb@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/ioccom.h>
+#include <sys/module.h>
+#include <sys/mount.h>
+
+#include <assert.h>
+#include <ctype.h>
+#include <inttypes.h>
+#include <libgen.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <err.h>
+#include <errno.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <libutil.h>
+#include <readpassphrase.h>
+
+#include <fs/pefs/pefs.h>
+
+#include "pefs_ctl.h"
+#include "pefs_keychain.h"
+
+#define	PATH_MOUNT		"/sbin/mount"
+#define	PATH_UMOUNT		"/sbin/umount"
+#define	PATH_DEVRANDOM		"/dev/random"
+
+#define	PEFS_KEY_PROMPT_DEFAULT			"passphrase"
+
+static void	pefs_usage(void);
+static void	pefs_usage_alg(void);
+static int	pefs_mount(int argc, char *argv[]);
+static int	pefs_unmount(int argc, char *argv[]);
+static int	pefs_addkey(int argc, char *argv[]);
+static int	pefs_setkey(int argc, char *argv[]);
+static int	pefs_delkey(int argc, char *argv[]);
+static int	pefs_flushkeys(int argc, char *argv[]);
+static int	pefs_addchain(int argc, char *argv[]);
+static int	pefs_delchain(int argc, char *argv[]);
+static int	pefs_randomchain(int argc, char *argv[]);
+static int	pefs_showkeys(int argc, char *argv[]);
+static int	pefs_getkey(int argc, char *argv[]);
+static int	pefs_showchains(int argc, char *argv[]);
+static int	pefs_showalgs(int argc, char *argv[]);
+
+typedef int (*command_func_t)(int argc, char **argv);
+typedef int (*keyop_func_t)(struct pefs_keychain_head *kch, int fd,
+    int verbose);
+
+struct command {
+	const char	*name;
+	command_func_t	func;
+};
+
+static struct command cmds[] = {
+	{ "mount",	pefs_mount },
+	{ "unmount",	pefs_unmount },
+	{ "umount",	pefs_unmount },
+	{ "addkey",	pefs_addkey },
+	{ "setkey",	pefs_setkey },
+	{ "delkey",	pefs_delkey },
+	{ "flushkeys",	pefs_flushkeys },
+	{ "showkeys",	pefs_showkeys },
+	{ "getkey",	pefs_getkey },
+	{ "status",	pefs_showkeys },
+	{ "randomchain", pefs_randomchain },
+	{ "addchain",	pefs_addchain },
+	{ "delchain",	pefs_delchain },
+	{ "showchains",	pefs_showchains },
+	{ "showalgs",	pefs_showalgs },
+	{ NULL, NULL },
+};
+
+void
+pefs_warn(const char *fmt, ...)
+{
+        va_list ap;
+
+        va_start(ap, fmt);
+        vwarnx(fmt, ap);
+        va_end(ap);
+}
+
+static int
+checkargs_fs(int argc, char **argv __unused)
+{
+	if (argc != 1) {
+		if (argc == 0)
+			warnx("missing filesystem argument");
+		else
+			warnx("too many arguments");
+		return (0);
+	}
+
+	return (1);
+}
+
+static void
+initfsroot(int argc, char **argv, int flags, char *fsroot, size_t size)
+{
+	if (!checkargs_fs(argc, argv))
+		pefs_usage();
+
+	if (pefs_getfsroot(argv[0], flags, fsroot, size) != 0)
+		exit(PEFS_ERR_INVALID);
+}
+
+static int
+openx_rdonly(const char *path)
+{
+	int fd;
+
+	fd = open(path, O_RDONLY);
+	if (fd == -1)
+		warn("cannot open %s", path);
+
+	return (fd);
+
+}
+
+struct pefs_readpassfile_ctx {
+	size_t	passphrase_pos;
+	size_t	passphrase_sz;
+	char	*passphrase;
+};
+
+static int
+pefs_readpassfile_handler(void *a, uint8_t *buf, size_t len, const char *file)
+{
+	struct pefs_readpassfile_ctx *ctx = a;
+	char *s;
+
+	if (strlen(buf) != len) {
+		pefs_warn("invalid passfile content: %s.", file);
+		return (PEFS_ERR_INVALID);
+	}
+
+	s = strchr(buf, '\n');
+	if (s != NULL)
+		*s = '\0';
+	if (strlcat(ctx->passphrase, buf, ctx->passphrase_sz) >=
+	    ctx->passphrase_sz) {
+		pefs_warn("passphrase in %s too long.", file);
+		bzero(ctx->passphrase, ctx->passphrase_sz);
+		return (PEFS_ERR_INVALID);
+	}
+
+	return (0);
+}
+
+static int
+pefs_readpassfile(char *passphrase, int passphrase_sz, const char **files,
+    int file_count)
+{
+	struct pefs_readpassfile_ctx ctx;
+	int error;
+
+	ctx.passphrase_pos = 0;
+	ctx.passphrase_sz = passphrase_sz;
+	ctx.passphrase = passphrase;
+
+	bzero(ctx.passphrase, ctx.passphrase_sz);
+
+	error = pefs_readfiles(files, file_count, &ctx,
+	    pefs_readpassfile_handler);
+	if (error != 0)
+		bzero(ctx.passphrase, ctx.passphrase_sz);
+	return (error);
+}
+
+static int
+pefs_readpassphrase(char *passphrase, int passphrase_sz, const char *prompt,
+    int verify)
+{
+	char promptbuf[64], buf[BUFSIZ], buf2[BUFSIZ], *p;
+	int i;
+
+	if (verify)
+		verify = 1;
+	if (prompt == NULL)
+		prompt = PEFS_KEY_PROMPT_DEFAULT;
+	for (i = 0; i <= verify; i++) {
+		snprintf(promptbuf, sizeof(promptbuf), "%s %s:",
+		    !i ? "Enter" : "Reenter", prompt);
+		p = readpassphrase(promptbuf, !i ? buf : buf2, BUFSIZ,
+		    RPP_ECHO_OFF | RPP_REQUIRE_TTY);
+		if (p == NULL || p[0] == '\0') {
+			bzero(buf, sizeof(buf));
+			bzero(buf2, sizeof(buf2));
+			warnx("unable to read passphrase");
+			return (PEFS_ERR_INVALID);
+		}
+	}
+	if (verify && strcmp(buf, buf2) != 0) {
+		bzero(buf, sizeof(buf));
+		bzero(buf2, sizeof(buf2));
+		warnx("passphrases didn't match");
+		return (PEFS_ERR_INVALID);
+	}
+	strlcpy(passphrase, buf, passphrase_sz);
+	bzero(buf2, sizeof(buf2));
+	bzero(buf, sizeof(buf));
+
+	return (0);
+}
+
+static int
+pefs_key_get(struct pefs_xkey *xk, const char *prompt, int verify,
+    struct pefs_keyparam *kp)
+{
+	char buf[BUFSIZ];
+	int error;
+
+	if (kp->kp_passfile_count != 0 && kp->kp_nopassphrase != 0) {
+		pefs_warn("options no-passphrase (-p) and passphrase-file (-j) "
+		    "are mutually exclusive.");
+		return (PEFS_ERR_USAGE);
+	}
+
+	buf[0] = '\0';
+	if (kp->kp_passfile_count != 0) {
+		error = pefs_readpassfile(buf, sizeof(buf), kp->kp_passfile,
+		    kp->kp_passfile_count);
+		if (error != 0)
+			return (error);
+	} else if (kp->kp_nopassphrase == 0) {
+		error = pefs_readpassphrase(buf, sizeof(buf), prompt, verify);
+		if (error != 0)
+			return (error);
+	}
+
+	error = pefs_key_generate(xk, buf, kp);
+	bzero(buf, sizeof(buf));
+
+	return (error);
+}
+
+static inline void
+pefs_key_showind(struct pefs_xkey *xk, int ind)
+{
+	printf("\t%-4d %016jx %s\n", ind, pefs_keyid_as_int(xk->pxk_keyid),
+	    pefs_alg_name(xk));
+}
+
+static inline void
+pefs_key_shownode(struct pefs_xkey *xk, const char *path)
+{
+	const char *basepath;
+
+	basepath = basename(path);
+	if (xk == NULL)
+		printf("Key(%s): <not specified>\n", basepath);
+	else
+		printf("Key(%s): %016jx %s\n", basepath,
+		    pefs_keyid_as_int(xk->pxk_keyid), pefs_alg_name(xk));
+}
+
+static int
+pefs_keychain_lookup(struct pefs_keychain_head *kch, const char *fsroot,
+    int chain_flags, struct pefs_keyparam *kp)
+{
+	struct pefs_xkey k;
+	int error;
+
+	error = pefs_keyparam_init(kp, fsroot);
+	if (error != 0)
+		return (error);
+	error = pefs_key_get(&k, NULL, 0, kp);
+	if (error != 0)
+		return (error);
+
+	error = pefs_keychain_get(kch, fsroot, chain_flags, &k);
+	bzero(&k, sizeof(k));
+	if (error)
+		return (PEFS_ERR_INVALID);
+
+	return (0);
+}
+
+static int
+pefs_keyop(keyop_func_t func, int argc, char *argv[])
+{
+	struct pefs_keychain_head kch;
+	struct pefs_keyparam kp;
+	char fsroot[MAXPATHLEN];
+	int error, fd, i;
+	int chain = PEFS_KEYCHAIN_IGNORE_MISSING;
+	int verbose = 0;
+
+	pefs_keyparam_create(&kp);
+	while ((i = getopt(argc, argv, "cCpva:i:j:k:")) != -1)
+		switch(i) {
+		case 'a':
+			if (pefs_keyparam_setalg(&kp, optarg) != 0)
+				pefs_usage_alg();
+			break;
+		case 'c':
+			chain = PEFS_KEYCHAIN_USE;
+			break;
+		case 'C':
+			chain = 0;
+			break;
+		case 'p':
+			kp.kp_nopassphrase = 1;
+			break;
+		case 'i':
+			if (pefs_keyparam_setiterations(&kp, optarg) != 0)
+				pefs_usage();
+			break;
+		case 'j':
+			if (pefs_keyparam_setfile(&kp, kp.kp_passfile,
+			    optarg) != 0)
+				pefs_usage();
+			break;
+		case 'k':
+			if (pefs_keyparam_setfile(&kp, kp.kp_keyfile,
+			    optarg) != 0)
+				pefs_usage();
+			break;
+		case 'v':
+			verbose = 1;
+			break;
+		default:
+			pefs_usage();
+		}
+	argc -= optind;
+	argv += optind;
+
+	initfsroot(argc, argv, 0, fsroot, sizeof(fsroot));
+
+	error = pefs_keychain_lookup(&kch, fsroot, chain, &kp);
+	if (error != 0)
+		return (error);
+
+	fd = openx_rdonly(fsroot);
+	if (fd == -1) {
+		pefs_keychain_free(&kch);
+		return (PEFS_ERR_IO);
+	}
+
+	error = func(&kch, fd, verbose);
+
+	pefs_keychain_free(&kch);
+
+	close(fd);
+
+	return (error);
+}
+
+static int
+pefs_addkey_op(struct pefs_keychain_head *kch, int fd, int verbose)
+{
+	struct pefs_keychain *kc;
+
+	TAILQ_FOREACH(kc, kch, kc_entry) {
+		if (ioctl(fd, PEFS_ADDKEY, &kc->kc_key) == -1) {
+			warn("cannot add key");
+			return (-1);
+		} else if (verbose)
+			printf("Key added: %016jx\n",
+			    pefs_keyid_as_int(kc->kc_key.pxk_keyid));
+	}
+
+	return (0);
+}
+
+static int
+pefs_delkey_op(struct pefs_keychain_head *kch, int fd, int verbose)
+{
+	struct pefs_keychain *kc;
+
+	TAILQ_FOREACH(kc, kch, kc_entry) {
+		if (ioctl(fd, PEFS_DELKEY, &kc->kc_key) == -1) {
+			warn("cannot delete key");
+		} else if (verbose)
+			printf("Key deleted: %016jx\n",
+			    pefs_keyid_as_int(kc->kc_key.pxk_keyid));
+	}
+
+	return (0);
+}
+
+static int
+pefs_addkey(int argc, char *argv[])
+{
+	return (pefs_keyop(pefs_addkey_op, argc, argv));
+}
+
+static int
+pefs_delkey(int argc, char *argv[])
+{
+	return (pefs_keyop(pefs_delkey_op, argc, argv));
+}
+
+static int
+pefs_setkey(int argc, char *argv[])
+{
+	struct pefs_keychain_head kch;
+	struct pefs_keychain *kc;
+	struct pefs_keyparam kp;
+	char fsroot[MAXPATHLEN];
+	int error, fd, i;
+	int verbose = 0;
+	int addkey = 0;
+	int chain = PEFS_KEYCHAIN_IGNORE_MISSING;
+
+	pefs_keyparam_create(&kp);
+	while ((i = getopt(argc, argv, "cCpvxa:i:j:k:")) != -1)
+		switch(i) {
+		case 'a':
+			if (pefs_keyparam_setalg(&kp, optarg) != 0)
+				pefs_usage_alg();
+			break;
+		case 'c':
+			chain = PEFS_KEYCHAIN_USE;
+			break;
+		case 'C':
+			chain = 0;
+			break;
+		case 'p':
+			kp.kp_nopassphrase = 1;
+			break;
+		case 'i':
+			if (pefs_keyparam_setiterations(&kp, optarg) != 0)
+				pefs_usage();
+			break;
+		case 'j':
+			if (pefs_keyparam_setfile(&kp, kp.kp_passfile,
+			    optarg) != 0)
+				pefs_usage();
+			break;
+		case 'k':
+			if (pefs_keyparam_setfile(&kp, kp.kp_keyfile,
+			    optarg) != 0)
+				pefs_usage();
+			break;
+		case 'v':
+			verbose = 1;
+			break;
+		case 'x':
+			addkey = 1;
+			break;
+		default:
+			pefs_usage();
+		}
+	argc -= optind;
+	argv += optind;
+
+	if (chain == PEFS_KEYCHAIN_USE && addkey) {
+		warnx("invalid argument combination: -x -c");
+		return (PEFS_ERR_USAGE);
+	}
+
+	if (argc != 1) {
+		if (argc == 0)
+			warnx("missing directory argument");
+		else
+			warnx("too many arguments");
+		pefs_usage();
+	}
+
+	initfsroot(argc, argv, 0, fsroot, sizeof(fsroot));
+
+	error = pefs_keychain_lookup(&kch, fsroot, chain, &kp);
+	if (error != 0)
+		return (error);
+
+	fd = openx_rdonly(argv[0]);
+	if (fd == -1) {
+		pefs_keychain_free(&kch);
+		return (PEFS_ERR_IO);
+	}
+
+	if (addkey) {
+		TAILQ_FOREACH(kc, &kch, kc_entry) {
+			if (ioctl(fd, PEFS_ADDKEY, &kc->kc_key) == 0 && verbose)
+				printf("Key added: %016jx\n",
+				    pefs_keyid_as_int(kc->kc_key.pxk_keyid));
+		}
+	}
+	kc = TAILQ_FIRST(&kch);
+	if (ioctl(fd, PEFS_SETKEY, &kc->kc_key) == -1) {
+		warn("cannot set key");
+		error = PEFS_ERR_SYS;
+	} else if (verbose)
+		pefs_key_shownode(&kc->kc_key, argv[0]);
+
+	pefs_keychain_free(&kch);
+
+	close(fd);
+
+	return (error);
+}
+
+static int
+pefs_flushkeys(int argc, char *argv[])
+{
+	char fsroot[MAXPATHLEN];
+	int fd;
+
+	initfsroot(argc, argv, 0, fsroot, sizeof(fsroot));
+
+	fd = openx_rdonly(fsroot);
+	if (fd == -1)
+		return (PEFS_ERR_IO);
+	if (ioctl(fd, PEFS_FLUSHKEYS) == -1) {
+		warn("cannot flush keys");
+		return (PEFS_ERR_IO);
+	}
+	close(fd);
+
+	return (0);
+}
+
+static int
+pefs_getkey(int argc, char *argv[])
+{
+	struct pefs_xkey k;
+	int testonly = 0;
+	int error = 0;
+	int fd, i;
+
+	while ((i = getopt(argc, argv, "t")) != -1)
+		switch(i) {
+		case 't':
+			testonly = 1;
+			break;
+		case '?':
+		default:
+			pefs_usage();
+		}
+	argc -= optind;
+	argv += optind;
+
+	if (argc != 1) {
+		if (argc == 0)
+			warnx("missing file argument");
+		else
+			warnx("too many arguments");
+		pefs_usage();
+	}
+
+	/* only check file system type */
+	if (pefs_getfsroot(argv[0], 0, NULL, 0) != 0)
+		return (PEFS_ERR_INVALID);
+
+	fd = openx_rdonly(argv[0]);
+	if (fd == -1)
+		return (PEFS_ERR_IO);
+
+	bzero(&k, sizeof(k));
+	if (ioctl(fd, PEFS_GETNODEKEY, &k) == -1) {
+		if (errno == ENOENT) {
+			if (testonly == 0)
+				pefs_key_shownode(NULL, argv[0]);
+			else
+				error = PEFS_ERR_GENERIC;
+		} else {
+			warn("cannot get key");
+			error = PEFS_ERR_SYS;
+		}
+	} else if (testonly == 0)
+		pefs_key_shownode(&k, argv[0]);
+
+	close(fd);
+
+	return (error);
+}
+
+static int
+pefs_showkeys(int argc, char *argv[])
+{
+	char fsroot[MAXPATHLEN];
+	struct pefs_xkey k;
+	int testonly = 0;
+	int fd, i;
+
+	while ((i = getopt(argc, argv, "t")) != -1)
+		switch(i) {
+		case 't':
+			testonly = 1;
+			break;
+		case '?':
+		default:
+			pefs_usage();
+		}
+	argc -= optind;
+	argv += optind;
+
+	initfsroot(argc, argv, 0, fsroot, sizeof(fsroot));
+
+	fd = openx_rdonly(fsroot);
+	if (fd == -1)
+		return (PEFS_ERR_IO);
+
+	bzero(&k, sizeof(k));
+	if (ioctl(fd, PEFS_GETKEY, &k) == -1) {
+		if (testonly) {
+			close(fd);
+			return (PEFS_ERR_INVALID);
+		}
+		if (errno == ENOENT)
+			printf("No keys specified\n");
+		else {
+			warn("cannot list keys");
+			close(fd);
+			return (PEFS_ERR_IO);
+		}
+	} else {
+		if (testonly) {
+			close(fd);
+			return (0);
+		}
+		printf("Keys:\n");
+		while (1) {
+			pefs_key_showind(&k, k.pxk_index);
+			k.pxk_index++;
+			if (ioctl(fd, PEFS_GETKEY, &k) == -1)
+				break;
+		}
+	}
+	close(fd);
+
+	return (0);
+}
+
+static int
+pefs_mount(int argc, char *argv[])
+{
+	char **nargv;
+	int nargc, topt, i, shift;
+
+	topt = 0;
+	opterr = 0;
+	while ((i = getopt(argc, argv, "t:")) != -1)
+		switch(i) {
+		case 't':
+			if (strcmp(optarg, PEFS_FSTYPE) != 0) {
+				warnx("invalid file system type: %s",
+				    optarg);
+				return (PEFS_ERR_USAGE);
+			}
+			topt = 1;
+			break;
+		default:
+			break;
+		}
+
+	shift = (topt == 0 ? 2 : 0);
+	nargc = argc + shift + 2;
+	nargv = malloc(nargc * sizeof(*nargv));
+	nargv[0] = __DECONST(char *, "pefs mount");
+	if (topt == 0) {
+		nargv[1] = __DECONST(char *, "-t");
+		nargv[2] = __DECONST(char *, PEFS_FSTYPE);
+	}
+	for (i = 0; i < argc; i++)
+		nargv[i + shift + 1] = argv[i];
+	nargv[nargc - 1] = NULL;
+
+	execv(PATH_MOUNT, nargv);
+	warnx("exec %s", PATH_MOUNT);
+
+	return (PEFS_ERR_SYS);
+}
+
+static int
+pefs_unmount(int argc, char *argv[])
+{
+	char **nargv;
+	int i;
+
+	while ((i = getopt(argc, argv, "fv")) != -1)
+		switch(i) {
+		case 'f':
+		case 'v':
+			break;
+		case '?':
+		default:
+			pefs_usage();
+		}
+	argc -= optind;
+	argv += optind;
+
+	if (!checkargs_fs(argc, argv))
+		pefs_usage();
+
+	nargv = malloc((argc + 2) * sizeof(*nargv));
+	for (i = 0; i < argc; i++)
+		nargv[i + 1] = argv[i];
+	nargv[0] = __DECONST(char *, "pefs unmount");
+	nargv[argc + 1] = NULL;
+
+	execv(PATH_UMOUNT, nargv);
+	warnx("exec %s", PATH_UMOUNT);
+
+	return (PEFS_ERR_SYS);
+}
+
+static int
+pefs_addchain(int argc, char *argv[])
+{
+	struct pefs_keychain *kc;
+	struct pefs_keychain_head kch;
+	struct {
+		struct pefs_xkey k;
+		struct pefs_keyparam kp;
+	} p[2];
+	struct pefs_xkey *k1 = &p[0].k, *k2 = &p[1].k;
+	struct pefs_keyparam *kpi;
+	char fsroot[MAXPATHLEN];
+	int fsflags = 0, verbose = 0;
+	int zerochainedkey = 0, optchainedkey = 0;
+	int error, i, fd;
+
+	pefs_keyparam_create(&p[0].kp);
+	pefs_keyparam_create(&p[1].kp);
+	while ((i = getopt(argc, argv, "a:A:i:I:j:J:k:K:fpPvZ")) != -1)
+		switch(i) {
+		case 'v':
+			verbose = 1;
+			break;
+		case 'f':
+			fsflags |= PEFS_FS_IGNORE_TYPE;
+			break;
+		case 'Z':
+			zerochainedkey = 1;
+			break;
+		case 'a':
+		case 'A':
+			if (isupper(i))
+				optchainedkey = i;
+			kpi = &p[isupper(i) ? 1 : 0].kp;
+			if (pefs_keyparam_setalg(kpi, optarg) != 0)
+				pefs_usage_alg();
+			break;
+		case 'p':
+		case 'P':
+			if (isupper(i))
+				optchainedkey = i;
+			kpi = &p[isupper(i) ? 1 : 0].kp;
+			kpi->kp_nopassphrase = 1;
+			break;
+		case 'i':
+		case 'I':
+			if (isupper(i))
+				optchainedkey = i;
+			kpi = &p[isupper(i) ? 1 : 0].kp;
+			if (pefs_keyparam_setiterations(kpi, optarg) != 0)
+				pefs_usage();
+			break;
+		case 'j':
+		case 'J':
+			if (isupper(i))
+				optchainedkey = i;
+			kpi = &p[isupper(i) ? 1 : 0].kp;
+			if (pefs_keyparam_setfile(kpi, kpi->kp_passfile,
+			    optarg) != 0)
+				pefs_usage();
+			break;
+		case 'k':
+		case 'K':
+			if (isupper(i))
+				optchainedkey = i;
+			kpi = &p[isupper(i) ? 1 : 0].kp;
+			if (pefs_keyparam_setfile(kpi, kpi->kp_keyfile,
+			    optarg) != 0)
+				pefs_usage();
+			break;
+		default:
+			pefs_usage();
+		}
+	argc -= optind;
+	argv += optind;
+
+	if (optchainedkey && zerochainedkey) {
+		warnx("invalid argument combination: -Z -%c",
+		    optchainedkey);
+		return (PEFS_ERR_USAGE);
+	}
+
+	initfsroot(argc, argv, fsflags, fsroot, sizeof(fsroot));
+
+	error = pefs_keyparam_init(&p[0].kp, fsroot);
+	if (error != 0)
+		return (error);
+	error = pefs_keyparam_init(&p[1].kp, fsroot);
+	if (error != 0)
+		return (error);
+
+	error = pefs_key_get(k1, "parent key passphrase", 1, &p[0].kp);
+	if (error != 0) {
+		bzero(p, sizeof(p));
+		return (error);
+	}
+
+	if (zerochainedkey) {
+		fd = openx_rdonly(PATH_DEVRANDOM);
+		if (fd == -1) {
+			bzero(p, sizeof(p));
+			return (PEFS_ERR_IO);
+		}
+		read(fd, k2, sizeof(struct pefs_keychain));
+		close(fd);
+		k2->pxk_alg = PEFS_ALG_INVALID;
+		error = pefs_keychain_set(fsroot, k1, k2);
+		bzero(p, sizeof(p));
+		if (error)
+			return (PEFS_ERR_INVALID);
+		return (0);
+	}
+
+	error = pefs_key_get(k2, "chained key passphrase", 1, &p[1].kp);
+	if (error != 0) {
+		bzero(p, sizeof(p));
+		return (error);
+	}
+
+	pefs_keychain_get(&kch, fsroot, PEFS_KEYCHAIN_IGNORE_MISSING, k1);
+	TAILQ_FOREACH(kc, &kch, kc_entry) {
+		if (memcmp(k2->pxk_keyid, kc->kc_key.pxk_keyid,
+		    PEFS_KEYID_SIZE) == 0) {
+			pefs_keychain_free(&kch);
+			bzero(k1->pxk_key, PEFS_KEY_SIZE);
+			bzero(k2->pxk_key, PEFS_KEY_SIZE);
+			warnx("key chain is already set: %016jx -> %016jx",
+			    pefs_keyid_as_int(k1->pxk_keyid),
+			    pefs_keyid_as_int(k2->pxk_keyid));
+			pefs_keychain_free(&kch);
+			return (PEFS_ERR_INVALID);
+		}
+	}
+	kc = TAILQ_FIRST(&kch);
+	if (TAILQ_NEXT(kc, kc_entry) != NULL) {
+		bzero(k1->pxk_key, PEFS_KEY_SIZE);
+		bzero(k2->pxk_key, PEFS_KEY_SIZE);
+		warnx("key chain for parent key is already set: "
+		    "%016jx -> %016jx",
+		    pefs_keyid_as_int(kc->kc_key.pxk_keyid),
+		    pefs_keyid_as_int(
+			TAILQ_NEXT(kc, kc_entry)->kc_key.pxk_keyid));
+		pefs_keychain_free(&kch);
+		return (PEFS_ERR_INVALID);
+	}
+	pefs_keychain_free(&kch);
+
+	error = pefs_keychain_set(fsroot, k1, k2);
+	bzero(k1->pxk_key, PEFS_KEY_SIZE);
+	bzero(k2->pxk_key, PEFS_KEY_SIZE);
+	if (error)
+		return (PEFS_ERR_INVALID);
+	if (verbose) {
+		if (zerochainedkey)
+			printf("Key chain set: %016jx\n",
+			    pefs_keyid_as_int(k1->pxk_keyid));
+		else
+			printf("Key chain set: %016jx -> %016jx\n",
+			    pefs_keyid_as_int(k1->pxk_keyid),
+			    pefs_keyid_as_int(k2->pxk_keyid));
+	}
+
+	return (0);
+}
+
+static int
+pefs_delchain(int argc, char *argv[])
+{
+	struct pefs_keyparam kp;
+	struct pefs_keychain *kc, *kc_next;
+	struct pefs_keychain_head kch;
+	char fsroot[MAXPATHLEN];
+	int deleteall = 0, fsflags = 0, verbose = 0;
+	int error, i;
+
+	pefs_keyparam_create(&kp);
+	while ((i = getopt(argc, argv, "fFvpi:j:k:")) != -1)
+		switch(i) {
+		case 'f':
+			fsflags |= PEFS_FS_IGNORE_TYPE;
+			break;
+		case 'F':
+			deleteall = 1;
+			break;
+		case 'v':
+			verbose = 1;
+			break;
+		case 'p':
+			kp.kp_nopassphrase = 1;
+			break;
+		case 'i':
+			if (pefs_keyparam_setiterations(&kp, optarg) != 0)
+				pefs_usage();
+			break;
+		case 'j':
+			if (pefs_keyparam_setfile(&kp, kp.kp_passfile,
+			    optarg) != 0)
+				pefs_usage();
+			break;
+		case 'k':
+			if (pefs_keyparam_setfile(&kp, kp.kp_keyfile,
+			    optarg) != 0)
+				pefs_usage();
+		default:
+			pefs_usage();
+		}
+	argc -= optind;
+	argv += optind;
+
+	initfsroot(argc, argv, fsflags, fsroot, sizeof(fsroot));
+
+	error = pefs_keychain_lookup(&kch, fsroot, PEFS_KEYCHAIN_USE, &kp);
+	if (error != 0)
+		return (error);
+
+	TAILQ_FOREACH(kc, &kch, kc_entry) {
+		kc_next = TAILQ_NEXT(kc, kc_entry);
+		error = pefs_keychain_del(fsroot,
+		    kc_next == NULL ? PEFS_KEYCHAIN_IGNORE_MISSING : 0,
+		    &kc->kc_key);
+		if (error != 0)
+			break;
+		if (verbose) {
+			if (kc_next == NULL)
+				printf("Key chain deleted: %016jx\n",
+				    pefs_keyid_as_int(kc->kc_key.pxk_keyid));
+			else
+				printf("Key chain deleted: %016jx -> %016jx\n",
+				    pefs_keyid_as_int(kc->kc_key.pxk_keyid),
+				    pefs_keyid_as_int(
+					kc_next->kc_key.pxk_keyid));
+		}
+		if (!deleteall)
+			break;
+	}
+	pefs_keychain_free(&kch);
+
+	return (0);
+}
+
+static int
+pefs_showchains(int argc, char *argv[])
+{
+	struct pefs_keyparam kp;
+	struct pefs_keychain *kc;
+	struct pefs_keychain_head kch;
+	char fsroot[MAXPATHLEN];
+	int fsflags = 0;
+	int error, i;
+
+	pefs_keyparam_create(&kp);
+	while ((i = getopt(argc, argv, "fpi:j:k:")) != -1)
+		switch(i) {
+		case 'f':
+			fsflags |= PEFS_FS_IGNORE_TYPE;
+			break;
+		case 'p':
+			kp.kp_nopassphrase = 1;
+			break;
+		case 'i':
+			if (pefs_keyparam_setiterations(&kp, optarg) != 0)
+				pefs_usage();
+			break;
+		case 'j':
+			if (pefs_keyparam_setfile(&kp, kp.kp_passfile,
+			    optarg) != 0)
+				pefs_usage();
+		case 'k':
+			if (pefs_keyparam_setfile(&kp, kp.kp_keyfile,
+			    optarg) != 0)
+				pefs_usage();
+			break;
+		default:
+			pefs_usage();
+		}
+	argc -= optind;
+	argv += optind;
+
+	initfsroot(argc, argv, fsflags, fsroot, sizeof(fsroot));
+
+	error = pefs_keychain_lookup(&kch, fsroot, PEFS_KEYCHAIN_USE, &kp);
+	if (error)
+		return (PEFS_ERR_INVALID);
+
+	printf("Key chain:\n");
+	i = 1;
+	TAILQ_FOREACH(kc, &kch, kc_entry) {
+		pefs_key_showind(&kc->kc_key, i++);
+	}
+	pefs_keychain_free(&kch);
+
+	return (0);
+}
+
+static int
+pefs_randomchain(int argc, char *argv[])
+{
+	struct pefs_xkey k[2];
+	char fsroot[MAXPATHLEN];
+	int nmin = PEFS_RANDOMCHAIN_MIN, nmax = PEFS_RANDOMCHAIN_MAX;
+	int fsflags = 0, verbose = 0;
+	int i, n, fd;
+
+	k[0].pxk_index = k[1].pxk_index = -1;
+	while ((i = getopt(argc, argv, "vfn:N:")) != -1)
+		switch(i) {
+		case 'v':
+			verbose = 1;
+			break;
+		case 'f':
+			fsflags |= PEFS_FS_IGNORE_TYPE;
+			break;
+		case 'n':
+			if ((nmin = atoi(optarg)) <= 0) {
+				warnx("invalid lower bound argument: %s",
+				    optarg);
+				pefs_usage();
+			}
+			break;
+		case 'N':
+			if ((nmax = atoi(optarg)) <= 0) {
+				warnx("invalid lower bound argument: %s",
+				    optarg);
+				pefs_usage();
+			}
+			break;
+		default:
+			pefs_usage();
+		}
+	argc -= optind;
+	argv += optind;
+
+	if (nmin >= nmax) {
+		warnx("invalid arguments: "
+		    "lower bound (%d) >= upper bound (%d)", nmin, nmax);
+		return (PEFS_ERR_USAGE);
+	}
+
+	initfsroot(argc, argv, fsflags, fsroot, sizeof(fsroot));
+
+	n = arc4random_uniform(nmax - nmin) + nmin;
+	n /= 2;
+
+	fd = openx_rdonly(PATH_DEVRANDOM);
+	if (fd == -1)
+		return (PEFS_ERR_IO);
+
+	for (i = 1; i <= n; i++) {
+		read(fd, k, sizeof(k));
+		k[0].pxk_alg = PEFS_ALG_INVALID;
+		k[1].pxk_alg = PEFS_ALG_INVALID;
+		pefs_keychain_set(fsroot, &k[0], &k[1]);
+		if (verbose)
+			printf("Key chain set: %016jx -> %016jx\n",
+			    pefs_keyid_as_int(k[0].pxk_keyid),
+			    pefs_keyid_as_int(k[1].pxk_keyid));
+	}
+
+	close(fd);
+
+	return (0);
+}
+
+static int
+pefs_showalgs(int argc, char *argv[] __unused)
+{
+	if (argc != 0)
+		pefs_usage();
+
+	pefs_alg_list(stdout);
+
+	return (0);
+}
+
+static void
+pefs_usage_alg(void)
+{
+	pefs_alg_list(stderr);
+	exit(PEFS_ERR_USAGE);
+}
+
+static void
+pefs_usage(void)
+{
+	fprintf(stderr,
+"usage:	pefs mount [-o options] [from filesystem]\n"
+"	pefs unmount [-fv] filesystem\n"
+"	pefs addkey [-cCpv] [-a alg] [-i iterations] [-j passfile] [-k keyfile] filesystem\n"
+"	pefs delkey [-cCpv] [-i iterations] [-j passfile] [-k keyfile] filesystem\n"
+"	pefs flushkeys filesystem\n"
+"	pefs getkey [-t] file\n"
+"	pefs setkey [-cCpvx] [-a alg] [-i iterations] [-j passfile] [-k keyfile] directory\n"
+"	pefs showkeys [-t] filesystem\n"
+"	pefs addchain [-fpPvZ] [-a alg] [-i iterations] [-j passfile] [-k keyfile]\n"
+"		[-A alg] [-I iterations] [-J passfile] [-K keyfile] filesystem\n"
+"	pefs delchain [-fFpv] [-i iterations] [-j passfile] [-k keyfile] filesystem\n"
+"	pefs randomchain [-fv] [-n min] [-N max] filesystem\n"
+"	pefs showchains [-fp] [-i iterations] [-j passfile] [-k keyfile] filesystem\n"
+"	pefs showalgs\n"
+);
+	exit(PEFS_ERR_USAGE);
+}
+
+static void
+pefs_kld_load(void)
+{
+	if (modfind(PEFS_KLD) < 0)
+		if (kld_load(PEFS_KLD) < 0 || modfind(PEFS_KLD) < 0)
+			errx(PEFS_ERR_SYS,
+			    "cannot find or load \"%s\" kernel module",
+			    PEFS_KLD);
+}
+
+int
+main(int argc, char *argv[])
+{
+	struct command *cmd = NULL;
+	char *prog;
+
+	prog = strrchr(argv[0], '/');
+	if (prog == NULL)
+		prog = argv[0];
+
+	if (argc <= 1)
+		pefs_usage();
+
+	for (cmd = cmds; cmd->name; cmd++) {
+		if (strcmp(cmd->name, argv[1]) == 0) {
+			argc -= 2;
+			argv += 2;
+			optind = 0;
+			optreset = 1;
+			pefs_kld_load();
+			return (cmd->func(argc, argv));
+		}
+	}
+
+	warnx("unknown command: %s", argv[1]);
+	pefs_usage();
+
+	return (1);
+}
diff --git sbin/pefs/pefs_ctl.h sbin/pefs/pefs_ctl.h
new file mode 100644
index 0000000..c0618e2
--- /dev/null
+++ sbin/pefs/pefs_ctl.h
@@ -0,0 +1,114 @@
+/*-
+ * Copyright (c) 2009 Gleb Kurtsou <gleb@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#include <inttypes.h>
+
+#define	PEFS_FSTYPE			"pefs"
+#define	PEFS_KLD			PEFS_FSTYPE
+
+#define	PEFS_ALG_DEFAULT		PEFS_ALG_AES_XTS
+#define	PEFS_ALG_DEFAULT_KEYBITS	128
+
+#define	PEFS_KDF_ITERATIONS		50000
+
+#define	PEFS_FILE_KEYCHAIN		".pefs.db"
+#define	PEFS_FILE_KEYCONF		".pefs.conf"
+
+#define	PEFS_KEYCONF_ALG_IND		0
+#define	PEFS_KEYCONF_ITERATIONS_IND	1
+
+#define	PEFS_RANDOMCHAIN_MIN		16
+#define	PEFS_RANDOMCHAIN_MAX		64
+
+#define	PEFS_KEYENC_MAC_SIZE		(PEFS_KEY_SIZE / 2)
+
+#define PEFS_KEYPARAM_FILES_MAX		16
+
+#define	PEFS_ERR_GENERIC		1
+#define	PEFS_ERR_USAGE			2
+#define	PEFS_ERR_IO			3
+#define	PEFS_ERR_SYS			4
+#define	PEFS_ERR_NOENT			5
+#define	PEFS_ERR_EXIST			6
+#define	PEFS_ERR_INVALID		7
+
+#define	PEFS_FS_IGNORE_TYPE		0x0001
+
+struct pefs_xkeyenc {
+	struct {
+		struct pefs_xkey	ke_next;
+		uint32_t		ke_alg;
+		uint32_t		ke_keybits;
+	} a;
+	u_char		ke_mac[PEFS_KEYENC_MAC_SIZE];
+};
+
+struct pefs_keyparam {
+	int		kp_alg;
+	int		kp_keybits;
+	int		kp_nopassphrase;
+	int		kp_iterations;
+	int		kp_keyfile_count;
+	int		kp_passfile_count;
+	const char	*kp_keyfile[PEFS_KEYPARAM_FILES_MAX];
+	const char	*kp_passfile[PEFS_KEYPARAM_FILES_MAX];
+};
+
+void	pefs_warn(const char *, ...) __printf0like(1, 2);
+
+int	pefs_getfsroot(const char *path, int flags, char *fsroot, size_t size);
+int	pefs_readfiles(const char **files, size_t count, void *ctx,
+	    int (*handler)(void *, uint8_t *, size_t, const char *));
+
+int	pefs_key_generate(struct pefs_xkey *xk, const char *passphrase,
+	    struct pefs_keyparam *kp);
+int	pefs_key_encrypt(struct pefs_xkeyenc *xe,
+	    const struct pefs_xkey *xk_parent);
+int	pefs_key_decrypt(struct pefs_xkeyenc *xe,
+	    const struct pefs_xkey *xk_parent);
+uintmax_t	pefs_keyid_as_int(char *keyid);
+
+const char *	pefs_alg_name(struct pefs_xkey *xk);
+void	pefs_alg_list(FILE *stream);
+
+int	pefs_keyparam_init(struct pefs_keyparam *kp, const char *fsroot);
+int	pefs_keyparam_setalg(struct pefs_keyparam *kp, const char *algname);
+int	pefs_keyparam_setiterations(struct pefs_keyparam *kp, const char *arg);
+int	pefs_keyparam_setfile(struct pefs_keyparam *kp, const char **files,
+    const char *arg);
+
+static inline void
+pefs_keyparam_create(struct pefs_keyparam *kp)
+{
+	kp->kp_nopassphrase = 0;
+	kp->kp_iterations = -1;
+	kp->kp_keyfile_count = 0;
+	kp->kp_passfile_count = 0;
+	kp->kp_alg = 0;
+	kp->kp_keybits = 0;
+}
diff --git sbin/pefs/pefs_key.c sbin/pefs/pefs_key.c
new file mode 100644
index 0000000..e6e258a
--- /dev/null
+++ sbin/pefs/pefs_key.c
@@ -0,0 +1,386 @@
+/*-
+ * Copyright (c) 2004-2008 Pawel Jakub Dawidek <pjd@FreeBSD.org>
+ * Copyright (c) 2009 Gleb Kurtsou <gleb@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/types.h>
+#include <sys/errno.h>
+#include <assert.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include <crypto/hmac/hmac.h>
+#include <crypto/pkcs5v2/pkcs5v2.h>
+#include <crypto/rijndael/rijndael.h>
+#include <opencrypto/cryptodev.h>
+#include <fs/pefs/pefs.h>
+
+#include "pefs_ctl.h"
+
+#define AES_BLOCK_SIZE		16
+
+struct algorithm {
+	const char		*name;
+	uint32_t		id;
+	uint32_t		keybits;
+};
+
+static struct algorithm algs[] = {
+	{ "aes128-xts",		PEFS_ALG_AES_XTS, 128 },
+	{ "aes128",		PEFS_ALG_AES_XTS, 128 },
+	{ "aes192-xts",		PEFS_ALG_AES_XTS, 192 },
+	{ "aes192",		PEFS_ALG_AES_XTS, 192 },
+	{ "aes256-xts",		PEFS_ALG_AES_XTS, 256 },
+	{ "aes256",		PEFS_ALG_AES_XTS, 256 },
+	{ "camellia128-xts",	PEFS_ALG_CAMELLIA_XTS, 128 },
+	{ "camellia128",	PEFS_ALG_CAMELLIA_XTS, 128 },
+	{ "camellia192-xts",	PEFS_ALG_CAMELLIA_XTS, 192 },
+	{ "camellia192",	PEFS_ALG_CAMELLIA_XTS, 192 },
+	{ "camellia256-xts",	PEFS_ALG_CAMELLIA_XTS, 256 },
+	{ "camellia256",	PEFS_ALG_CAMELLIA_XTS, 256 },
+	{ NULL, 0, 0 },
+};
+
+static char magic_keyid_info[] = "<KEY ID>";
+static char magic_enckey_info[] = "<ENCRYPTED KEY>";
+
+static void
+pefs_aes_ctr(const rijndael_ctx *aes_ctx, const uint8_t *iv,
+    const uint8_t *plaintext, uint8_t *ciphertext, int len)
+{
+	uint8_t ctr[AES_BLOCK_SIZE];
+	uint8_t block[AES_BLOCK_SIZE];
+	int l, i;
+
+	if (iv != NULL)
+		memcpy(ctr, iv, sizeof(ctr));
+	else
+		bzero(ctr, sizeof(ctr));
+
+	while (len > 0) {
+		rijndael_encrypt(aes_ctx, ctr, block);
+		l = (len < AES_BLOCK_SIZE ? len : AES_BLOCK_SIZE);
+		for (i = 0; i < l; i++)
+			*(ciphertext++) = block[i] ^ *(plaintext++);
+		/* Increment counter */
+		for (i = 0; i < AES_BLOCK_SIZE; i++) {
+			ctr[i]++;
+			if (ctr[i] != 0)
+				break;
+		}
+		len -= l;
+	}
+}
+
+const char *
+pefs_alg_name(struct pefs_xkey *xk)
+{
+	struct algorithm *alg;
+
+	for (alg = algs; alg->name != NULL; alg++) {
+		if (alg->id == xk->pxk_alg && alg->keybits == xk->pxk_keybits)
+			return (alg->name);
+	}
+
+	return ("<unknown algorithm>");
+}
+
+void
+pefs_alg_list(FILE *stream)
+{
+	struct algorithm *prev, *alg;
+
+	fprintf(stream, "Supported algorithms:\n");
+	for (prev = NULL, alg = algs; alg->name != NULL; prev = alg++) {
+		if (prev != NULL && alg->id == prev->id &&
+		    alg->keybits == prev->keybits)
+			fprintf(stream, "\t%-16s (alias for %s)\n", alg->name, prev->name);
+		else if (alg->id == PEFS_ALG_DEFAULT &&
+		    alg->keybits == PEFS_ALG_DEFAULT_KEYBITS)
+			fprintf(stream, "\t%-16s (default)\n", alg->name);
+		else
+			fprintf(stream, "\t%s\n", alg->name);
+	}
+}
+
+int
+pefs_keyparam_setalg(struct pefs_keyparam *kp, const char *algname)
+{
+	struct algorithm *alg;
+
+	for (alg = algs; alg->name != NULL; alg++) {
+		if (strcmp(algname, alg->name) == 0) {
+			kp->kp_alg = alg->id;
+			kp->kp_keybits = alg->keybits;
+			return (0);
+		}
+	}
+
+	pefs_warn("invalid algorithm %s", algname);
+	return (PEFS_ERR_INVALID);
+}
+
+int
+pefs_keyparam_setiterations(struct pefs_keyparam *kp, const char *arg)
+{
+	kp->kp_iterations = atoi(arg);
+	if (kp->kp_iterations < 0) {
+		pefs_warn("invalid iterations number: %s", arg);
+		return (PEFS_ERR_INVALID);
+	}
+
+	return (0);
+}
+
+int
+pefs_keyparam_setfile(struct pefs_keyparam *kp, const char **files,
+    const char *arg)
+{
+	int *countp;
+
+	if (files == kp->kp_keyfile)
+		countp = &kp->kp_keyfile_count;
+	else if (files == kp->kp_passfile)
+		countp = &kp->kp_passfile_count;
+	else {
+		pefs_warn("internal error. invalid key parameters file type");
+		return (PEFS_ERR_INVALID);
+	}
+	if (arg == NULL || arg[0] == '\0') {
+		pefs_warn("invalid key file");
+		return (PEFS_ERR_INVALID);
+	}
+	if (*countp == PEFS_KEYPARAM_FILES_MAX) {
+		pefs_warn("key file limit exceed, %d max",
+		    PEFS_KEYPARAM_FILES_MAX);
+		return (PEFS_ERR_INVALID);
+	}
+	files[(*countp)++] = arg;
+
+	return (0);
+}
+
+static int
+pefs_keyparam_handle(struct pefs_keyparam *kp, int ind, const char *param)
+{
+	int err;
+
+	if (*param == '\0')
+		return (0);
+
+	switch (ind) {
+	case PEFS_KEYCONF_ALG_IND:
+		err = pefs_keyparam_setalg(kp, param);
+		break;
+	case PEFS_KEYCONF_ITERATIONS_IND:
+		err = pefs_keyparam_setiterations(kp, param);
+		break;
+	default:
+		pefs_warn("invalid configuration option at position %d: %s",
+		    ind + 1, param);
+		err = PEFS_ERR_USAGE;
+	}
+
+	return (err);
+}
+
+int
+pefs_keyparam_init(struct pefs_keyparam *kp, const char *fsroot)
+{
+	char conffile[MAXPATHLEN];
+	char buf[BUFSIZ];
+	char *s, *e;
+	int ind, err;
+	ssize_t bufsz;
+
+	snprintf(conffile, sizeof(conffile), "%s/%s", fsroot,
+	    PEFS_FILE_KEYCONF);
+	bufsz = readlink(conffile, buf, sizeof(buf));
+	if (bufsz > 0 && bufsz < (ssize_t)sizeof(buf)) {
+		buf[bufsz] = '\0';
+		e = buf;
+		for (ind = 0; e != NULL; ind++) {
+			s = e;
+			e = strchr(s, ':');
+			if (e != NULL)
+				*(e++) = '\0';
+			err = pefs_keyparam_handle(kp, ind, s);
+			if (err != 0)
+				return (err);
+		}
+	}
+	if (kp->kp_iterations < 0)
+		kp->kp_iterations = PEFS_KDF_ITERATIONS;
+	if (kp->kp_alg <= 0) {
+		kp->kp_alg = PEFS_ALG_DEFAULT;
+		kp->kp_keybits = PEFS_ALG_DEFAULT_KEYBITS;
+	}
+
+	return (0);
+}
+
+uintmax_t
+pefs_keyid_as_int(char *keyid)
+{
+	uintmax_t r;
+	int i;
+
+	assert(sizeof(uintmax_t) >= PEFS_KEYID_SIZE);
+	for (i = 0, r = 0; i < PEFS_KEYID_SIZE; i++) {
+		if (i)
+			r <<= 8;
+		r |= keyid[i] & 0xff;
+	}
+
+	return (r);
+}
+
+static int
+pefs_readkeyfile_handler(void *a, uint8_t *buf, size_t len,
+    const char *file __unused)
+{
+	struct hmac_ctx *ctx = a;
+
+	hmac_update(ctx, buf, len);
+
+	return (0);
+}
+
+int
+pefs_key_generate(struct pefs_xkey *xk, const char *passphrase,
+    struct pefs_keyparam *kp)
+{
+	struct hmac_ctx ctx;
+	int error;
+
+	if (kp->kp_alg <= 0 || kp->kp_keybits <= 0 ||
+	    kp->kp_iterations < 0) {
+		pefs_warn("key parameters are not initialized");
+		return (PEFS_ERR_INVALID);
+	}
+
+	xk->pxk_index = -1;
+	xk->pxk_alg = kp->kp_alg;
+	xk->pxk_keybits = kp->kp_keybits;
+
+	hmac_init(&ctx, CRYPTO_SHA2_512_HMAC, NULL, 0);
+
+	if (kp->kp_keyfile_count == 0 && passphrase[0] == '\0') {
+		pefs_warn("no key components given");
+		return (PEFS_ERR_USAGE);
+	}
+	if (kp->kp_keyfile_count != 0) {
+		error = pefs_readfiles(kp->kp_keyfile, kp->kp_keyfile_count,
+		    &ctx, pefs_readkeyfile_handler);
+		if (error != 0)
+			return (error);
+	}
+
+	if (passphrase[0] != '\0') {
+		if (kp->kp_iterations == 0) {
+			hmac_update(&ctx, passphrase,
+			    strlen(passphrase));
+		} else {
+			pkcs5v2_genkey(xk->pxk_key, PEFS_KEY_SIZE,
+			    passphrase, 0, passphrase,
+			    kp->kp_iterations);
+			hmac_update(&ctx, xk->pxk_key,
+			    PEFS_KEY_SIZE);
+		}
+	}
+	hmac_final(&ctx, xk->pxk_key, PEFS_KEY_SIZE);
+
+	hmac_init(&ctx, CRYPTO_SHA2_512_HMAC, xk->pxk_key, PEFS_KEY_SIZE);
+	hmac_update(&ctx, magic_keyid_info, sizeof(magic_keyid_info));
+	hmac_final(&ctx, xk->pxk_keyid, PEFS_KEYID_SIZE);
+
+	bzero(&ctx, sizeof(ctx));
+
+	return (0);
+}
+
+static int
+pefs_key_cipher(struct pefs_xkeyenc *xe, int enc,
+    const struct pefs_xkey *xk_parent)
+{
+	struct hmac_ctx hmac_ctx;
+	rijndael_ctx enc_ctx;
+	uint8_t key[PEFS_KEY_SIZE];
+	uint8_t mac[PEFS_KEYENC_MAC_SIZE];
+	uint8_t *data = (uint8_t *) &xe->a;
+	const int datasize = sizeof(xe->a);
+	const int keysize = 128 / 8;
+
+	bzero(key, PEFS_KEY_SIZE);
+	hmac_init(&hmac_ctx, CRYPTO_SHA2_512_HMAC, xk_parent->pxk_key,
+	    PEFS_KEY_SIZE);
+	hmac_update(&hmac_ctx, magic_enckey_info,
+	    sizeof(magic_enckey_info));
+	hmac_final(&hmac_ctx, key, PEFS_KEY_SIZE);
+
+	hmac_init(&hmac_ctx, CRYPTO_SHA2_512_HMAC, key, PEFS_KEY_SIZE);
+
+	if (!enc) {
+		hmac_update(&hmac_ctx, data, datasize);
+		hmac_final(&hmac_ctx, mac, PEFS_KEYENC_MAC_SIZE);
+		bzero(&hmac_ctx, sizeof(hmac_ctx));
+		if (memcmp(mac, xe->ke_mac, PEFS_KEYENC_MAC_SIZE) != 0)
+			return (PEFS_ERR_INVALID);
+	}
+
+	rijndael_set_key(&enc_ctx, key, keysize * 8);
+	pefs_aes_ctr(&enc_ctx, NULL, data, data, datasize);
+	bzero(key, sizeof(key));
+	bzero(&enc_ctx, sizeof(enc_ctx));
+
+	if (enc) {
+		hmac_update(&hmac_ctx, data, datasize);
+		hmac_final(&hmac_ctx, xe->ke_mac,
+		    PEFS_KEYENC_MAC_SIZE);
+		bzero(&hmac_ctx, sizeof(hmac_ctx));
+	}
+
+	return (0);
+}
+
+int
+pefs_key_encrypt(struct pefs_xkeyenc *xe, const struct pefs_xkey *xk_parent)
+{
+	return (pefs_key_cipher(xe, 1, xk_parent));
+}
+
+int
+pefs_key_decrypt(struct pefs_xkeyenc *xe, const struct pefs_xkey *xk_parent)
+{
+	return (pefs_key_cipher(xe, 0, xk_parent));
+}
diff --git sbin/pefs/pefs_keychain.c sbin/pefs/pefs_keychain.c
new file mode 100644
index 0000000..b66f06b
--- /dev/null
+++ sbin/pefs/pefs_keychain.c
@@ -0,0 +1,282 @@
+/*-
+ * Copyright (c) 2009 Gleb Kurtsou <gleb@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/endian.h>
+#include <sys/stat.h>
+#include <assert.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <db.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <errno.h>
+
+#include <fs/pefs/pefs.h>
+
+#include "pefs_ctl.h"
+#include "pefs_keychain.h"
+
+static DB *
+keychain_dbopen(const char *filesystem, int kc_flags, int flags)
+{
+	char buf[MAXPATHLEN];
+	DB *db;
+
+	snprintf(buf, sizeof(buf), "%s/%s", filesystem, PEFS_FILE_KEYCHAIN);
+	db = dbopen(buf, flags | O_EXLOCK, S_IRUSR | S_IWUSR, DB_BTREE, NULL);
+	if (db == NULL && (kc_flags & PEFS_KEYCHAIN_USE || errno != ENOENT))
+		pefs_warn("key chain %s: %s", buf, strerror(errno));
+	return (db);
+}
+
+void
+pefs_keychain_free(struct pefs_keychain_head *kch)
+{
+	struct pefs_keychain *kc;
+
+	if (kch == NULL)
+		return;
+	while ((kc = TAILQ_FIRST(kch)) != NULL) {
+		TAILQ_REMOVE(kch, kc, kc_entry);
+		bzero(kc, sizeof(struct pefs_keychain));
+		free(kc);
+	}
+}
+
+static int
+pefs_keychain_get_db(DB *db, struct pefs_keychain_head *kch)
+{
+	struct pefs_keychain *kc_parent = NULL, *kc = NULL;
+	struct pefs_xkeyenc ke;
+	DBT db_key, db_data;
+	int error;
+
+	while (1) {
+		kc_parent = TAILQ_LAST(kch, pefs_keychain_head);
+		TAILQ_FOREACH(kc, kch, kc_entry) {
+			if (kc != kc_parent &&
+			    memcmp(kc->kc_key.pxk_keyid,
+			    kc_parent->kc_key.pxk_keyid,
+			    PEFS_KEYID_SIZE) == 0) {
+				pefs_warn("key chain loop detected: %016jx",
+				    pefs_keyid_as_int(kc->kc_key.pxk_keyid));
+				error = PEFS_ERR_INVALID;
+				break;
+			}
+		}
+		kc = NULL;
+		db_key.data = kc_parent->kc_key.pxk_keyid;
+		db_key.size = PEFS_KEYID_SIZE;
+		error = db->get(db, &db_key, &db_data, 0);
+		if (error != 0) {
+			if (error == -1) {
+				pefs_warn("key chain database error: %s",
+				    strerror(errno));
+				error = PEFS_ERR_SYS;
+			}
+			if (TAILQ_FIRST(kch) != kc_parent)
+				error = 0;
+			break;
+		}
+		if (db_data.size != sizeof(struct pefs_xkeyenc)) {
+			pefs_warn("key chain database damaged");
+			error = PEFS_ERR_INVALID;
+			break;
+		}
+
+		kc = calloc(1, sizeof(struct pefs_keychain));
+		if (kc == NULL) {
+			pefs_warn("calloc: %s", strerror(errno));
+			error = PEFS_ERR_SYS;
+			break;
+		}
+
+		memcpy(&ke, db_data.data, sizeof(struct pefs_xkeyenc));
+		error = pefs_key_decrypt(&ke, &kc_parent->kc_key);
+		if (error)
+			break;
+		kc->kc_key = ke.a.ke_next;
+		kc_parent->kc_key.pxk_alg = le32toh(ke.a.ke_alg);
+		kc_parent->kc_key.pxk_keybits = le32toh(ke.a.ke_keybits);
+		if (pefs_alg_name(&kc_parent->kc_key) == NULL) {
+			pefs_warn("key chain database damaged");
+			error = PEFS_ERR_INVALID;
+			break;
+		}
+		kc->kc_key.pxk_index = -1;
+		kc->kc_key.pxk_alg = le32toh(kc->kc_key.pxk_alg);
+		kc->kc_key.pxk_keybits = le32toh(kc->kc_key.pxk_keybits);
+
+		if (kc->kc_key.pxk_alg == PEFS_ALG_INVALID ||
+		    pefs_alg_name(&kc->kc_key) == NULL) {
+			if (kc->kc_key.pxk_alg != PEFS_ALG_INVALID) {
+				error = PEFS_ERR_INVALID;
+				pefs_warn("key chain %016jx -> %016jx: "
+				    "invalid algorithm (decyption failed)",
+				    pefs_keyid_as_int(
+					kc_parent->kc_key.pxk_keyid),
+				    pefs_keyid_as_int(kc->kc_key.pxk_keyid));
+			}
+			bzero(&kc->kc_key, sizeof(struct pefs_xkey));
+			break;
+		}
+		TAILQ_INSERT_TAIL(kch, kc, kc_entry);
+		kc = NULL;
+	}
+
+	if (error != 0 && kc != NULL) {
+		bzero(&kc->kc_key, sizeof(struct pefs_xkey));
+		free(kc);
+	}
+	return (error);
+}
+
+int
+pefs_keychain_get(struct pefs_keychain_head *kch, const char *filesystem,
+    int flags, struct pefs_xkey *xk)
+{
+	struct pefs_keychain *kc;
+	DB *db;
+	int error;
+
+	assert(filesystem != NULL && kch != NULL && xk != NULL);
+
+	TAILQ_INIT(kch);
+
+	kc = calloc(1, sizeof(struct pefs_keychain));
+	if (kc == NULL) {
+		pefs_warn("calloc: %s", strerror(errno));
+		return (PEFS_ERR_SYS);
+	}
+	kc->kc_key = *xk;
+	TAILQ_INSERT_HEAD(kch, kc, kc_entry);
+
+	if (flags == 0)
+		return (0);
+
+	db = keychain_dbopen(filesystem, flags, O_RDONLY);
+	if (db == NULL) {
+		if (flags & PEFS_KEYCHAIN_IGNORE_MISSING)
+			return (0);
+		pefs_keychain_free(kch);
+		return (PEFS_ERR_NOENT);
+	}
+
+	error = pefs_keychain_get_db(db, kch);
+
+	db->close(db);
+
+	if (error != 0 && (flags & PEFS_KEYCHAIN_USE) != 0) {
+		pefs_keychain_free(kch);
+		pefs_warn("key chain not found: %016jx",
+		    pefs_keyid_as_int(xk->pxk_keyid));
+		return (PEFS_ERR_NOENT);
+	}
+
+	return (0);
+}
+
+int
+pefs_keychain_set(const char *filesystem, struct pefs_xkey *xk,
+    struct pefs_xkey *xknext)
+{
+	struct pefs_xkeyenc ke;
+	DBT db_key, db_data;
+	DB *db;
+	int error;
+
+	ke.a.ke_next = *xknext;
+	ke.a.ke_next.pxk_index = (uint32_t)random();
+	ke.a.ke_next.pxk_alg = htole32(ke.a.ke_next.pxk_alg);
+	ke.a.ke_next.pxk_keybits = htole32(ke.a.ke_next.pxk_keybits);
+	ke.a.ke_alg = htole32(xk->pxk_alg);
+	ke.a.ke_keybits = htole32(xk->pxk_keybits);
+	if (pefs_key_encrypt(&ke, xk) != 0)
+		return (PEFS_ERR_INVALID);
+
+	db = keychain_dbopen(filesystem, PEFS_KEYCHAIN_USE, O_RDWR | O_CREAT);
+	if (db == NULL)
+		return (PEFS_ERR_INVALID);
+
+	db_data.data = &ke;
+	db_data.size = sizeof(struct pefs_xkeyenc);
+	db_key.data = xk->pxk_keyid;
+	db_key.size = PEFS_KEYID_SIZE;
+	error = db->put(db, &db_key, &db_data, R_NOOVERWRITE);
+	bzero(&ke, sizeof(struct pefs_xkeyenc));
+	if (error != 0) {
+		if (error == -1) {
+			error = PEFS_ERR_SYS;
+			pefs_warn("key chain database error: %s",
+			    strerror(errno));
+		} else {
+			error = PEFS_ERR_EXIST;
+			pefs_warn("key chain already exists: %016jx",
+			    pefs_keyid_as_int(xk->pxk_keyid));
+		}
+	}
+	db->close(db);
+
+	return (error);
+}
+
+int
+pefs_keychain_del(const char *filesystem, int flags, struct pefs_xkey *xk)
+{
+	DBT db_key;
+	DB *db;
+	int error;
+
+	db = keychain_dbopen(filesystem, PEFS_KEYCHAIN_USE, O_RDWR | O_CREAT);
+	if (db == NULL)
+		return (-1);
+	db_key.data = xk->pxk_keyid;
+	db_key.size = PEFS_KEYID_SIZE;
+	error = db->del(db, &db_key, 0);
+	if (error != 0) {
+		if (error == -1) {
+			error = PEFS_ERR_SYS;
+			pefs_warn("key chain database error: %s",
+			    strerror(errno));
+		} else {
+			if ((flags & PEFS_KEYCHAIN_IGNORE_MISSING) == 0) {
+				error = PEFS_ERR_NOENT;
+				pefs_warn("cannot delete key chain %016jx",
+				    pefs_keyid_as_int(xk->pxk_keyid));
+			} else
+				error = 0;
+		}
+	}
+	db->close(db);
+
+	return (error);
+}
diff --git sbin/pefs/pefs_keychain.h sbin/pefs/pefs_keychain.h
new file mode 100644
index 0000000..67a7a48
--- /dev/null
+++ sbin/pefs/pefs_keychain.h
@@ -0,0 +1,48 @@
+/*-
+ * Copyright (c) 2009 Gleb Kurtsou <gleb@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#include <sys/queue.h>
+
+#define	PEFS_KEYCHAIN_USE		0x0001
+#define	PEFS_KEYCHAIN_IGNORE_MISSING	0x0002
+
+struct pefs_keychain
+{
+	TAILQ_ENTRY(pefs_keychain)	kc_entry;
+	struct pefs_xkey		kc_key;
+};
+
+TAILQ_HEAD(pefs_keychain_head, pefs_keychain);
+
+int	pefs_keychain_get(struct pefs_keychain_head *kch,
+	    const char *filesystem, int flags, struct pefs_xkey *xk);
+int	pefs_keychain_set(const char *filesystem, struct pefs_xkey *xk,
+	    struct pefs_xkey *xknext);
+int	pefs_keychain_del(const char *filesystem, int flags,
+		struct pefs_xkey *xk);
+void	pefs_keychain_free(struct pefs_keychain_head *kch);
diff --git sbin/pefs/pefs_subr.c sbin/pefs/pefs_subr.c
new file mode 100644
index 0000000..fd0ecb4
--- /dev/null
+++ sbin/pefs/pefs_subr.c
@@ -0,0 +1,113 @@
+/*-
+ * Copyright (c) 2009 Gleb Kurtsou <gleb@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/ioccom.h>
+#include <sys/module.h>
+#include <sys/mount.h>
+
+#include <assert.h>
+#include <ctype.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include <fs/pefs/pefs.h>
+
+#include "pefs_ctl.h"
+
+int
+pefs_getfsroot(const char *path, int flags, char *fsroot, size_t size)
+{
+	struct statfs fs;
+	const char *realfsroot;
+
+	if (statfs(path, &fs) == -1) {
+		pefs_warn("statfs failed: %s: %s", path, strerror(errno));
+		return (PEFS_ERR_SYS);
+	}
+
+	realfsroot = fs.f_mntonname;
+	if (strcmp(PEFS_FSTYPE, fs.f_fstypename) != 0) {
+		if ((flags & PEFS_FS_IGNORE_TYPE) != 0)
+			realfsroot = path;
+		else {
+			pefs_warn("invalid file system type: %s", path);
+			return (PEFS_ERR_INVALID);
+		}
+	}
+
+	if (fsroot != NULL)
+		strlcpy(fsroot, realfsroot, size);
+
+	return (0);
+}
+
+int
+pefs_readfiles(const char **files, size_t count, void *ctx,
+    int (*handler)(void *, uint8_t *, size_t, const char *))
+{
+	uint8_t buf[BUFSIZ + 1];
+	ssize_t done;
+	size_t i;
+	int error, fd;
+
+	for (i = 0; i < count; i++) {
+		if (strcmp(files[i], "-") == 0)
+			fd = STDIN_FILENO;
+		else {
+			fd = open(files[i], O_RDONLY);
+			if (fd == -1) {
+				pefs_warn("cannot open key file %s: %s",
+				    files[i], strerror(errno));
+				return (PEFS_ERR_IO);
+			}
+		}
+		while ((done = read(fd, buf, sizeof(buf) - 1)) > 0) {
+			buf[done] = '\0';
+			error = handler(ctx, buf, done, files[i]);
+			if (error != 0)
+				return (error);
+		}
+		bzero(buf, sizeof(buf));
+		if (done == -1) {
+			pefs_warn("cannot read key file %s: %s",
+			    files[i], strerror(errno));
+			return (PEFS_ERR_IO);
+		}
+		if (fd != STDIN_FILENO)
+			close(fd);
+	}
+	return (0);
+}
diff --git sys/crypto/hmac/hmac.c sys/crypto/hmac/hmac.c
new file mode 100644
index 0000000..8ac9c37
--- /dev/null
+++ sys/crypto/hmac/hmac.c
@@ -0,0 +1,179 @@
+/*-
+ * Copyright (c) 2005-2010 Pawel Jakub Dawidek <pjd@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#ifdef _KERNEL
+#include <sys/systm.h>
+#include <sys/malloc.h>
+#else
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#endif
+
+#include <opencrypto/cryptodev.h>
+
+#include <crypto/hmac/hmac.h>
+
+#ifndef _KERNEL
+#define	panic(...)	do {						\
+	fprintf(stderr, __VA_ARGS__);					\
+	abort();							\
+} while (0)
+#endif
+
+typedef void hmac_hash_init_t(union hmac_hash_ctx *ctx);
+typedef void hmac_hash_update_t(union hmac_hash_ctx *ctx, const uint8_t *,
+    size_t);
+typedef void hmac_hash_final_t(uint8_t *, union hmac_hash_ctx *ctx);
+
+struct hmac_hash {
+	u_int			block_len;
+	u_int			digest_len;
+	hmac_hash_init_t	*init;
+	hmac_hash_update_t	*update;
+	hmac_hash_final_t	*final;
+};
+
+static const struct hmac_hash hmac_hash_sha256 = {
+	.block_len =	SHA256_BLOCK_LENGTH,
+	.digest_len =	SHA256_DIGEST_LENGTH,
+	.init =		(hmac_hash_init_t *)&SHA256_Init,
+	.update =	(hmac_hash_update_t *)&SHA256_Update,
+	.final =	(hmac_hash_final_t *)&SHA256_Final,
+};
+
+static const struct hmac_hash hmac_hash_sha384 = {
+	.block_len =	SHA384_BLOCK_LENGTH,
+	.digest_len =	SHA384_DIGEST_LENGTH,
+	.init =		(hmac_hash_init_t *)&SHA384_Init,
+	.update =	(hmac_hash_update_t *)&SHA384_Update,
+	.final =	(hmac_hash_final_t *)&SHA384_Final,
+};
+
+static const struct hmac_hash hmac_hash_sha512 = {
+	.block_len =	SHA512_BLOCK_LENGTH,
+	.digest_len =	SHA512_DIGEST_LENGTH,
+	.init =		(hmac_hash_init_t *)&SHA512_Init,
+	.update =	(hmac_hash_update_t *)&SHA512_Update,
+	.final =	(hmac_hash_final_t *)&SHA512_Final,
+};
+
+void
+hmac_init(struct hmac_ctx *ctx, int algo, const uint8_t *hkey, size_t hkeylen)
+{
+	const struct hmac_hash *hash;
+	u_int i;
+
+	switch (algo) {
+	case CRYPTO_SHA2_256_HMAC:
+		hash = &hmac_hash_sha256;
+		break;
+	case CRYPTO_SHA2_384_HMAC:
+		hash = &hmac_hash_sha384;
+		break;
+	case CRYPTO_SHA2_512_HMAC:
+		hash = &hmac_hash_sha512;
+		break;
+	default:
+		panic("HMAC: invalid alorithm: %d.", algo);
+		return;
+	}
+
+	ctx->hash = hash;
+	bzero(ctx->k_opad, hash->block_len);
+	if (hkeylen == 0)
+		; /* do nothing */
+	else if (hkeylen <= hash->block_len)
+		bcopy(hkey, ctx->k_opad, hkeylen);
+	else {
+		/*
+		 * If key is longer than HMAC_BLOCK_LENGTH_MAX bytes
+		 * reset it to key = HASH(key).
+		 */
+		hash->init(&ctx->hash_ctx);
+		hash->update(&ctx->hash_ctx, hkey, hkeylen);
+		hash->final(ctx->k_opad, &ctx->hash_ctx);
+	}
+
+	/* Perform inner SHA512. */
+	hash->init(&ctx->hash_ctx);
+	/* XOR key ipad value. */
+	for (i = 0; i < hash->block_len; i++)
+		ctx->k_opad[i] ^= 0x36;
+	hash->update(&ctx->hash_ctx, ctx->k_opad, hash->block_len);
+	/* XOR key opad value. */
+	for (i = 0; i < hash->block_len; i++)
+		ctx->k_opad[i] ^= 0x36 ^ 0x5c;
+}
+
+void
+hmac_update(struct hmac_ctx *ctx, const uint8_t *data,
+    size_t datasize)
+{
+
+	ctx->hash->update(&ctx->hash_ctx, data, datasize);
+}
+
+void
+hmac_final(struct hmac_ctx *ctx, uint8_t *md, size_t mdsize)
+{
+	const struct hmac_hash *hash = ctx->hash;
+	u_char digest[HMAC_DIGEST_LENGTH_MAX];
+
+	if (mdsize == 0 || mdsize > hash->digest_len) {
+		panic("HMAC: invalid digest buffer size: %zu (digest length %u).",
+		    mdsize, hash->digest_len);
+		return;
+	}
+
+	hash->final(digest, &ctx->hash_ctx);
+	/* Perform outer SHA512. */
+	hash->init(&ctx->hash_ctx);
+	hash->update(&ctx->hash_ctx, ctx->k_opad, hash->block_len);
+	hash->update(&ctx->hash_ctx, digest, sizeof(digest));
+	hash->final(digest, &ctx->hash_ctx);
+	bzero(ctx, sizeof(*ctx));
+
+	bcopy(digest, md, mdsize);
+}
+
+void
+hmac(int algo, const uint8_t *hkey, size_t hkeysize, const uint8_t *data,
+    size_t datasize, uint8_t *md, size_t mdsize)
+{
+	struct hmac_ctx ctx;
+
+	hmac_init(&ctx, algo, hkey, hkeysize);
+	hmac_update(&ctx, data, datasize);
+	/* mdsize == 0 means "Give me the whole hash!" */
+	if (mdsize == 0)
+		mdsize = ctx.hash->digest_len;
+	hmac_final(&ctx, md, mdsize);
+}
diff --git sys/crypto/hmac/hmac.h sys/crypto/hmac/hmac.h
new file mode 100644
index 0000000..8e3d8a3
--- /dev/null
+++ sys/crypto/hmac/hmac.h
@@ -0,0 +1,55 @@
+/*-
+ * Copyright (c) 2005-2011 Pawel Jakub Dawidek <pjd@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _SYS_CRYPTO_HMAC_H
+#define _SYS_CRYPTO_HMAC_H
+
+#include <crypto/sha2/sha2.h>
+
+#define HMAC_BLOCK_LENGTH_MAX		SHA512_BLOCK_LENGTH
+#define HMAC_DIGEST_LENGTH_MAX		SHA512_DIGEST_LENGTH
+
+struct hmac_hash;
+
+struct hmac_ctx {
+	const struct hmac_hash	*hash;
+	union hmac_hash_ctx {
+		SHA256_CTX	sha256_ctx;
+		SHA384_CTX	sha384_ctx;
+		SHA512_CTX	sha512_ctx;
+	}		hash_ctx;
+	u_char		k_opad[HMAC_BLOCK_LENGTH_MAX];
+};
+
+void hmac_init(struct hmac_ctx *ctx, int algo, const uint8_t *hkey,
+    size_t hkeylen);
+void hmac_update(struct hmac_ctx *ctx, const uint8_t *data,
+    size_t datasize);
+void hmac_final(struct hmac_ctx *ctx, uint8_t *md, size_t mdsize);
+void hmac(int algo, const uint8_t *hkey, size_t hkeysize,
+    const uint8_t *data, size_t datasize, uint8_t *md, size_t mdsize);
+
+#endif /* _SYS_CRYPTO_HMAC_H */
diff --git sys/crypto/pkcs5v2/pkcs5v2.c sys/crypto/pkcs5v2/pkcs5v2.c
new file mode 100644
index 0000000..df95d17
--- /dev/null
+++ sys/crypto/pkcs5v2/pkcs5v2.c
@@ -0,0 +1,128 @@
+/*-
+ * Copyright (c) 2005 Pawel Jakub Dawidek <pjd@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#ifdef _KERNEL
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/malloc.h>
+#else
+#include <sys/resource.h>
+#include <stdint.h>
+#include <string.h>
+#endif
+
+#include <crypto/hmac/hmac.h>
+#include <opencrypto/cryptodev.h>
+
+#include <crypto/pkcs5v2/pkcs5v2.h>
+
+#define SHA512_MDLEN		SHA512_DIGEST_LENGTH
+
+static __inline void
+xor(uint8_t *dst, const uint8_t *src, size_t size)
+{
+
+	for (; size > 0; size--)
+		*dst++ ^= *src++;
+}
+
+void
+pkcs5v2_genkey(uint8_t *key, unsigned keylen, const uint8_t *salt,
+    size_t saltsize, const char *passphrase, u_int iterations)
+{
+	uint8_t md[SHA512_MDLEN], saltcount[saltsize + sizeof(uint32_t)];
+	uint8_t *counter, *keyp;
+	u_int i, bsize, passlen;
+	uint32_t count;
+
+	passlen = strlen(passphrase);
+	bzero(key, keylen);
+	bcopy(salt, saltcount, saltsize);
+	counter = saltcount + saltsize;
+
+	keyp = key;
+	for (count = 1; keylen > 0; count++, keylen -= bsize, keyp += bsize) {
+		bsize = MIN(keylen, sizeof(md));
+
+		counter[0] = (count >> 24) & 0xff;
+		counter[1] = (count >> 16) & 0xff;
+		counter[2] = (count >> 8) & 0xff;
+		counter[3] = count & 0xff;
+		hmac(CRYPTO_SHA2_512_HMAC, passphrase, passlen, saltcount,
+		    sizeof(saltcount), md, sizeof(md));
+		xor(keyp, md, bsize);
+
+		for(i = 1; i < iterations; i++) {
+			hmac(CRYPTO_SHA2_512_HMAC, passphrase, passlen, md,
+			    sizeof(md), md, sizeof(md));
+			xor(keyp, md, bsize);
+		}
+	}
+}
+
+#ifndef _KERNEL
+/*
+ * Return the number of microseconds needed for 'interations' iterations.
+ */
+static int
+pkcs5v2_probe(int iterations, size_t keylen, size_t saltlen)
+{
+	uint8_t	key[keylen], salt[saltlen];
+	uint8_t passphrase[] = "passphrase";
+	struct rusage start, end;
+	int usecs;
+
+	getrusage(RUSAGE_SELF, &start);
+	pkcs5v2_genkey(key, keylen, salt, saltlen, passphrase,
+	    iterations);
+	getrusage(RUSAGE_SELF, &end);
+
+	usecs = end.ru_utime.tv_sec - start.ru_utime.tv_sec;
+	usecs *= 1000000;
+	usecs += end.ru_utime.tv_usec - start.ru_utime.tv_usec;
+	return (usecs);
+}
+
+/*
+ * Return the number of iterations which takes 'usecs' microseconds.
+ */
+int
+pkcs5v2_calculate(int usecs, size_t keylen, size_t saltlen)
+{
+	int iterations, v;
+
+	for (iterations = 1; ; iterations <<= 1) {
+		v = pkcs5v2_probe(iterations, keylen, saltlen);
+		if (v > 2000000)
+			break;
+	}
+	return (((intmax_t)iterations * (intmax_t)usecs) / v);
+}
+#endif	/* !_KERNEL */
diff --git sys/crypto/pkcs5v2/pkcs5v2.h sys/crypto/pkcs5v2/pkcs5v2.h
new file mode 100644
index 0000000..b538265
--- /dev/null
+++ sys/crypto/pkcs5v2/pkcs5v2.h
@@ -0,0 +1,36 @@
+/*-
+ * Copyright (c) 2005 Pawel Jakub Dawidek <pjd@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#ifndef _PKCS5V2_H_
+#define	_PKCS5V2_H_
+void pkcs5v2_genkey(uint8_t *key, unsigned keylen, const uint8_t *salt,
+    size_t saltsize, const char *passphrase, u_int iterations);
+#ifndef _KERNEL
+int pkcs5v2_calculate(int usecs, size_t keylen, size_t saltlen);
+#endif
+#endif	/* !_PKCS5V2_H_ */
diff --git sys/crypto/sha2/sha2.c sys/crypto/sha2/sha2.c
index 3bbf3cc..ed33b66 100644
--- sys/crypto/sha2/sha2.c
+++ sys/crypto/sha2/sha2.c
@@ -206,9 +206,9 @@ typedef u_int64_t sha2_word64;	/* Exactly 8 bytes */
  * library -- they are intended for private internal visibility/use
  * only.
  */
-static void SHA512_Last(SHA512_CTX*);
-static void SHA256_Transform(SHA256_CTX*, const sha2_word32*);
-static void SHA512_Transform(SHA512_CTX*, const sha2_word64*);
+void SHA512_Last(SHA512_CTX*);
+void SHA256_Transform(SHA256_CTX*, const sha2_word32*);
+void SHA512_Transform(SHA512_CTX*, const sha2_word64*);
 
 
 /*** SHA-XYZ INITIAL HASH VALUES AND CONSTANTS ************************/
@@ -366,7 +366,7 @@ void SHA256_Init(SHA256_CTX* context) {
 	(h) = T1 + Sigma0_256(a) + Maj((a), (b), (c)); \
 	j++
 
-static void SHA256_Transform(SHA256_CTX* context, const sha2_word32* data) {
+void SHA256_Transform(SHA256_CTX* context, const sha2_word32* data) {
 	sha2_word32	a, b, c, d, e, f, g, h, s0, s1;
 	sha2_word32	T1, *W256;
 	int		j;
@@ -424,7 +424,7 @@ static void SHA256_Transform(SHA256_CTX* context, const sha2_word32* data) {
 
 #else /* SHA2_UNROLL_TRANSFORM */
 
-static void SHA256_Transform(SHA256_CTX* context, const sha2_word32* data) {
+void SHA256_Transform(SHA256_CTX* context, const sha2_word32* data) {
 	sha2_word32	a, b, c, d, e, f, g, h, s0, s1;
 	sha2_word32	T1, T2, *W256;
 	int		j;
@@ -693,7 +693,7 @@ void SHA512_Init(SHA512_CTX* context) {
 	(h) = T1 + Sigma0_512(a) + Maj((a), (b), (c)); \
 	j++
 
-static void SHA512_Transform(SHA512_CTX* context, const sha2_word64* data) {
+void SHA512_Transform(SHA512_CTX* context, const sha2_word64* data) {
 	sha2_word64	a, b, c, d, e, f, g, h, s0, s1;
 	sha2_word64	T1, *W512 = (sha2_word64*)context->buffer;
 	int		j;
@@ -748,7 +748,7 @@ static void SHA512_Transform(SHA512_CTX* context, const sha2_word64* data) {
 
 #else /* SHA2_UNROLL_TRANSFORM */
 
-static void SHA512_Transform(SHA512_CTX* context, const sha2_word64* data) {
+void SHA512_Transform(SHA512_CTX* context, const sha2_word64* data) {
 	sha2_word64	a, b, c, d, e, f, g, h, s0, s1;
 	sha2_word64	T1 = 0, T2 = 0, *W512 = (sha2_word64*)context->buffer;
 	int		j;
@@ -874,7 +874,7 @@ void SHA512_Update(SHA512_CTX* context, const sha2_byte *data, size_t len) {
 	usedspace = freespace = 0;
 }
 
-static void SHA512_Last(SHA512_CTX* context) {
+void SHA512_Last(SHA512_CTX* context) {
 	unsigned int	usedspace;
 
 	usedspace = (context->bitcount[0] >> 3) % SHA512_BLOCK_LENGTH;
diff --git sys/fs/pefs/pefs.h sys/fs/pefs/pefs.h
new file mode 100644
index 0000000..d08feeb
--- /dev/null
+++ sys/fs/pefs/pefs.h
@@ -0,0 +1,282 @@
+/*-
+ * Copyright (c) 2009 Gleb Kurtsou <gleb@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#define	PEFS_SECTOR_SIZE		4096
+#define	PEFS_SECTOR_MASK		(PEFS_SECTOR_SIZE - 1)
+
+#define	PEFS_ALG_INVALID		0
+#define	PEFS_ALG_AES_XTS		4
+#define	PEFS_ALG_CAMELLIA_XTS		5
+
+#define	PEFS_TWEAK_SIZE			8
+#define	PEFS_KEY_BITS			512
+#define	PEFS_KEY_SIZE			(PEFS_KEY_BITS / 8)
+#define	PEFS_KEYID_SIZE			8
+#define	PEFS_NAME_CSUM_SIZE		8
+#define	PEFS_NAME_BLOCK_SIZE		16
+
+struct pefs_xkey {
+	uint32_t		pxk_index;
+	uint32_t		pxk_alg;
+	uint32_t		pxk_keybits;
+	char			pxk_keyid[PEFS_KEYID_SIZE];
+	char			pxk_key[PEFS_KEY_SIZE];
+};
+
+#ifdef _IO
+#define	PEFS_GETKEY			_IOWR('p', 0, struct pefs_xkey)
+#define	PEFS_ADDKEY			_IOWR('p', 1, struct pefs_xkey)
+#define	PEFS_SETKEY			_IOWR('p', 2, struct pefs_xkey)
+#define	PEFS_DELKEY			_IOWR('p', 3, struct pefs_xkey)
+#define	PEFS_FLUSHKEYS			_IO('p', 4)
+#define	PEFS_GETNODEKEY			_IOWR('p', 5, struct pefs_xkey)
+#endif
+
+#ifdef _KERNEL
+
+#define	PEFS_NAME_NTOP_SIZE(a)		(((a) * 4 + 2)/3)
+#define	PEFS_NAME_PTON_SIZE(a)		(((a) * 3)/4)
+
+#ifdef PEFS_DEBUG
+#define	PEFSDEBUG(format, args...)	printf(format ,## args)
+#else
+#define	PEFSDEBUG(format, args...)	do { } while (0)
+#endif /* PEFS_DEBUG */
+
+struct pefs_alg;
+struct pefs_ctx;
+struct pefs_dircache;
+struct vfsconf;
+
+TAILQ_HEAD(pefs_key_head, pefs_key);
+
+struct pefs_key {
+	TAILQ_ENTRY(pefs_key)	pk_entry;
+	volatile u_int		pk_refcnt;
+	const struct		pefs_alg *pk_alg;
+	struct pefs_ctx		*pk_name_csum_ctx;
+	struct pefs_ctx		*pk_name_ctx;
+	struct pefs_ctx		*pk_tweak_ctx;
+	struct pefs_ctx		*pk_data_ctx;
+	struct mtx		*pk_entry_lock;
+	int			pk_algid;
+	int			pk_keybits;
+	char			pk_keyid[PEFS_KEYID_SIZE];
+};
+
+struct pefs_tkey {
+	struct pefs_key		*ptk_key;
+	char			ptk_tweak[PEFS_TWEAK_SIZE];
+};
+
+#define	PN_HASKEY			0x000001
+#define	PN_WANTRECYCLE			0x000100
+#define	PN_LOCKBUF_SMALL		0x001000
+#define	PN_LOCKBUF_LARGE		0x002000
+
+struct pefs_node {
+	LIST_ENTRY(pefs_node)	pn_listentry;
+	struct vnode		*pn_lowervp;
+	struct vnode		*pn_lowervp_dead;
+	struct vnode		*pn_vnode;
+	struct pefs_dircache	*pn_dircache;
+	void			*pn_buf_small;
+	void			*pn_buf_large;
+	int			pn_flags;
+	struct pefs_tkey	pn_tkey;
+};
+
+#define	PM_ROOT_CANRECURSE		0x01
+#define	PM_DIRCACHE			0x02
+#define	PM_ASYNCRECLAIM			0x04
+
+struct pefs_mount {
+	struct mount		*pm_lowervfs;
+	struct vnode		*pm_rootvp;
+	struct mtx		pm_keys_lock;
+	struct pefs_key_head	pm_keys;
+	int			pm_flags;
+};
+
+struct pefs_chunk {
+	size_t			pc_size;
+	size_t			pc_capacity;
+	void			*pc_base;
+	int			pc_nodebuf;
+	struct iovec		pc_iov;
+	struct uio		pc_uio;
+};
+
+int	pefs_init(struct vfsconf *vfsp);
+int	pefs_uninit(struct vfsconf *vfsp);
+void	pefs_crypto_init(void);
+void	pefs_crypto_uninit(void);
+
+int	pefs_node_get_nokey(struct mount *mp, struct vnode *lvp,
+	    struct vnode **vpp);
+int	pefs_node_get_haskey(struct mount *mp, struct vnode *lvp,
+	    struct vnode **vpp, struct pefs_tkey *ptk);
+int	pefs_node_get_lookupkey(struct mount *mp, struct vnode *lvp,
+	    struct vnode **vpp, struct ucred *cred);
+void	pefs_node_asyncfree(struct pefs_node *xp);
+struct pefs_key	*pefs_node_key(struct pefs_node *pn);
+void	pefs_node_buf_free(struct pefs_node *pn);
+
+struct pefs_ctx	*pefs_ctx_get(void);
+void	pefs_ctx_free(struct pefs_ctx *ctx);
+
+struct pefs_key	*pefs_key_get(int alg, int keybits, const char *key,
+		    const char *keyid);
+struct pefs_key	*pefs_key_ref(struct pefs_key *pk);
+void	pefs_key_release(struct pefs_key *pk);
+
+struct pefs_key	*pefs_key_lookup(struct pefs_mount *pm, char *keyid);
+int	pefs_key_add(struct pefs_mount *pm, int index, struct pefs_key *pk);
+void	pefs_key_remove(struct pefs_mount *pm, struct pefs_key *pk);
+int	pefs_key_remove_all(struct pefs_mount *pm);
+
+void	pefs_data_encrypt(struct pefs_tkey *ptk, off_t offset,
+	    struct pefs_chunk *pc);
+void	pefs_data_decrypt(struct pefs_tkey *ptk, off_t offset,
+	    struct pefs_chunk *pc);
+
+int	pefs_name_encrypt(struct pefs_ctx *ctx, struct pefs_tkey *ptk,
+	    const char *plain, size_t plain_len, char *enc, size_t enc_size);
+int	pefs_name_decrypt(struct pefs_ctx *ctx, struct pefs_key *pk,
+	    struct pefs_tkey *ptk, const char *enc, size_t enc_len, char *plain,
+	    size_t plain_size);
+
+int	pefs_name_ntop(u_char const *src, size_t srclength, char *target,
+	    size_t targsize);
+int	pefs_name_pton(char const *src, size_t srclen, u_char *target,
+	    size_t targsize);
+
+void	pefs_chunk_create(struct pefs_chunk *pc, struct pefs_node *pn,
+	    size_t size);
+void	pefs_chunk_restore(struct pefs_chunk* pc);
+void	pefs_chunk_free(struct pefs_chunk* pc, struct pefs_node *pn);
+void	pefs_chunk_zero(struct pefs_chunk *pc);
+int	pefs_chunk_copy(struct pefs_chunk *pc, size_t skip, struct uio *uio);
+void	pefs_chunk_setsize(struct pefs_chunk *pc, size_t size);
+struct uio	*pefs_chunk_uio(struct pefs_chunk *pc, off_t uio_offset,
+	    enum uio_rw uio_rw);
+
+#ifdef DIAGNOSTIC
+struct vnode	*pefs_checkvp(struct vnode *vp, char *fil, int lno);
+#endif
+
+#ifdef SYSCTL_DECL
+SYSCTL_DECL(_vfs_pefs);
+#endif
+
+#ifdef MALLOC_DECLARE
+MALLOC_DECLARE(M_PEFSBUF);
+MALLOC_DECLARE(M_PEFSHASH);
+#endif
+
+extern struct vop_vector	pefs_vnodeops;
+
+static __inline struct pefs_mount *
+VFS_TO_PEFS(struct mount *mp)
+{
+	MPASS(mp != NULL && mp->mnt_data != NULL);
+	return ((struct pefs_mount *)(mp->mnt_data));
+}
+
+static __inline struct pefs_node *
+VP_TO_PN(struct vnode *vp)
+{
+	MPASS(vp != NULL && vp->v_data != NULL);
+	return ((struct pefs_node *)vp->v_data);
+}
+
+static __inline struct vnode *
+PN_TO_VP(struct pefs_node *pn)
+{
+	MPASS(pn != NULL && pn->pn_vnode != NULL);
+	return (pn->pn_vnode);
+}
+
+static __inline struct vnode *
+PEFS_LOWERVP(struct vnode *vp)
+{
+	struct vnode *lvp;
+
+	MPASS(vp != NULL);
+#ifdef DIAGNOSTIC
+	pefs_checkvp((vp), __FILE__, __LINE__);
+#endif
+	lvp = VP_TO_PN(vp)->pn_lowervp;
+	MPASS(lvp != NULL);
+	return (lvp);
+}
+
+static __inline void **
+pefs_node_buf(struct pefs_node *pn, int flag)
+{
+	MPASS(flag == PN_LOCKBUF_SMALL || flag == PN_LOCKBUF_LARGE);
+	if (flag == PN_LOCKBUF_SMALL)
+		return (&pn->pn_buf_small);
+	else
+		return (&pn->pn_buf_large);
+}
+
+static __inline struct pefs_key *
+pefs_rootkey(struct pefs_mount *pm)
+{
+	struct pefs_key *pk;
+
+	mtx_lock(&pm->pm_keys_lock);
+	pk = TAILQ_FIRST(&pm->pm_keys);
+	mtx_unlock(&pm->pm_keys_lock);
+
+	return (pk);
+}
+
+static __inline int
+pefs_no_keys(struct vnode *vp)
+{
+	return (!(VP_TO_PN(vp)->pn_flags & PN_HASKEY) &&
+	    pefs_rootkey(VFS_TO_PEFS(vp->v_mount)) == NULL);
+}
+
+static __inline uint32_t
+pefs_hash_mixptr(void *ptr)
+{
+	uintptr_t h = (uintptr_t)ptr;
+
+	h = (~h) + (h << 18);
+	h = h ^ (h >> 31);
+	h = h * 21;
+	h = h ^ (h >> 11);
+	h = h + (h << 6);
+	h = h ^ (h >> 22);
+	return (h);
+}
+
+#endif /* _KERNEL */
diff --git sys/fs/pefs/pefs_aesni.c sys/fs/pefs/pefs_aesni.c
new file mode 100644
index 0000000..8d8658e
--- /dev/null
+++ sys/fs/pefs/pefs_aesni.c
@@ -0,0 +1,220 @@
+/*-
+ * Copyright (c) 2010 Konstantin Belousov <kib@FreeBSD.org>
+ * Copyright (c) 2010 Pawel Jakub Dawidek <pjd@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/kernel.h>
+#include <sys/libkern.h>
+#include <sys/lock.h>
+#include <sys/malloc.h>
+#include <sys/pcpu.h>
+#include <sys/proc.h>
+#include <sys/sched.h>
+#include <sys/smp.h>
+#include <sys/systm.h>
+
+#include <fs/pefs/pefs_crypto.h>
+
+#define	AESNI_ENABLE_ENV	"vfs.pefs.aesni_enable"
+
+DPCPU_DEFINE(struct fpu_kern_ctx *, pefs_aesni_fpu);
+
+#if __FreeBSD_version < 900503
+static struct fpu_kern_ctx *
+fpu_kern_alloc_ctx(int flags __unused)
+{
+	struct fpu_kern_ctx *ctx;
+
+	ctx = malloc(sizeof(*ctx), M_TEMP, M_WAITOK | M_ZERO);
+	return (ctx);
+}
+
+static void
+fpu_kern_free_ctx(struct fpu_kern_ctx *ctx)
+{
+	free(ctx, M_TEMP);
+}
+#endif
+
+static int
+pefs_aesni_keysetup(const struct pefs_session *xses,
+    struct pefs_ctx *xctx, const uint8_t *key, uint32_t keybits)
+{
+	const struct pefs_aesni_ses *ses = &xses->o.ps_aesni;
+	struct pefs_aesni_ctx *ctx = &xctx->o.pctx_aesni;
+	struct fpu_kern_ctx *tmpctx = NULL;
+	int error;
+
+	switch (keybits) {
+	case 128:
+		ctx->rounds = AES128_ROUNDS;
+		break;
+	case 192:
+		ctx->rounds = AES192_ROUNDS;
+		break;
+	case 256:
+		ctx->rounds = AES256_ROUNDS;
+		break;
+	default:
+		printf("pefs: AESNI: invalid key length: %d", keybits);
+		return (EINVAL);
+	}
+
+	if (ses->fpu_saved < 0) {
+		tmpctx = fpu_kern_alloc_ctx(FPU_KERN_NORMAL);
+		if (tmpctx == NULL)
+			return (ENOMEM);
+		error = fpu_kern_enter(curthread, tmpctx, FPU_KERN_NORMAL);
+		if (error != 0) {
+			fpu_kern_free_ctx(tmpctx);
+			return (error);
+		}
+	}
+
+	aesni_set_enckey(key, ctx->enc_schedule, ctx->rounds);
+	aesni_set_deckey(ctx->enc_schedule, ctx->dec_schedule, ctx->rounds);
+	rijndael_set_key(&ctx->sw, key, keybits);
+
+	if (tmpctx != NULL) {
+		fpu_kern_leave(curthread, tmpctx);
+		fpu_kern_free_ctx(tmpctx);
+	}
+
+	return (0);
+}
+
+static void
+pefs_aesni_encrypt(const struct pefs_session *xses,
+    const struct pefs_ctx *xctx, const uint8_t *in, uint8_t *out)
+{
+	const struct pefs_aesni_ses *ses = &xses->o.ps_aesni;
+	const struct pefs_aesni_ctx *ctx = &xctx->o.pctx_aesni;
+
+	if (ses->fpu_saved >= 0)
+		aesni_enc(ctx->rounds - 1, ctx->enc_schedule, in, out, NULL);
+	else
+		rijndael_encrypt(&ctx->sw, in, out);
+}
+
+static void
+pefs_aesni_decrypt(const struct pefs_session *xses,
+    const struct pefs_ctx *xctx, const uint8_t *in, uint8_t *out)
+{
+	const struct pefs_aesni_ses *ses = &xses->o.ps_aesni;
+	const struct pefs_aesni_ctx *ctx = &xctx->o.pctx_aesni;
+
+	if (ses->fpu_saved >= 0)
+		aesni_dec(ctx->rounds - 1, ctx->dec_schedule, in, out, NULL);
+	else
+		rijndael_decrypt(&ctx->sw, in, out);
+}
+
+static void
+pefs_aesni_enter(struct pefs_session *xses)
+{
+	struct pefs_aesni_ses *ses = &xses->o.ps_aesni;
+	int error;
+
+	if (is_fpu_kern_thread(0)) {
+		ses->fpu_saved = 0;
+		return;
+	}
+
+	sched_pin();
+	ses->fpu_ctx = DPCPU_GET(pefs_aesni_fpu);
+	if (ses->fpu_ctx != NULL) {
+		ses->td = curthread;
+		ses->fpu_cpuid = curcpu;
+		DPCPU_ID_SET(ses->fpu_cpuid, pefs_aesni_fpu, NULL);
+		sched_unpin();
+		error = fpu_kern_enter(ses->td, ses->fpu_ctx, FPU_KERN_NORMAL);
+		if (error == 0) {
+			ses->fpu_saved = 1;
+			return;
+		}
+		DPCPU_ID_SET(ses->fpu_cpuid, pefs_aesni_fpu, ses->fpu_ctx);
+	} else
+		sched_unpin();
+	ses->fpu_saved = -1;
+}
+
+static void
+pefs_aesni_leave(struct pefs_session *xses)
+{
+	struct pefs_aesni_ses *ses = &xses->o.ps_aesni;
+
+	if (ses->fpu_saved <= 0)
+		return;
+
+	fpu_kern_leave(ses->td, ses->fpu_ctx);
+	DPCPU_ID_SET(ses->fpu_cpuid, pefs_aesni_fpu, ses->fpu_ctx);
+}
+
+static void
+pefs_aesni_uninit(struct pefs_alg *pa)
+{
+	struct fpu_kern_ctx *fpu_ctx;
+	u_int cpuid;
+
+	CPU_FOREACH(cpuid) {
+		fpu_ctx = DPCPU_ID_GET(cpuid, pefs_aesni_fpu);
+		if (fpu_ctx != NULL) {
+			fpu_kern_free_ctx(fpu_ctx);
+			DPCPU_ID_SET(cpuid, pefs_aesni_fpu, NULL);
+		}
+	}
+}
+
+void
+pefs_aesni_init(struct pefs_alg *pa)
+{
+	struct fpu_kern_ctx *fpu_ctx;
+	u_long enable = 1;
+	u_int cpuid;
+
+	TUNABLE_ULONG_FETCH(AESNI_ENABLE_ENV, &enable);
+
+	if (enable != 0 && (cpu_feature2 & CPUID2_AESNI) != 0) {
+		printf("pefs: AESNI hardware acceleration enabled\n");
+		pa->pa_uninit = pefs_aesni_uninit;
+		pa->pa_enter = pefs_aesni_enter;
+		pa->pa_leave = pefs_aesni_leave;
+		pa->pa_keysetup = pefs_aesni_keysetup;
+		pa->pa_encrypt = pefs_aesni_encrypt;
+		pa->pa_decrypt = pefs_aesni_decrypt;
+		CPU_FOREACH(cpuid) {
+			fpu_ctx = fpu_kern_alloc_ctx(FPU_KERN_NORMAL);
+			DPCPU_ID_SET(cpuid, pefs_aesni_fpu, fpu_ctx);
+		}
+	} else
+#ifndef PEFS_DEBUG
+	if (bootverbose)
+#endif
+		printf("pefs: AESNI hardware acceleration disabled\n");
+}
diff --git sys/fs/pefs/pefs_aesni.h sys/fs/pefs/pefs_aesni.h
new file mode 100644
index 0000000..2e92bff
--- /dev/null
+++ sys/fs/pefs/pefs_aesni.h
@@ -0,0 +1,43 @@
+/*-
+ * Copyright (c) 2010 Konstantin Belousov <kib@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#include <crypto/aesni/aesni.h>
+
+struct pefs_aesni_ctx {
+	uint8_t enc_schedule[AES_SCHED_LEN] __aligned(16);
+	uint8_t dec_schedule[AES_SCHED_LEN] __aligned(16);
+	int			rounds;
+	rijndael_ctx		sw;
+};
+
+struct pefs_aesni_ses {
+	struct fpu_kern_ctx	*fpu_ctx;
+	struct thread		*td;
+	u_int			fpu_cpuid;
+	int			fpu_saved;
+};
diff --git sys/fs/pefs/pefs_crypto.c sys/fs/pefs/pefs_crypto.c
new file mode 100644
index 0000000..a722e06
--- /dev/null
+++ sys/fs/pefs/pefs_crypto.c
@@ -0,0 +1,754 @@
+/*-
+ * Copyright (c) 2009 Gleb Kurtsou <gleb@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/dirent.h>
+#include <sys/endian.h>
+#include <sys/lock.h>
+#include <sys/libkern.h>
+#include <sys/limits.h>
+#include <sys/malloc.h>
+#include <sys/mount.h>
+#include <sys/refcount.h>
+#include <sys/queue.h>
+#include <sys/vnode.h>
+#include <vm/uma.h>
+
+#include <opencrypto/cryptodev.h>
+
+#include <fs/pefs/pefs.h>
+#include <fs/pefs/pefs_crypto.h>
+
+#define	PEFS_NAME_KEY_BITS	128
+
+CTASSERT(PEFS_KEY_SIZE <= HMAC_DIGEST_LENGTH_MAX);
+CTASSERT(PEFS_TWEAK_SIZE == 64/8);
+CTASSERT(PEFS_NAME_CSUM_SIZE <= sizeof(uint64_t));
+CTASSERT(MAXNAMLEN >= PEFS_NAME_PTON_SIZE(MAXNAMLEN) + PEFS_NAME_BLOCK_SIZE);
+
+static algop_keysetup_t pefs_aes_keysetup;
+static algop_crypt_t pefs_aes_encrypt;
+static algop_crypt_t pefs_aes_decrypt;
+
+static algop_keysetup_t pefs_camellia_keysetup;
+static algop_crypt_t pefs_camellia_encrypt;
+static algop_crypt_t pefs_camellia_decrypt;
+
+static uma_zone_t		pefs_ctx_zone;
+static uma_zone_t		pefs_key_zone;
+
+static const char		magic_keyinfo_v1[] = "PEFSKEY-V1";
+
+static struct pefs_alg pefs_alg_aes = {
+	.pa_id =		PEFS_ALG_AES_XTS,
+#ifdef PEFS_AESNI
+	.pa_init =		pefs_aesni_init,
+#endif
+	.pa_keysetup =		pefs_aes_keysetup,
+	.pa_encrypt =		pefs_aes_encrypt,
+	.pa_decrypt =		pefs_aes_decrypt,
+};
+
+static struct pefs_alg pefs_alg_camellia = {
+	.pa_id =		PEFS_ALG_CAMELLIA_XTS,
+	.pa_keysetup =		pefs_camellia_keysetup,
+	.pa_encrypt =		pefs_camellia_encrypt,
+	.pa_decrypt =		pefs_camellia_decrypt,
+};
+
+static __inline void
+pefs_alg_init(struct pefs_alg *pa)
+{
+	if (pa->pa_init != NULL)
+		pa->pa_init(pa);
+}
+
+static __inline void
+pefs_alg_uninit(struct pefs_alg *pa)
+{
+	if (pa->pa_uninit != NULL)
+		pa->pa_uninit(pa);
+}
+
+void
+pefs_crypto_init(void)
+{
+	pefs_ctx_zone = uma_zcreate("pefs_ctx", sizeof(struct pefs_ctx),
+	    NULL, NULL, NULL, (uma_fini)bzero, UMA_ALIGN_CACHE, 0);
+	pefs_key_zone = uma_zcreate("pefs_key", sizeof(struct pefs_key),
+	    NULL, NULL, NULL, (uma_fini)bzero, UMA_ALIGN_PTR, 0);
+	pefs_alg_init(&pefs_alg_aes);
+	pefs_alg_init(&pefs_alg_camellia);
+}
+
+void
+pefs_crypto_uninit(void)
+{
+	pefs_alg_uninit(&pefs_alg_aes);
+	pefs_alg_uninit(&pefs_alg_camellia);
+	uma_zdestroy(pefs_ctx_zone);
+	uma_zdestroy(pefs_key_zone);
+}
+
+struct pefs_ctx *
+pefs_ctx_get(void)
+{
+	struct pefs_ctx *ctx;
+
+	ctx = uma_zalloc(pefs_ctx_zone, M_WAITOK);
+	return (ctx);
+}
+
+void
+pefs_ctx_free(struct pefs_ctx *ctx)
+{
+	uma_zfree(pefs_ctx_zone, ctx);
+}
+
+static __inline void
+pefs_ctx_cpy(struct pefs_ctx *dst, struct pefs_ctx *src)
+{
+	*dst = *src;
+}
+
+static __inline void
+pefs_session_enter(const struct pefs_alg *alg, struct pefs_session *ses)
+{
+	if (alg->pa_enter != NULL)
+		alg->pa_enter(ses);
+}
+
+static __inline void
+pefs_session_leave(const struct pefs_alg *alg, struct pefs_session *ses)
+{
+	if (alg->pa_leave != NULL)
+		alg->pa_leave(ses);
+}
+
+/*
+ * Use HKDF-Expand() defined in RFC5869 to derive keys,
+ * masterkey parameter should be cryptographically strong.
+ */
+static void
+pefs_hkdf_expand(struct pefs_ctx *ctx, const uint8_t *masterkey, uint8_t *key,
+    int idx, const uint8_t *magic, size_t magicsize)
+{
+	uint8_t byte_idx = idx;
+
+	hmac_init(&ctx->o.pctx_hmac, CRYPTO_SHA2_512_HMAC,
+	    masterkey, PEFS_KEY_SIZE);
+	hmac_update(&ctx->o.pctx_hmac, key, PEFS_KEY_SIZE);
+	hmac_update(&ctx->o.pctx_hmac, magic, magicsize);
+	hmac_update(&ctx->o.pctx_hmac, &byte_idx, sizeof(byte_idx));
+	hmac_final(&ctx->o.pctx_hmac, key, PEFS_KEY_SIZE);
+}
+
+static void
+pefs_key_wipe(struct pefs_key *pk)
+{
+	bzero(pk->pk_name_ctx, sizeof(struct pefs_ctx));
+	bzero(pk->pk_name_csum_ctx, sizeof(struct pefs_ctx));
+	bzero(pk->pk_data_ctx, sizeof(struct pefs_ctx));
+	bzero(pk->pk_tweak_ctx, sizeof(struct pefs_ctx));
+}
+
+static int
+pefs_key_generate(struct pefs_key *pk, const uint8_t *masterkey,
+    const uint8_t *magic, size_t magicsize)
+{
+	struct pefs_session ses;
+	struct pefs_ctx *ctx;
+	uint8_t key[PEFS_KEY_SIZE];
+	int error;
+
+	/* Properly initialize contexts as they are used to compare keys. */
+	pefs_key_wipe(pk);
+
+	ctx = pefs_ctx_get();
+	pefs_session_enter(pk->pk_alg, &ses);
+
+	bzero(key, PEFS_KEY_SIZE);
+	pefs_hkdf_expand(ctx, masterkey, key, 1, magic, magicsize);
+	error = pk->pk_alg->pa_keysetup(&ses, pk->pk_data_ctx, key,
+	    pk->pk_keybits);
+	if (error != 0) {
+		pefs_session_leave(pk->pk_alg, &ses);
+		goto out;
+	}
+
+	pefs_hkdf_expand(ctx, masterkey, key, 2, magic, magicsize);
+	error = pk->pk_alg->pa_keysetup(&ses, pk->pk_tweak_ctx, key,
+	    pk->pk_keybits);
+	if (error != 0) {
+		pefs_session_leave(pk->pk_alg, &ses);
+		goto out;
+	}
+
+	if (pk->pk_alg != &pefs_alg_aes) {
+		pefs_session_leave(pk->pk_alg, &ses);
+		pefs_session_enter(&pefs_alg_aes, &ses);
+	}
+
+	pefs_hkdf_expand(ctx, masterkey, key, 3, magic, magicsize);
+	error = pefs_alg_aes.pa_keysetup(&ses, pk->pk_name_ctx, key,
+	    PEFS_NAME_KEY_BITS);
+
+	pefs_session_leave(&pefs_alg_aes, &ses);
+
+	if (error != 0)
+		goto out;
+
+	pefs_hkdf_expand(ctx, masterkey, key, 4, magic, magicsize);
+	vmac_set_key(key, &pk->pk_name_csum_ctx->o.pctx_vmac);
+
+out:
+	if (error != 0)
+		pefs_key_wipe(pk);
+	bzero(key, PEFS_KEY_SIZE);
+	pefs_ctx_free(ctx);
+
+	return (error);
+}
+
+struct pefs_key *
+pefs_key_get(int alg, int keybits, const char *key, const char *keyid)
+{
+	struct pefs_key *pk;
+
+	pk = uma_zalloc(pefs_key_zone, M_WAITOK | M_ZERO);
+
+	switch (alg) {
+	case PEFS_ALG_AES_XTS:
+		pk->pk_alg = &pefs_alg_aes;
+		if (keybits == 128 || keybits == 192 || keybits == 256)
+			pk->pk_keybits = keybits;
+		break;
+	case PEFS_ALG_CAMELLIA_XTS:
+		pk->pk_alg = &pefs_alg_camellia;
+		if (keybits == 128 || keybits == 192 || keybits == 256)
+			pk->pk_keybits = keybits;
+		break;
+	default:
+		uma_zfree(pefs_key_zone, pk);
+		printf("pefs: unknown algorithm %d\n", alg);
+		return (NULL);
+	}
+	if (pk->pk_keybits == 0) {
+		uma_zfree(pefs_key_zone, pk);
+		printf("pefs: invalid key size %d for algorithm %d\n",
+		    keybits, alg);
+		return (NULL);
+	}
+	pk->pk_algid = alg;
+
+	refcount_init(&pk->pk_refcnt, 1);
+	memcpy(pk->pk_keyid, keyid, PEFS_KEYID_SIZE);
+
+	pk->pk_name_ctx = pefs_ctx_get();
+	pk->pk_name_csum_ctx = pefs_ctx_get();
+	pk->pk_data_ctx = pefs_ctx_get();
+	pk->pk_tweak_ctx = pefs_ctx_get();
+
+	pefs_key_generate(pk, key, magic_keyinfo_v1, sizeof(magic_keyinfo_v1));
+
+	return (pk);
+}
+
+struct pefs_key *
+pefs_key_ref(struct pefs_key *pk)
+{
+	refcount_acquire(&pk->pk_refcnt);
+	return (pk);
+}
+
+void
+pefs_key_release(struct pefs_key *pk)
+{
+	if (pk == NULL)
+		return;
+	if (refcount_release(&pk->pk_refcnt)) {
+		PEFSDEBUG("pefs_key_release: free pk=%p\n", pk);
+		pefs_ctx_free(pk->pk_name_ctx);
+		pefs_ctx_free(pk->pk_name_csum_ctx);
+		pefs_ctx_free(pk->pk_data_ctx);
+		pefs_ctx_free(pk->pk_tweak_ctx);
+		uma_zfree(pefs_key_zone, pk);
+	}
+}
+
+struct pefs_key *
+pefs_key_lookup(struct pefs_mount *pm, char *keyid)
+{
+	struct pefs_key *pk;
+
+	mtx_assert(&pm->pm_keys_lock, MA_OWNED);
+	TAILQ_FOREACH(pk, &pm->pm_keys, pk_entry) {
+		if (memcmp(pk->pk_keyid, keyid, PEFS_KEYID_SIZE) == 0)
+			return (pk);
+	}
+
+	return (NULL);
+}
+
+int
+pefs_key_add(struct pefs_mount *pm, int index, struct pefs_key *pk)
+{
+	struct pefs_key *i, *pk_pos;
+	int pos;
+
+	mtx_lock(&pm->pm_keys_lock);
+	if (index == 0 && !TAILQ_EMPTY(&pm->pm_keys)) {
+		mtx_unlock(&pm->pm_keys_lock);
+		return (EEXIST);
+	}
+	pk_pos = NULL;
+	pos = 0;
+	TAILQ_FOREACH(i, &pm->pm_keys, pk_entry) {
+		if (memcmp(pk->pk_keyid, i->pk_keyid, PEFS_KEYID_SIZE) == 0 ||
+		    memcmp(pk->pk_data_ctx, i->pk_data_ctx,
+		    sizeof(struct pefs_ctx)) == 0) {
+			mtx_unlock(&pm->pm_keys_lock);
+			return (EEXIST);
+		}
+		if (index == pos + 1)
+			pk_pos = i;
+	}
+	pk->pk_entry_lock = &pm->pm_keys_lock;
+	if (TAILQ_EMPTY(&pm->pm_keys)) {
+		TAILQ_INSERT_HEAD(&pm->pm_keys, pk, pk_entry);
+		PEFSDEBUG("pefs_key_add: root key added: %p\n", pk);
+	} else if (pk_pos == NULL) {
+		TAILQ_INSERT_TAIL(&pm->pm_keys, pk, pk_entry);
+		PEFSDEBUG("pefs_key_add: tail key added: %p\n", pk);
+	} else {
+		TAILQ_INSERT_AFTER(&pm->pm_keys, pk_pos, pk, pk_entry);
+		PEFSDEBUG("pefs_key_add: key added at pos=%d: %p\n", pos, pk);
+	}
+	mtx_unlock(&pm->pm_keys_lock);
+
+	return (0);
+}
+
+void
+pefs_key_remove(struct pefs_mount *pm, struct pefs_key *pk)
+{
+	mtx_assert(&pm->pm_keys_lock, MA_OWNED);
+	MPASS(pk->pk_entry_lock != NULL);
+	TAILQ_REMOVE(&pm->pm_keys, pk, pk_entry);
+	pk->pk_entry_lock = NULL;
+	PEFSDEBUG("pefs_key_remove: pk=%p\n", pk);
+	pefs_key_release(pk);
+}
+
+int
+pefs_key_remove_all(struct pefs_mount *pm)
+{
+	int n = 0;
+
+	mtx_lock(&pm->pm_keys_lock);
+	while (!TAILQ_EMPTY(&pm->pm_keys)) {
+		pefs_key_remove(pm, TAILQ_FIRST(&pm->pm_keys));
+		n++;
+	}
+	mtx_unlock(&pm->pm_keys_lock);
+
+	return (n);
+}
+
+void
+pefs_data_encrypt(struct pefs_tkey *ptk, off_t offset, struct pefs_chunk *pc)
+{
+	struct pefs_session ses;
+	char *buf;
+	ssize_t resid, block;
+
+	MPASS(ptk->ptk_key != NULL);
+	MPASS((offset & PEFS_SECTOR_MASK) == 0);
+
+	pefs_session_enter(ptk->ptk_key->pk_alg, &ses);
+	buf = pc->pc_base;
+	resid = pc->pc_size;
+	while (resid > 0) {
+		block = qmin(resid, PEFS_SECTOR_SIZE);
+		pefs_xts_block_encrypt(ptk->ptk_key->pk_alg, &ses,
+		    ptk->ptk_key->pk_tweak_ctx, ptk->ptk_key->pk_data_ctx,
+		    offset, ptk->ptk_tweak, block,
+		    buf, buf);
+		offset += block;
+		buf += block;
+		resid -= block;
+	}
+	pefs_session_leave(ptk->ptk_key->pk_alg, &ses);
+}
+
+void
+pefs_data_decrypt(struct pefs_tkey *ptk, off_t offset, struct pefs_chunk *pc)
+{
+	struct pefs_session ses;
+	ssize_t resid;
+	long *p;
+	char *buf, *end;
+
+	MPASS(ptk->ptk_key != NULL);
+	MPASS((offset & PEFS_SECTOR_MASK) == 0);
+
+	pefs_session_enter(ptk->ptk_key->pk_alg, &ses);
+	buf = (char *)pc->pc_base;
+	end = buf + pc->pc_size;
+	while (buf < end) {
+		if ((end - buf) >= PEFS_SECTOR_SIZE) {
+			p = (long *)buf;
+			resid = PEFS_SECTOR_SIZE / sizeof(long);
+			for (; resid > 0; resid--)
+				if (*(p++) != 0)
+					break;
+			if (resid == 0) {
+				bzero(buf, PEFS_SECTOR_SIZE);
+				offset += PEFS_SECTOR_SIZE;
+				buf += PEFS_SECTOR_SIZE;
+				continue;
+			}
+			resid = PEFS_SECTOR_SIZE;
+		} else
+			resid = end - buf;
+		pefs_xts_block_decrypt(ptk->ptk_key->pk_alg, &ses,
+		    ptk->ptk_key->pk_tweak_ctx, ptk->ptk_key->pk_data_ctx,
+		    offset, ptk->ptk_tweak, resid, buf, buf);
+		buf += resid;
+		offset += resid;
+	}
+	pefs_session_leave(ptk->ptk_key->pk_alg, &ses);
+}
+
+/*
+ * File name layout: [checksum] [tweak] [name]
+ * File name is padded with zeros to 16 byte boundary
+ */
+static __inline size_t
+pefs_name_padsize(size_t size)
+{
+	size_t psize;
+
+	psize = size - PEFS_NAME_CSUM_SIZE;
+	psize = PEFS_NAME_CSUM_SIZE +
+	    roundup2(psize, PEFS_NAME_BLOCK_SIZE);
+
+	return (psize);
+}
+
+static __inline size_t
+pefs_name_pad(char *name, size_t size, size_t maxsize)
+{
+	size_t psize;
+
+	MPASS(size > PEFS_NAME_CSUM_SIZE && size <= MAXNAMLEN);
+	psize = pefs_name_padsize(size);
+	MPASS(psize <= MAXNAMLEN);
+	if (psize != size) {
+		if (maxsize < psize)
+			panic("pefs_name_pad: buffer is too small");
+		bzero(name + size, psize - size);
+	}
+
+	return (psize);
+}
+
+static void
+pefs_name_checksum(struct pefs_ctx *ctx, struct pefs_key *pk, char *csum,
+    char *name, size_t size)
+{
+	uint64_t buf[howmany(MAXNAMLEN + 1, sizeof(uint64_t))];
+	uint64_t nonce[2];
+	uint64_t csum_int;
+	char *data;
+
+	MPASS(size >= PEFS_NAME_CSUM_SIZE + (PEFS_TWEAK_SIZE * 2) &&
+	    size <= MAXNAMLEN &&
+	    (size - PEFS_NAME_CSUM_SIZE) % PEFS_NAME_BLOCK_SIZE == 0);
+
+	/*
+	 * First block of encrypted name contains 64bit random tweak.
+	 * Considering AES strong cipher reuse it as a nonce. It's rather far
+	 * from what VMAC specification suggests, but storing additional random
+	 * data in file name is too expensive and decrypting before running vmac
+	 * degrades performance dramatically.
+	 * Use separate key for name checksum.
+	 */
+	memcpy(nonce, name + PEFS_NAME_CSUM_SIZE, PEFS_TWEAK_SIZE * 2);
+	((char *)nonce)[15] &= 0xfe; /* VMAC requirement */
+
+	size -= PEFS_NAME_CSUM_SIZE;
+	data = name + PEFS_NAME_CSUM_SIZE;
+	if (((uintptr_t)data & (__alignof__(uint64_t) - 1)) != 0) {
+		memcpy(buf, data, size);
+		data = (char *)buf;
+	}
+
+	pefs_ctx_cpy(ctx, pk->pk_name_csum_ctx);
+	csum_int = vmac(data, size, (char *)nonce, NULL, &ctx->o.pctx_vmac);
+	memcpy(csum, &csum_int, PEFS_NAME_CSUM_SIZE);
+}
+
+static __inline int
+pefs_name_checksum_eq(const uint8_t *mac1, const uint8_t *mac2)
+{
+	int i, result;
+
+	result = 0;
+	for (i = 0; i < PEFS_NAME_CSUM_SIZE; i++)
+		result |= *(mac1++) ^ *(mac2++);
+
+	return (result == 0);
+}
+
+static void
+pefs_name_enccbc(struct pefs_key *pk, u_char *data, ssize_t size)
+{
+	struct pefs_session ses;
+	u_char *prev;
+	int i;
+
+	size -= PEFS_NAME_CSUM_SIZE;
+	data += PEFS_NAME_CSUM_SIZE;
+	MPASS(size > 0 && size % PEFS_NAME_BLOCK_SIZE == 0);
+
+	pefs_session_enter(&pefs_alg_aes, &ses);
+	/* Start with zero iv */
+	while (1) {
+		pefs_alg_aes.pa_encrypt(&ses, pk->pk_name_ctx, data, data);
+		prev = data;
+		data += PEFS_NAME_BLOCK_SIZE;
+		size -= PEFS_NAME_BLOCK_SIZE;
+		if (size == 0)
+			break;
+		for (i = 0; i < PEFS_NAME_BLOCK_SIZE; i++)
+			data[i] ^= prev[i];
+	}
+	pefs_session_leave(&pefs_alg_aes, &ses);
+}
+
+static void
+pefs_name_deccbc(struct pefs_key *pk, u_char *data, ssize_t size)
+{
+	struct pefs_session ses;
+	u_char tmp[PEFS_NAME_BLOCK_SIZE], iv[PEFS_NAME_BLOCK_SIZE];
+	int i;
+
+	size -= PEFS_NAME_CSUM_SIZE;
+	data += PEFS_NAME_CSUM_SIZE;
+	MPASS(size > 0 && size % PEFS_NAME_BLOCK_SIZE == 0);
+
+	pefs_session_enter(&pefs_alg_aes, &ses);
+	bzero(iv, PEFS_NAME_BLOCK_SIZE);
+	while (size > 0) {
+		memcpy(tmp, data, PEFS_NAME_BLOCK_SIZE);
+		pefs_alg_aes.pa_decrypt(&ses, pk->pk_name_ctx, data, data);
+		for (i = 0; i < PEFS_NAME_BLOCK_SIZE; i++)
+			data[i] ^= iv[i];
+		memcpy(iv, tmp, PEFS_NAME_BLOCK_SIZE);
+		data += PEFS_NAME_BLOCK_SIZE;
+		size -= PEFS_NAME_BLOCK_SIZE;
+	}
+	pefs_session_leave(&pefs_alg_aes, &ses);
+}
+
+int
+pefs_name_encrypt(struct pefs_ctx *ctx, struct pefs_tkey *ptk,
+    const char *plain, size_t plain_len, char *enc, size_t enc_size)
+{
+	char buf[MAXNAMLEN + 1];
+	size_t size;
+	int free_ctx = 0;
+	int r;
+
+	KASSERT(ptk != NULL && ptk->ptk_key != NULL,
+	    ("pefs_name_encrypt: key is null"));
+
+	size = PEFS_NAME_CSUM_SIZE + PEFS_TWEAK_SIZE + plain_len;
+	/* Resulting name size, count '.' prepended to name */
+	r = PEFS_NAME_NTOP_SIZE(pefs_name_padsize(size)) + 1;
+	if (r > MAXNAMLEN) {
+		return (-ENAMETOOLONG);
+	}
+	if (enc_size < r) {
+		printf("pefs: name encryption buffer is too small: "
+		    "length %zd, required %d\n", enc_size, r);
+		return (-EOVERFLOW);
+	}
+
+	if (ctx == NULL) {
+		ctx = pefs_ctx_get();
+		free_ctx = 1;
+	}
+
+	memcpy(buf + PEFS_NAME_CSUM_SIZE, ptk->ptk_tweak, PEFS_TWEAK_SIZE);
+	memcpy(buf + PEFS_NAME_CSUM_SIZE + PEFS_TWEAK_SIZE, plain, plain_len);
+
+	size = pefs_name_pad(buf, size, sizeof(buf));
+	pefs_name_enccbc(ptk->ptk_key, buf, size);
+	pefs_name_checksum(ctx, ptk->ptk_key, buf, buf, size);
+
+	if (free_ctx != 0)
+		pefs_ctx_free(ctx);
+
+	enc[0] = '.';
+	r = pefs_name_ntop(buf, size, enc + 1, enc_size - 1);
+	if (r <= 0)
+		return (r);
+	r++;
+
+	return (r);
+}
+
+int
+pefs_name_decrypt(struct pefs_ctx *ctx, struct pefs_key *pk,
+    struct pefs_tkey *ptk, const char *enc, size_t enc_len,
+    char *plain, size_t plain_size)
+{
+	struct pefs_key *ki;
+	char csum[PEFS_NAME_CSUM_SIZE];
+	int free_ctx = 0;
+	int r, ki_rev;
+
+	KASSERT(enc != plain, ("pefs_name_decrypt: "
+	    "ciphertext and plaintext buffers should differ"));
+	MPASS(enc_len > 0 && enc_len <= MAXNAMLEN);
+
+	if (enc[0] != '.' || enc_len <= 1)
+		return (-EINVAL);
+	enc++;
+	enc_len--;
+
+	r = PEFS_NAME_PTON_SIZE(enc_len);
+	if (r <= PEFS_TWEAK_SIZE + PEFS_NAME_CSUM_SIZE ||
+	    (r - PEFS_NAME_CSUM_SIZE) % PEFS_NAME_BLOCK_SIZE != 0)
+		return (-EINVAL);
+	if (plain_size < r) {
+		printf("pefs: name decryption buffer is too small: "
+		    "length %zd, required %d\n", plain_size, r);
+		return (-EOVERFLOW);
+	}
+
+	r = pefs_name_pton(enc, enc_len, plain, plain_size);
+	if (r <= 0) {
+		PEFSDEBUG("pefs_name_decrypt: error: r=%d\n", r);
+		return (-EINVAL);
+	}
+
+	if (ctx == NULL) {
+		ctx = pefs_ctx_get();
+		free_ctx = 1;
+	}
+
+	ki = pk;
+	ki_rev = 0;
+	do {
+		pefs_name_checksum(ctx, ki, csum, plain, r);
+		if (pefs_name_checksum_eq(csum, plain))
+			break;
+
+		if (ki_rev == 0) {
+			ki = TAILQ_NEXT(ki, pk_entry);
+			if (ki == NULL) {
+				ki_rev = 1;
+				ki = pk;
+			}
+		}
+		if (ki_rev != 0)
+			ki = TAILQ_PREV(ki, pefs_key_head, pk_entry);
+	} while (ki != NULL);
+
+	if (free_ctx != 0)
+		pefs_ctx_free(ctx);
+
+	if (ki == NULL)
+		return (-EINVAL);
+
+	pefs_name_deccbc(ki, plain, r);
+
+	if (ptk != NULL) {
+		ptk->ptk_key = ki;
+		memcpy(ptk->ptk_tweak, plain + PEFS_NAME_CSUM_SIZE,
+		    PEFS_TWEAK_SIZE);
+	}
+
+	r -= PEFS_TWEAK_SIZE + PEFS_NAME_CSUM_SIZE;
+	memcpy(plain, plain + PEFS_NAME_CSUM_SIZE + PEFS_TWEAK_SIZE, r);
+	plain[r] = '\0';
+	/* Remove encryption zero padding */
+	while (r > 0 && plain[r - 1] == '\0')
+		r--;
+	MPASS(r > 0 && strlen(plain) == r);
+
+	return (r);
+}
+
+static int
+pefs_aes_keysetup(const struct pefs_session *sess __unused,
+    struct pefs_ctx *ctx, const uint8_t *key, uint32_t keybits)
+{
+	rijndael_set_key(&ctx->o.pctx_aes, key, keybits);
+	return (0);
+}
+
+static void
+pefs_aes_encrypt(const struct pefs_session *sess __unused,
+	    const struct pefs_ctx *ctx, const uint8_t *in, uint8_t *out)
+{
+	rijndael_encrypt(&ctx->o.pctx_aes, in, out);
+}
+
+static void
+pefs_aes_decrypt(const struct pefs_session *sess __unused,
+	    const struct pefs_ctx *ctx, const uint8_t *in, uint8_t *out)
+{
+	rijndael_decrypt(&ctx->o.pctx_aes, in, out);
+}
+
+static int
+pefs_camellia_keysetup(const struct pefs_session *sess __unused,
+    struct pefs_ctx *ctx, const uint8_t *key, uint32_t keybits)
+{
+	camellia_set_key(&ctx->o.pctx_camellia, key, keybits);
+	return (0);
+}
+
+static void
+pefs_camellia_encrypt(const struct pefs_session *sess __unused,
+	    const struct pefs_ctx *ctx, const uint8_t *in, uint8_t *out)
+{
+	camellia_encrypt(&ctx->o.pctx_camellia, in, out);
+}
+
+static void
+pefs_camellia_decrypt(const struct pefs_session *sess __unused,
+	    const struct pefs_ctx *ctx, const uint8_t *in, uint8_t *out)
+{
+	camellia_decrypt(&ctx->o.pctx_camellia, in, out);
+}
diff --git sys/fs/pefs/pefs_crypto.h sys/fs/pefs/pefs_crypto.h
new file mode 100644
index 0000000..afdb113
--- /dev/null
+++ sys/fs/pefs/pefs_crypto.h
@@ -0,0 +1,92 @@
+/*-
+ * Copyright (c) 2009 Gleb Kurtsou <gleb@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#include <crypto/camellia/camellia.h>
+#include <crypto/hmac/hmac.h>
+#include <crypto/rijndael/rijndael.h>
+
+#include <fs/pefs/pefs_aesni.h>
+#include <fs/pefs/vmac.h>
+
+struct pefs_alg;
+struct pefs_ctx;
+struct pefs_session;
+
+typedef void	algop_init_t(struct pefs_alg *alg);
+typedef void	algop_uninit_t(struct pefs_alg *alg);
+typedef void	algop_session_t(struct pefs_session *ses);
+typedef int	algop_keysetup_t(const struct pefs_session *sess,
+	    struct pefs_ctx *ctx, const uint8_t *key, uint32_t keybits);
+typedef void	algop_crypt_t(const struct pefs_session *sess,
+	    const struct pefs_ctx *ctx, const uint8_t *in, uint8_t *out);
+
+struct pefs_alg {
+	algop_session_t		*pa_enter;
+	algop_session_t		*pa_leave;
+	algop_crypt_t		*pa_encrypt;
+	algop_crypt_t		*pa_decrypt;
+	algop_keysetup_t	*pa_keysetup;
+	algop_init_t		*pa_init;
+	algop_uninit_t		*pa_uninit;
+	int			pa_id;
+};
+
+struct pefs_ctx {
+	union {
+		camellia_ctx	pctx_camellia;
+		rijndael_ctx	pctx_aes;
+		struct hmac_ctx	pctx_hmac;
+		vmac_ctx_t	pctx_vmac;
+#ifdef PEFS_AESNI
+		struct pefs_aesni_ctx pctx_aesni;
+#endif
+	} o;
+} __aligned(CACHE_LINE_SIZE);
+
+struct pefs_session {
+	union {
+		int dummy;
+#ifdef PEFS_AESNI
+		struct pefs_aesni_ses ps_aesni;
+#endif
+	} o;
+};
+
+algop_init_t	pefs_aesni_init;
+
+void	pefs_xts_block_encrypt(const struct pefs_alg *alg,
+	    const struct pefs_session *ses,
+	    const struct pefs_ctx *tweak_ctx, const struct pefs_ctx *data_ctx,
+	    uint64_t sector, const uint8_t *xtweak, int len,
+	    const uint8_t *src, uint8_t *dst);
+
+void	pefs_xts_block_decrypt(const struct pefs_alg *alg,
+	    const struct pefs_session *ses,
+	    const struct pefs_ctx *tweak_ctx, const struct pefs_ctx *data_ctx,
+	    uint64_t sector, const uint8_t *xtweak, int len,
+	    const uint8_t *src, uint8_t *dst);
diff --git sys/fs/pefs/pefs_dircache.c sys/fs/pefs/pefs_dircache.c
new file mode 100644
index 0000000..070d5ea
--- /dev/null
+++ sys/fs/pefs/pefs_dircache.c
@@ -0,0 +1,394 @@
+/*-
+ * Copyright (c) 2009 Gleb Kurtsou <gleb@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/lock.h>
+#include <sys/malloc.h>
+#include <sys/mount.h>
+#include <sys/mutex.h>
+#include <sys/namei.h>
+#include <sys/dirent.h>
+#include <sys/hash.h>
+#include <sys/queue.h>
+#include <sys/proc.h>
+#include <sys/sysctl.h>
+#include <sys/sx.h>
+#include <sys/uio.h>
+#include <sys/taskqueue.h>
+#include <sys/vnode.h>
+
+#include <fs/pefs/pefs.h>
+#include <fs/pefs/pefs_dircache.h>
+
+#define	DIRCACHE_SIZE_ENV	"vfs.pefs.dircache.buckets"
+#define	DIRCACHE_SIZE_MIN	512
+#define	DIRCACHE_SIZE_DEFAULT	(desiredvnodes / 8)
+
+#define	DIRCACHE_HEADOFF(pd)	(((pd)->pd_flags & PD_SWAPEDHEADS) ? 1 : 0)
+#define	DIRCACHE_ACTIVEHEAD(pd)	(&(pd)->pd_heads[DIRCACHE_HEADOFF(pd) ^ 0])
+#define	DIRCACHE_STALEHEAD(pd)	(&(pd)->pd_heads[DIRCACHE_HEADOFF(pd) ^ 1])
+
+#define	DIRCACHE_ASSERT(pd)	MPASS(LIST_EMPTY(&(pd)->pd_heads[0]) || \
+		LIST_EMPTY(&(pd)->pd_heads[1]))
+
+static struct mtx		dircache_mtx;
+
+static struct pefs_dircache_listhead *dircache_tbl;
+static struct pefs_dircache_listhead *dircache_enctbl;
+static u_long			pefs_dircache_hashmask;
+
+static uma_zone_t		dircache_zone;
+static uma_zone_t		dircache_entry_zone;
+
+SYSCTL_NODE(_vfs_pefs, OID_AUTO, dircache, CTLFLAG_RW, 0,
+    "PEFS directory cache");
+
+int		pefs_dircache_enable = 1;
+SYSCTL_INT(_vfs_pefs_dircache, OID_AUTO, enable, CTLFLAG_RW,
+    &pefs_dircache_enable, 0, "Enable dircache");
+
+static u_long	dircache_buckets = 0;
+SYSCTL_ULONG(_vfs_pefs_dircache, OID_AUTO, buckets, CTLFLAG_RD,
+    &dircache_buckets, 0, "Number of dircache hash table buckets");
+
+static u_long	dircache_entries = 0;
+SYSCTL_ULONG(_vfs_pefs_dircache, OID_AUTO, entries, CTLFLAG_RD,
+    &dircache_entries, 0, "Entries in dircache");
+
+static void	dircache_entry_free(struct pefs_dircache_entry *pde);
+
+void
+pefs_dircache_init(void)
+{
+	TUNABLE_ULONG_FETCH(DIRCACHE_SIZE_ENV, &dircache_buckets);
+
+	if (dircache_buckets < DIRCACHE_SIZE_MIN)
+		dircache_buckets = DIRCACHE_SIZE_DEFAULT;
+
+	dircache_zone = uma_zcreate("pefs_dircache",
+	    sizeof(struct pefs_dircache), NULL, NULL, NULL, NULL,
+	    UMA_ALIGN_PTR, 0);
+	dircache_entry_zone = uma_zcreate("pefs_dircache_entry",
+	    sizeof(struct pefs_dircache_entry), NULL, NULL, NULL,
+	    (uma_fini) bzero, UMA_ALIGN_PTR, 0);
+
+	dircache_tbl = hashinit(dircache_buckets, M_PEFSHASH,
+	    &pefs_dircache_hashmask);
+	dircache_enctbl = hashinit(dircache_buckets, M_PEFSHASH,
+	    &pefs_dircache_hashmask);
+	mtx_init(&dircache_mtx, "pefs_dircache_mtx", NULL, MTX_DEF);
+}
+
+void
+pefs_dircache_uninit(void)
+{
+	mtx_destroy(&dircache_mtx);
+	free(dircache_tbl, M_PEFSHASH);
+	free(dircache_enctbl, M_PEFSHASH);
+	uma_zdestroy(dircache_zone);
+	uma_zdestroy(dircache_entry_zone);
+}
+
+struct pefs_dircache *
+pefs_dircache_get(void)
+{
+	struct pefs_dircache *pd;
+
+	pd = uma_zalloc(dircache_zone, M_WAITOK | M_ZERO);
+	sx_init(&pd->pd_lock, "pefs_dircache_sx");
+	LIST_INIT(&pd->pd_heads[0]);
+	LIST_INIT(&pd->pd_heads[1]);
+
+	return (pd);
+}
+
+void
+pefs_dircache_free(struct pefs_dircache *pd)
+{
+	struct pefs_dircache_entry *pde;
+
+	if (pd == NULL)
+		return;
+
+	while (!LIST_EMPTY(DIRCACHE_STALEHEAD(pd))) {
+		pde = LIST_FIRST(DIRCACHE_STALEHEAD(pd));
+		dircache_entry_free(pde);
+	}
+	while (!LIST_EMPTY(DIRCACHE_ACTIVEHEAD(pd))) {
+		pde = LIST_FIRST(DIRCACHE_ACTIVEHEAD(pd));
+		dircache_entry_free(pde);
+	}
+	sx_destroy(&pd->pd_lock);
+	uma_zfree(dircache_zone, pd);
+}
+
+static __inline uint32_t
+dircache_hashname(struct pefs_dircache *pd, char const *buf, size_t len)
+{
+	uint32_t h;
+
+	h = pefs_hash_mixptr(pd);
+	h ^= hash32_buf(buf, len, HASHINIT * len);
+	return (h);
+}
+
+static void
+dircache_entry_free(struct pefs_dircache_entry *pde)
+{
+	MPASS(pde != NULL);
+
+	PEFSDEBUG("dircache_entry_free: %s -> %s\n",
+	    pde->pde_name, pde->pde_encname);
+	pefs_key_release(pde->pde_tkey.ptk_key);
+	LIST_REMOVE(pde, pde_dir_entry);
+	mtx_lock(&dircache_mtx);
+	LIST_REMOVE(pde, pde_hash_entry);
+	LIST_REMOVE(pde, pde_enchash_entry);
+	dircache_entries--;
+	mtx_unlock(&dircache_mtx);
+	uma_zfree(dircache_entry_zone, pde);
+}
+
+static void
+dircache_expire(struct pefs_dircache *pd)
+{
+	struct pefs_dircache_entry *pde;
+
+	pd->pd_gen = 0;
+	if (LIST_EMPTY(DIRCACHE_STALEHEAD(pd))) {
+		pd->pd_flags ^= PD_SWAPEDHEADS;
+	} else while (!LIST_EMPTY(DIRCACHE_ACTIVEHEAD(pd))) {
+		pde = LIST_FIRST(DIRCACHE_ACTIVEHEAD(pd));
+		pde->pde_gen = 0;
+		LIST_REMOVE(pde, pde_dir_entry);
+		LIST_INSERT_HEAD(DIRCACHE_STALEHEAD(pd), pde, pde_dir_entry);
+		PEFSDEBUG("dircache_expire: active entry: %p\n", pde);
+	}
+	MPASS(LIST_EMPTY(DIRCACHE_ACTIVEHEAD(pd)));
+}
+
+static void
+dircache_update(struct pefs_dircache_entry *pde, int onlist)
+{
+	struct pefs_dircache *pd = pde->pde_dircache;
+
+	sx_assert(&pd->pd_lock, SA_XLOCKED);
+
+	if ((pd->pd_flags & PD_UPDATING) != 0) {
+		PEFSDEBUG("pefs_dircache_update: %s -> %s\n",
+		    pde->pde_name, pde->pde_encname);
+		pde->pde_gen = pd->pd_gen;
+		if (onlist != 0)
+			LIST_REMOVE(pde, pde_dir_entry);
+		LIST_INSERT_HEAD(DIRCACHE_ACTIVEHEAD(pd), pde, pde_dir_entry);
+	} else if (pd->pd_gen == 0 || pd->pd_gen != pde->pde_gen) {
+		PEFSDEBUG("pefs_dircache: inconsistent cache: "
+		    "gen=%ld old_gen=%ld name=%s\n",
+		    pd->pd_gen, pde->pde_gen, pde->pde_name);
+		dircache_expire(pd);
+		pde->pde_gen = 0;
+		if (onlist == 0)
+			LIST_INSERT_HEAD(DIRCACHE_STALEHEAD(pd), pde,
+					pde_dir_entry);
+	}
+}
+
+struct pefs_dircache_entry *
+pefs_dircache_insert(struct pefs_dircache *pd, struct pefs_tkey *ptk,
+    char const *name, size_t name_len,
+    char const *encname, size_t encname_len)
+{
+	struct pefs_dircache_listhead *head;
+	struct pefs_dircache_entry *pde;
+
+	MPASS(ptk->ptk_key != NULL);
+	sx_assert(&pd->pd_lock, SA_XLOCKED);
+
+	if (name_len == 0 || name_len >= sizeof(pde->pde_name) ||
+	    encname_len == 0 || encname_len >= sizeof(pde->pde_encname))
+		panic("pefs: invalid file name length: %zd/%zd",
+		    name_len, encname_len);
+
+	pde = uma_zalloc(dircache_entry_zone, M_WAITOK | M_ZERO);
+	pde->pde_dircache = pd;
+
+	pde->pde_tkey = *ptk;
+	pefs_key_ref(pde->pde_tkey.ptk_key);
+
+	pde->pde_namelen = name_len;
+	memcpy(pde->pde_name, name, name_len);
+	pde->pde_name[name_len] = '\0';
+	pde->pde_namehash = dircache_hashname(pd, pde->pde_name,
+	    pde->pde_namelen);
+
+	pde->pde_encnamelen = encname_len;
+	memcpy(pde->pde_encname, encname, encname_len);
+	pde->pde_encname[encname_len] = '\0';
+	pde->pde_encnamehash = dircache_hashname(pd, pde->pde_encname,
+	    pde->pde_encnamelen);
+
+	/* Insert into list and set pge_gen */
+	dircache_update(pde, 0);
+
+	mtx_lock(&dircache_mtx);
+	head = &dircache_tbl[pde->pde_namehash & pefs_dircache_hashmask];
+	LIST_INSERT_HEAD(head, pde, pde_hash_entry);
+	head = &dircache_enctbl[pde->pde_encnamehash & pefs_dircache_hashmask];
+	LIST_INSERT_HEAD(head, pde, pde_enchash_entry);
+	dircache_entries++;
+	mtx_unlock(&dircache_mtx);
+
+	PEFSDEBUG("pefs_dircache_insert: hash=%x enchash=%x: %s -> %s\n",
+	    pde->pde_namehash, pde->pde_encnamehash,
+	    pde->pde_name, pde->pde_encname);
+
+	return (pde);
+}
+
+struct pefs_dircache_entry *
+pefs_dircache_lookup(struct pefs_dircache *pd, char const *name,
+    size_t name_len)
+{
+	struct pefs_dircache_entry *pde;
+	struct pefs_dircache_listhead *head;
+	uint32_t h;
+
+	MPASS(pd != NULL);
+	MPASS((pd->pd_flags & PD_UPDATING) == 0);
+	MPASS(LIST_EMPTY(DIRCACHE_STALEHEAD(pd)));
+
+	h = dircache_hashname(pd, name, name_len);
+	head = &dircache_tbl[h & pefs_dircache_hashmask];
+	mtx_lock(&dircache_mtx);
+	LIST_FOREACH(pde, head, pde_hash_entry) {
+		if (pde->pde_namehash == h &&
+		    pde->pde_dircache == pd &&
+		    pde->pde_gen == pd->pd_gen &&
+		    pde->pde_namelen == name_len &&
+		    memcmp(pde->pde_name, name, name_len) == 0) {
+			mtx_unlock(&dircache_mtx);
+			PEFSDEBUG("pefs_dircache_lookup: found %s -> %s\n",
+			    pde->pde_name, pde->pde_encname);
+			return (pde);
+		}
+	}
+	mtx_unlock(&dircache_mtx);
+	PEFSDEBUG("pefs_dircache_lookup: not found %s\n", name);
+	return (NULL);
+}
+
+struct pefs_dircache_entry *
+pefs_dircache_enclookup(struct pefs_dircache *pd, char const *encname,
+    size_t encname_len)
+{
+	struct pefs_dircache_entry *pde;
+	struct pefs_dircache_listhead *head;
+	uint32_t h;
+
+	h = dircache_hashname(pd, encname, encname_len);
+	head = &dircache_enctbl[h & pefs_dircache_hashmask];
+	mtx_lock(&dircache_mtx);
+	LIST_FOREACH(pde, head, pde_enchash_entry) {
+		if (pde->pde_encnamehash == h &&
+		    pde->pde_dircache == pd &&
+		    pde->pde_encnamelen == encname_len &&
+		    memcmp(pde->pde_encname, encname, encname_len) == 0) {
+			mtx_unlock(&dircache_mtx);
+			PEFSDEBUG("pefs_dircache_enclookup: found %s -> %s\n",
+			    pde->pde_name, pde->pde_encname);
+			return (pde);
+		}
+	}
+	mtx_unlock(&dircache_mtx);
+	PEFSDEBUG("pefs_dircache_enclookup: not found %s\n", encname);
+	return (NULL);
+}
+
+void
+pefs_dircache_update(struct pefs_dircache_entry *pde)
+{
+	dircache_update(pde, 1);
+}
+
+void
+pefs_dircache_beginupdate(struct pefs_dircache *pd, u_long gen)
+{
+	if (sx_try_upgrade(&pd->pd_lock) == 0) {
+		/* vnode should be locked to avoid races */
+		sx_unlock(&pd->pd_lock);
+		sx_xlock(&pd->pd_lock);
+	}
+	if (gen != 0 && pd->pd_gen != gen) {
+		PEFSDEBUG("pefs_dircache_beginupdate: update: gen=%lu %p\n",
+		    gen, pd);
+		if (!LIST_EMPTY(DIRCACHE_ACTIVEHEAD(pd))) {
+			/* Assert consistent state */
+			MPASS(LIST_EMPTY(DIRCACHE_STALEHEAD(pd)));
+			dircache_expire(pd);
+		}
+		pd->pd_gen = gen;
+		pd->pd_flags |= PD_UPDATING;
+		MPASS(LIST_EMPTY(DIRCACHE_ACTIVEHEAD(pd)));
+	}
+}
+
+void
+pefs_dircache_abortupdate(struct pefs_dircache *pd)
+{
+	sx_assert(&pd->pd_lock, SA_XLOCKED);
+
+	if ((pd->pd_flags & PD_UPDATING) != 0) {
+		PEFSDEBUG("pefs_dircache_abortupdate: gen=%lu %p\n",
+		    pd->pd_gen, pd);
+		dircache_expire(pd);
+		pd->pd_flags &= ~PD_UPDATING;
+	}
+	DIRCACHE_ASSERT(pd);
+}
+
+void
+pefs_dircache_endupdate(struct pefs_dircache *pd)
+{
+	struct pefs_dircache_entry *pde;
+
+	sx_assert(&pd->pd_lock, SA_XLOCKED);
+
+	if ((pd->pd_flags & PD_UPDATING) == 0) {
+		DIRCACHE_ASSERT(pd);
+		return;
+	}
+
+	while (!LIST_EMPTY(DIRCACHE_STALEHEAD(pd))) {
+		pde = LIST_FIRST(DIRCACHE_STALEHEAD(pd));
+		dircache_entry_free(pde);
+	}
+	pd->pd_flags &= ~PD_UPDATING;
+}
diff --git sys/fs/pefs/pefs_dircache.h sys/fs/pefs/pefs_dircache.h
new file mode 100644
index 0000000..209a356
--- /dev/null
+++ sys/fs/pefs/pefs_dircache.h
@@ -0,0 +1,97 @@
+/*-
+ * Copyright (c) 2009 Gleb Kurtsou <gleb@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+
+#define	PEFS_CACHENAME_MAXLEN		PEFS_NAME_PTON_SIZE(MAXNAMLEN)
+
+struct pefs_dircache_entry;
+LIST_HEAD(pefs_dircache_listhead, pefs_dircache_entry);
+
+#define	PD_UPDATING			0x01
+#define	PD_SWAPEDHEADS			0x02
+
+struct pefs_dircache {
+	struct sx		pd_lock;
+	struct pefs_dircache_listhead pd_heads[2];
+	u_long			pd_gen;
+	int			pd_flags;
+};
+
+struct pefs_dircache_entry {
+	LIST_ENTRY(pefs_dircache_entry) pde_dir_entry;
+	LIST_ENTRY(pefs_dircache_entry) pde_hash_entry;
+	LIST_ENTRY(pefs_dircache_entry) pde_enchash_entry;
+	struct pefs_dircache	*pde_dircache;
+	struct pefs_tkey	pde_tkey;
+	u_long			pde_gen;
+	uint32_t		pde_namehash;
+	uint32_t		pde_encnamehash;
+	uint16_t		pde_namelen;
+	uint16_t		pde_encnamelen;
+	char			pde_name[PEFS_CACHENAME_MAXLEN + 1];
+	char			pde_encname[MAXNAMLEN + 1];
+};
+
+extern int			pefs_dircache_enable;
+
+void	pefs_dircache_init(void);
+void	pefs_dircache_uninit(void);
+
+struct pefs_dircache	*pefs_dircache_get(void);
+void	pefs_dircache_free(struct pefs_dircache *pd);
+void	pefs_dircache_update(struct pefs_dircache_entry *pde);
+void	pefs_dircache_beginupdate(struct pefs_dircache *pd, u_long gen);
+void	pefs_dircache_endupdate(struct pefs_dircache *pd);
+void	pefs_dircache_abortupdate(struct pefs_dircache *pd);
+struct pefs_dircache_entry *pefs_dircache_lookup(struct pefs_dircache *pd,
+	    char const *name, size_t name_len);
+struct pefs_dircache_entry *pefs_dircache_enclookup(struct pefs_dircache *pd,
+	    char const *encname, size_t encname_len);
+struct pefs_dircache_entry *pefs_dircache_insert(struct pefs_dircache *pd,
+	    struct pefs_tkey *ptk, char const *name, size_t name_len,
+	    char const *encname, size_t encname_len);
+
+static __inline void
+pefs_dircache_lock(struct pefs_dircache *pd)
+{
+	sx_slock(&pd->pd_lock);
+}
+
+static __inline void
+pefs_dircache_unlock(struct pefs_dircache *pd)
+{
+	sx_unlock(&pd->pd_lock);
+}
+
+static __inline int
+pefs_dircache_valid(struct pefs_dircache *pd, u_long gen)
+{
+	sx_assert(&pd->pd_lock, SA_LOCKED);
+
+	return (gen == pd->pd_gen && gen != 0);
+}
diff --git sys/fs/pefs/pefs_subr.c sys/fs/pefs/pefs_subr.c
new file mode 100644
index 0000000..127cd7f
--- /dev/null
+++ sys/fs/pefs/pefs_subr.c
@@ -0,0 +1,704 @@
+/*-
+ * Copyright (c) 1992, 1993 The Regents of the University of California.
+ * Copyright (c) 2009 Gleb Kurtsou <gleb@FreeBSD.org>
+ * All rights reserved.
+ *
+ * This code is derived from software donated to Berkeley by
+ * Jan-Simon Pendry.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/lock.h>
+#include <sys/malloc.h>
+#include <sys/mount.h>
+#include <sys/mutex.h>
+#include <sys/namei.h>
+#include <sys/dirent.h>
+#include <sys/queue.h>
+#include <sys/proc.h>
+#include <sys/sysctl.h>
+#include <sys/sx.h>
+#include <sys/uio.h>
+#include <sys/taskqueue.h>
+#include <sys/vnode.h>
+
+#include <fs/pefs/pefs.h>
+#include <fs/pefs/pefs_dircache.h>
+
+typedef int	pefs_node_init_fn(struct mount *mp, struct pefs_node *pn,
+	    void *context);
+LIST_HEAD(pefs_node_listhead, pefs_node);
+
+static struct taskqueue		*pefs_taskq;
+static struct task		pefs_task_freenode;
+
+static struct mtx		pefs_node_listmtx;
+
+static struct pefs_node_listhead pefs_node_freelist;
+static struct pefs_node_listhead *pefs_nodehash_tbl;
+static u_long			pefs_nodehash_mask;
+
+static uma_zone_t		pefs_node_zone;
+
+MALLOC_DEFINE(M_PEFSHASH, "pefs_hash", "PEFS hash table");
+MALLOC_DEFINE(M_PEFSBUF, "pefs_buf", "PEFS buffers");
+
+SYSCTL_NODE(_vfs, OID_AUTO, pefs, CTLFLAG_RW, 0, "PEFS file system");
+
+static u_long	pefs_nodes;
+SYSCTL_ULONG(_vfs_pefs, OID_AUTO, nodes, CTLFLAG_RD, &pefs_nodes, 0,
+    "Allocated nodes");
+
+static void	pefs_node_free_proc(void *, int);
+
+/*
+ * Initialise cache headers
+ */
+int
+pefs_init(struct vfsconf *vfsp)
+{
+	PEFSDEBUG("pefs_init\n");
+
+	LIST_INIT(&pefs_node_freelist);
+
+	TASK_INIT(&pefs_task_freenode, 0, pefs_node_free_proc, NULL);
+	pefs_taskq = taskqueue_create("pefs_taskq", M_WAITOK,
+	    taskqueue_thread_enqueue, &pefs_taskq);
+	taskqueue_start_threads(&pefs_taskq, 1, PVFS, "pefs taskq");
+
+	pefs_node_zone = uma_zcreate("pefs_node", sizeof(struct pefs_node),
+	    NULL, NULL, NULL, (uma_fini) bzero, UMA_ALIGN_PTR, 0);
+
+	pefs_nodehash_tbl = hashinit(desiredvnodes / 8, M_PEFSHASH,
+	    &pefs_nodehash_mask);
+	pefs_nodes = 0;
+	mtx_init(&pefs_node_listmtx, "pefs_node_list", NULL, MTX_DEF);
+
+	pefs_dircache_init();
+	pefs_crypto_init();
+
+	return (0);
+}
+
+int
+pefs_uninit(struct vfsconf *vfsp)
+{
+	taskqueue_enqueue(pefs_taskq, &pefs_task_freenode);
+	taskqueue_drain(pefs_taskq, &pefs_task_freenode);
+	taskqueue_free(pefs_taskq);
+	pefs_dircache_uninit();
+	pefs_crypto_uninit();
+	mtx_destroy(&pefs_node_listmtx);
+	free(pefs_nodehash_tbl, M_PEFSHASH);
+	uma_zdestroy(pefs_node_zone);
+	return (0);
+}
+
+static __inline struct pefs_node_listhead *
+pefs_nodehash_gethead(struct vnode *vp)
+{
+	uint32_t v;
+
+	v = pefs_hash_mixptr(vp);
+	return (&pefs_nodehash_tbl[v & pefs_nodehash_mask]);
+}
+
+/*
+ * Return a VREF'ed alias for lower vnode if already exists, else 0.
+ * Lower vnode should be locked on entry and will be left locked on exit.
+ */
+static struct vnode *
+pefs_nodehash_get(struct mount *mp, struct vnode *lowervp)
+{
+	struct pefs_node_listhead *hd;
+	struct pefs_node *a;
+	struct vnode *vp;
+
+	ASSERT_VOP_LOCKED(lowervp, "pefs_nodehash_get");
+
+	/*
+	 * Find hash base, and then search the (two-way) linked
+	 * list looking for a pefs_node structure which is referencing
+	 * the lower vnode.  If found, the increment the pefs_node
+	 * reference count (but NOT the lower vnode's VREF counter).
+	 */
+	hd = pefs_nodehash_gethead(lowervp);
+	mtx_lock(&pefs_node_listmtx);
+	LIST_FOREACH(a, hd, pn_listentry) {
+		if (a->pn_lowervp == lowervp && PN_TO_VP(a)->v_mount == mp) {
+			/*
+			 * Since we have the lower node locked the pefs
+			 * node can not be in the process of recycling.  If
+			 * it had been recycled before we grabed the lower
+			 * lock it would not have been found on the hash.
+			 */
+			vp = PN_TO_VP(a);
+			vref(vp);
+			mtx_unlock(&pefs_node_listmtx);
+			return (vp);
+		}
+	}
+	mtx_unlock(&pefs_node_listmtx);
+	return (NULLVP);
+}
+
+/*
+ * Act like pefs_nodehash_get, but add passed pefs_node to hash if no existing
+ * node found.
+ */
+static struct vnode *
+pefs_nodehash_insert(struct mount *mp, struct pefs_node *pn)
+{
+	struct pefs_node_listhead *hd;
+	struct pefs_node *oxp;
+	struct vnode *ovp;
+
+	hd = pefs_nodehash_gethead(pn->pn_lowervp);
+	mtx_lock(&pefs_node_listmtx);
+	LIST_FOREACH(oxp, hd, pn_listentry) {
+		if (oxp->pn_lowervp == pn->pn_lowervp &&
+		    PN_TO_VP(oxp)->v_mount == mp) {
+			/*
+			 * See pefs_nodehash_get for a description of this
+			 * operation.
+			 */
+			ovp = PN_TO_VP(oxp);
+			vref(ovp);
+			mtx_unlock(&pefs_node_listmtx);
+			return (ovp);
+		}
+	}
+	pefs_nodes++;
+	LIST_INSERT_HEAD(hd, pn, pn_listentry);
+	mtx_unlock(&pefs_node_listmtx);
+	return (NULLVP);
+}
+
+static void
+pefs_insmntque_dtr(struct vnode *vp, void *_pn)
+{
+	struct pefs_node *pn = _pn;
+
+	PEFSDEBUG("pefs_insmntque_dtr: free node %p\n", pn);
+	vp->v_data = NULL;
+	vp->v_vnlock = &vp->v_lock;
+	pefs_key_release(pn->pn_tkey.ptk_key);
+	uma_zfree(pefs_node_zone, pn);
+	vp->v_op = &dead_vnodeops;
+	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY);
+	vgone(vp);
+	vput(vp);
+}
+
+static int
+pefs_node_lookup_name(struct vnode *lvp, struct vnode *ldvp, struct ucred *cred,
+    char *encname, int *encname_len)
+{
+	struct vnode *nldvp;
+	int error, locked, dlocked;
+	int buflen = *encname_len;
+
+	ASSERT_VOP_LOCKED(lvp, "pefs_node_lookup_name");
+	locked = VOP_ISLOCKED(lvp);
+	if (ldvp) {
+		dlocked = VOP_ISLOCKED(ldvp);
+		if (dlocked)
+			VOP_UNLOCK(ldvp, 0);
+	} else
+		dlocked = 0;
+
+	vref(lvp);
+	VOP_UNLOCK(lvp, 0);
+	nldvp = lvp;
+	error = vn_vptocnp(&nldvp, cred, encname, encname_len);
+	if (error == 0) {
+#if __FreeBSD_version >= 900501
+		vrele(nldvp);
+#else
+		vdrop(nldvp);
+#endif
+	}
+	vrele(lvp);
+	if (ldvp && dlocked)
+		vn_lock(ldvp, dlocked | LK_RETRY);
+	vn_lock(lvp, locked | LK_RETRY);
+	if (error != 0)
+		return (ENOENT);
+
+	memcpy(encname, encname + *encname_len, buflen - *encname_len);
+	*encname_len = buflen - *encname_len;
+	if (*encname_len < buflen)
+		encname[*encname_len] = '\0';
+
+	return (0);
+}
+
+static int
+pefs_node_lookup_key(struct pefs_mount *pm, struct vnode *lvp,
+    struct vnode *ldvp, struct ucred *cred, struct pefs_tkey *ptk)
+{
+	char *namebuf;
+	char *encname;
+	int error, encname_len, name_len;
+
+	namebuf = malloc((MAXNAMLEN + 1)*2, M_PEFSBUF, M_WAITOK | M_ZERO);
+	encname = namebuf + MAXNAMLEN + 1;
+	encname_len = MAXNAMLEN + 1;
+
+	error = pefs_node_lookup_name(lvp, ldvp, cred, encname, &encname_len);
+	if (error != 0) {
+		free(namebuf, M_PEFSBUF);
+		return (error);
+	}
+
+	PEFSDEBUG("pefs_node_lookup_key: encname=%.*s\n", encname_len, encname);
+
+	name_len = pefs_name_decrypt(NULL, pefs_rootkey(pm), ptk,
+	    encname, encname_len, namebuf, MAXNAMLEN + 1);
+
+	if (name_len > 0)
+		pefs_key_ref(ptk->ptk_key);
+	else
+		PEFSDEBUG("pefs_node_lookup_key: not found: %.*s\n",
+		    encname_len, encname);
+
+	free(namebuf, M_PEFSBUF);
+
+	return (error);
+}
+
+static int
+pefs_node_init_knownkey(struct mount *mp, struct pefs_node *pn,
+    void *context)
+{
+	struct pefs_tkey *ptk = context;
+
+	MPASS((pn->pn_flags & PN_HASKEY) == 0);
+
+	if (ptk != NULL && ptk->ptk_key != NULL) {
+		pn->pn_tkey = *ptk;
+		pefs_key_ref(pn->pn_tkey.ptk_key);
+		pn->pn_flags |= PN_HASKEY;
+	}
+
+	return (0);
+}
+
+static int
+pefs_node_init_lookupkey(struct mount *mp, struct pefs_node *pn,
+    void *context)
+{
+	struct ucred *cred = context;
+	int error;
+
+	KASSERT(mp->mnt_data != NULL,
+	    ("pefs_node_get_lookupkey called for uninitialized mount point"));
+
+	if (pefs_rootkey(VFS_TO_PEFS(mp)) == NULL)
+		return (0);
+
+	error = pefs_node_lookup_key(VFS_TO_PEFS(mp), pn->pn_lowervp, NULL,
+	    cred, &pn->pn_tkey);
+
+	if (pn->pn_tkey.ptk_key != NULL) {
+		MPASS(error == 0);
+		pn->pn_flags |= PN_HASKEY;
+	}
+
+	return (error);
+
+}
+
+/*
+ * Make a new or get existing pefs node.
+ * vp is the alias vnode
+ * lvp is the lower vnode
+ * ldvp is the lower directory vnode, used if no key specified
+ *
+ * The lvp assumed to be locked and having "spare" reference. This routine
+ * vrele lvp if pefs node was taken from hash. Otherwise it "transfers" the
+ * caller's "spare" reference to created pefs vnode.
+ */
+static int
+pefs_node_get(struct mount *mp, struct vnode *lvp, struct vnode **vpp,
+    pefs_node_init_fn *init_fn, void *context)
+{
+	struct pefs_node *pn;
+	struct vnode *vp;
+	int error;
+
+	ASSERT_VOP_LOCKED(lvp, "pefs_node_get");
+	/* Lookup the hash firstly */
+	*vpp = pefs_nodehash_get(mp, lvp);
+	if (*vpp != NULL) {
+		vrele(lvp);
+		return (0);
+	}
+
+	/*
+	 * We do not serialize vnode creation, instead we will check for
+	 * duplicates later, when adding new vnode to hash.
+	 *
+	 * Note that duplicate can only appear in hash if the lvp is
+	 * locked LK_SHARED.
+	 */
+
+	/*
+	 * Do the MALLOC before the getnewvnode since doing so afterward
+	 * might cause a bogus v_data pointer to get dereferenced
+	 * elsewhere if MALLOC should block.
+	 */
+	pn = uma_zalloc(pefs_node_zone, M_WAITOK | M_ZERO);
+	pn->pn_lowervp = lvp;
+
+	/* pn->pn_lowervp should be initialized before calling init_fn. */
+	error = init_fn(mp, pn, context);
+	MPASS(!(((pn->pn_flags & PN_HASKEY) == 0) ^
+	    (pn->pn_tkey.ptk_key == NULL)));
+	if (error != 0) {
+		uma_zfree(pefs_node_zone, pn);
+		return (error);
+	}
+
+	error = getnewvnode("pefs", mp, &pefs_vnodeops, &vp);
+	if (error != 0) {
+		pefs_key_release(pn->pn_tkey.ptk_key);
+		uma_zfree(pefs_node_zone, pn);
+		return (error);
+	}
+
+	if (pn->pn_tkey.ptk_key == NULL)
+		PEFSDEBUG("pefs_node_get: creating node without key: %p\n", pn);
+
+	pn->pn_vnode = vp;
+	vp->v_type = lvp->v_type;
+	vp->v_data = pn;
+	vp->v_vnlock = lvp->v_vnlock;
+	if (vp->v_vnlock == NULL)
+		panic("pefs_node_get: Passed a NULL vnlock.\n");
+	error = insmntque1(vp, mp, pefs_insmntque_dtr, pn);
+	if (error != 0)
+		return (error);
+	/*
+	 * Atomically insert our new node into the hash or vget existing
+	 * if someone else has beaten us to it.
+	 */
+	*vpp = pefs_nodehash_insert(mp, pn);
+	if (*vpp != NULL) {
+		vrele(lvp);
+		vp->v_vnlock = &vp->v_lock;
+		pn->pn_lowervp = NULL;
+		vrele(vp);
+		MPASS(PEFS_LOWERVP(*vpp) == lvp);
+		ASSERT_VOP_LOCKED(*vpp, "pefs_node_get: duplicate");
+		return (0);
+	}
+	if (vp->v_type == VDIR)
+		pn->pn_dircache = pefs_dircache_get();
+	*vpp = vp;
+	MPASS(PEFS_LOWERVP(*vpp) == lvp);
+	ASSERT_VOP_LOCKED(*vpp, "pefs_node_get");
+
+	return (0);
+}
+
+int
+pefs_node_get_nokey(struct mount *mp, struct vnode *lvp, struct vnode **vpp)
+{
+	return (pefs_node_get(mp, lvp, vpp, pefs_node_init_knownkey, NULL));
+}
+
+int
+pefs_node_get_haskey(struct mount *mp, struct vnode *lvp, struct vnode **vpp,
+    struct pefs_tkey *ptk)
+{
+	MPASS(ptk != NULL && ptk->ptk_key != NULL);
+	return (pefs_node_get(mp, lvp, vpp, pefs_node_init_knownkey, ptk));
+}
+
+/*
+ * Lookup vnode key using VOP_VPTOCNP.
+ * Directory vnode (ldvp) of lvp should not be locked.
+ * XXX will fail if ldvp is not active ???
+ */
+int
+pefs_node_get_lookupkey(struct mount *mp, struct vnode *lvp, struct vnode **vpp,
+    struct ucred *cred)
+{
+	MPASS(cred != NULL);
+	return (pefs_node_get(mp, lvp, vpp, pefs_node_init_lookupkey, cred));
+}
+
+static __inline void
+pefs_node_free(struct pefs_node *pn)
+{
+	struct vnode *lowervp;
+
+	lowervp = pn->pn_lowervp_dead;
+	uma_zfree(pefs_node_zone, pn);
+	if (lowervp != NULL) {
+#if __FreeBSD_version < 1000021
+		int vfslocked;
+		vfslocked = VFS_LOCK_GIANT(lowervp->v_mount);
+#endif
+		vrele(lowervp);
+#if __FreeBSD_version < 1000021
+		VFS_UNLOCK_GIANT(vfslocked);
+#endif
+	}
+}
+
+static void
+pefs_node_free_proc(void *context __unused, int pending __unused)
+{
+	struct pefs_node *pn;
+
+	while (1) {
+		mtx_lock(&pefs_node_listmtx);
+		pn = LIST_FIRST(&pefs_node_freelist);
+		if (pn == NULL) {
+			mtx_unlock(&pefs_node_listmtx);
+			break;
+		}
+		LIST_REMOVE(pn, pn_listentry);
+		mtx_unlock(&pefs_node_listmtx);
+		pefs_node_free(pn);
+	}
+}
+
+/*
+ * Remove node from hash and free it.
+ */
+void
+pefs_node_asyncfree(struct pefs_node *pn)
+{
+	int flags;
+
+	PEFSDEBUG("pefs_node_asyncfree: free node %p\n", pn);
+	pefs_key_release(pn->pn_tkey.ptk_key);
+	pefs_dircache_free(pn->pn_dircache);
+	mtx_lock(&pefs_node_listmtx);
+	pefs_nodes--;
+	LIST_REMOVE(pn, pn_listentry);
+	flags = VFS_TO_PEFS(PN_TO_VP(pn)->v_mount)->pm_flags;
+	/* XXX Find a better way to check for safe context */
+	if ((flags & PM_ASYNCRECLAIM) == 0 ||
+	    memcmp(curthread->td_name, "vnlru", 6) == 0) {
+		mtx_unlock(&pefs_node_listmtx);
+		pefs_node_free(pn);
+		return;
+	} else {
+		LIST_INSERT_HEAD(&pefs_node_freelist, pn, pn_listentry);
+		mtx_unlock(&pefs_node_listmtx);
+		taskqueue_enqueue(pefs_taskq, &pefs_task_freenode);
+	}
+}
+
+void
+pefs_node_buf_free(struct pefs_node *pn)
+{
+	void *bufs[2] = { NULL, NULL };
+	int ind = 0;
+
+	ASSERT_VI_UNLOCKED(pn->pn_vnode, "pefs_node_buf_free");
+	VI_LOCK(pn->pn_vnode);
+	if (pn->pn_buf_small != NULL &&
+	    (pn->pn_flags & PN_LOCKBUF_SMALL) == 0) {
+		bufs[ind++] = pn->pn_buf_small;
+		pn->pn_buf_small = NULL;
+	}
+	if (pn->pn_buf_large != NULL &&
+	    (pn->pn_flags & PN_LOCKBUF_LARGE) == 0) {
+		bufs[ind++] = pn->pn_buf_large;
+		pn->pn_buf_large = NULL;
+	}
+	VI_UNLOCK(pn->pn_vnode);
+	free(bufs[0], M_PEFSBUF);
+	free(bufs[1], M_PEFSBUF);
+}
+
+struct pefs_key*
+pefs_node_key(struct pefs_node *pn)
+{
+	struct pefs_key *pk;
+
+	if (pn->pn_flags & PN_HASKEY) {
+		MPASS(pn->pn_tkey.ptk_key != NULL);
+		pk = pn->pn_tkey.ptk_key;
+	} else {
+		MPASS(pn->pn_tkey.ptk_key == NULL);
+		pk = pefs_rootkey(VFS_TO_PEFS(pn->pn_vnode->v_mount));
+	}
+	MPASS(pk != NULL);
+	return (pefs_key_ref(pk));
+}
+
+void
+pefs_chunk_create(struct pefs_chunk *pc, struct pefs_node *pn, size_t size)
+{
+	size_t wantbufsize;
+	int nodebuf;
+	void **nodebuf_ptr;
+
+	if (size > DFLTPHYS)
+		panic("pefs_chunk_create: requested buffer is too large %zd",
+		    size);
+
+	nodebuf = 0;
+	wantbufsize = (size <= PEFS_SECTOR_SIZE ? PEFS_SECTOR_SIZE : DFLTPHYS);
+	if (pn != NULL) {
+		nodebuf = (size <= PEFS_SECTOR_SIZE ? PN_LOCKBUF_SMALL :
+		    PN_LOCKBUF_LARGE);
+		VI_LOCK(pn->pn_vnode);
+		if ((pn->pn_flags & nodebuf) == 0) {
+			pn->pn_flags |= nodebuf;
+			nodebuf_ptr = pefs_node_buf(pn, nodebuf);
+		} else if (nodebuf == PN_LOCKBUF_SMALL &&
+		    (pn->pn_flags & PN_LOCKBUF_LARGE) == 0)  {
+			nodebuf = PN_LOCKBUF_LARGE;
+			wantbufsize = DFLTPHYS;
+			pn->pn_flags |= nodebuf;
+			nodebuf_ptr = &pn->pn_buf_large;
+		} else
+			nodebuf = 0;
+		VI_UNLOCK(pn->pn_vnode);
+	}
+	if (nodebuf != 0) {
+		if (*nodebuf_ptr == NULL)
+			*nodebuf_ptr = malloc(wantbufsize, M_PEFSBUF, M_WAITOK);
+		pc->pc_nodebuf = nodebuf;
+		pc->pc_base = *nodebuf_ptr;
+	} else {
+		pc->pc_nodebuf = 0;
+		pc->pc_base = malloc(wantbufsize, M_PEFSBUF, M_WAITOK);
+	}
+	pc->pc_size = size;
+	pc->pc_capacity = pc->pc_size;
+	pc->pc_uio.uio_iovcnt = 1;
+	pc->pc_uio.uio_iov = &pc->pc_iov;
+}
+
+void
+pefs_chunk_restore(struct pefs_chunk* pc)
+{
+	pc->pc_size = pc->pc_capacity;
+	pc->pc_iov.iov_base = pc->pc_base;
+	pc->pc_iov.iov_len = pc->pc_size;
+}
+
+void
+pefs_chunk_free(struct pefs_chunk* pc, struct pefs_node *pn)
+{
+	if (pc->pc_nodebuf != 0) {
+		MPASS(pn != NULL);
+		MPASS(pc->pc_base == *pefs_node_buf(pn, pc->pc_nodebuf));
+		VI_LOCK(pn->pn_vnode);
+		pn->pn_flags &= ~(pc->pc_nodebuf);
+		VI_UNLOCK(pn->pn_vnode);
+	} else
+		free(pc->pc_base, M_PEFSBUF);
+	pc->pc_nodebuf = 0;
+	pc->pc_base = NULL;
+}
+
+struct uio*
+pefs_chunk_uio(struct pefs_chunk *pc, off_t uio_offset, enum uio_rw uio_rw)
+{
+	pc->pc_iov.iov_base = pc->pc_base;
+	pc->pc_iov.iov_len = pc->pc_size;
+
+	pc->pc_uio.uio_offset = uio_offset;
+	pc->pc_uio.uio_resid = pc->pc_size;
+	pc->pc_uio.uio_rw = uio_rw;
+	pc->pc_uio.uio_segflg = UIO_SYSSPACE;
+	pc->pc_uio.uio_td = curthread;
+
+	return (&pc->pc_uio);
+}
+
+void
+pefs_chunk_zero(struct pefs_chunk *pc)
+{
+	bzero(pc->pc_base, pc->pc_size);
+}
+
+int
+pefs_chunk_copy(struct pefs_chunk *pc, size_t skip, struct uio *uio)
+{
+	int error;
+
+	MPASS(skip < pc->pc_size);
+	error = uiomove((char *)pc->pc_base + skip,
+	    qmin(pc->pc_size - skip, uio->uio_resid), uio);
+
+	return (error);
+}
+
+void
+pefs_chunk_setsize(struct pefs_chunk *pc, size_t size)
+{
+	MPASS(size <= pc->pc_capacity);
+	pc->pc_size = size;
+}
+
+#ifdef DIAGNOSTIC
+struct vnode *
+pefs_checkvp(struct vnode *vp, char *fil, int lno)
+{
+	int interlock = 0;
+	struct pefs_node *a = VP_TO_PN(vp);
+	if (a->pn_lowervp == NULLVP) {
+		/* Should never happen */
+		int i; u_long *p;
+		printf("vp = %p, ZERO ptr\n", (void *)vp);
+		for (p = (u_long *) a, i = 0; i < 8; i++)
+			printf(" %lx", p[i]);
+		printf("\n");
+		panic("pefs_checkvp");
+	}
+	if (mtx_owned(VI_MTX(vp)) != 0) {
+		VI_UNLOCK(vp);
+		interlock = 1;
+	}
+	if (vrefcnt(a->pn_lowervp) < 1) {
+		int i; u_long *p;
+		printf("vp = %p, unref'ed lowervp\n", (void *)vp);
+		for (p = (u_long *) a, i = 0; i < 8; i++)
+			printf(" %lx", p[i]);
+		printf("\n");
+		panic ("null with unref'ed lowervp");
+	};
+	if (interlock != 0)
+		VI_LOCK(vp);
+	return (a->pn_lowervp);
+}
+#endif /* DIAGNOSTIC */
diff --git sys/fs/pefs/pefs_vfsops.c sys/fs/pefs/pefs_vfsops.c
new file mode 100644
index 0000000..4873190
--- /dev/null
+++ sys/fs/pefs/pefs_vfsops.c
@@ -0,0 +1,465 @@
+/*-
+ * Copyright (c) 1992, 1993, 1995
+ *	The Regents of the University of California.  All rights reserved.
+ * Copyright (c) 2009 Gleb Kurtsou <gleb@FreeBSD.org>
+ *
+ * This code is derived from software donated to Berkeley by
+ * Jan-Simon Pendry.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/fcntl.h>
+#include <sys/kernel.h>
+#include <sys/lock.h>
+#include <sys/malloc.h>
+#include <sys/mount.h>
+#include <sys/namei.h>
+#include <sys/proc.h>
+#include <sys/vnode.h>
+
+#include <fs/pefs/pefs.h>
+
+struct pefs_opt_descr {
+	char	*fs;
+	int	initial;
+	int	forbid;
+};
+
+static const struct pefs_opt_descr pefs_opt_support[] = {
+	{
+		.fs = "zfs",
+#if __FreeBSD_version >= 1000025
+		.initial = PM_DIRCACHE,
+#else
+		.initial = PM_DIRCACHE | PM_ASYNCRECLAIM,
+#endif
+		.forbid = 0
+	},
+	{	/* default flags */
+		.fs = NULL,
+		.initial = 0,
+		.forbid = PM_DIRCACHE,
+	}
+};
+
+static const char		*pefs_opts[] = {
+	"from",
+	"export",
+	"dircache",
+	"nodircache",
+	"asyncreclaim",
+	NULL
+};
+
+static MALLOC_DEFINE(M_PEFSMNT, "pefs_mount", "PEFS mount structure");
+
+static void
+pefs_opt_set(struct mount *mp, int opt, struct pefs_mount *pm,
+    int flag, const char *flagname)
+{
+	const struct pefs_opt_descr *descr;
+	char *lowerfs;
+
+	lowerfs = mp->mnt_vnodecovered->v_mount->mnt_vfc->vfc_name;
+	for (descr = pefs_opt_support; descr->fs != NULL; descr++)
+		if (strcmp(lowerfs, descr->fs) == 0)
+			break;
+	if (opt < 0)
+		opt = descr->initial & flag;
+	else if (opt > 0 && (descr->forbid & flag) != 0) {
+		printf("pefs: %s is not supported by file system: %s\n",
+		    flagname, lowerfs);
+		opt = 0;
+	}
+
+	if (opt == 0)
+		pm->pm_flags &= ~flag;
+	else
+		pm->pm_flags |= flag;
+	PEFSDEBUG("pefs_mount: %s %s\n",
+	    flagname, (opt ? "enabled" : "disabed"));
+}
+
+static int
+subdir(const char *p, const char *dir)
+{
+	int l;
+
+	l = strlen(dir);
+	if (l <= 1)
+		return (1);
+
+	if ((strncmp(p, dir, l) == 0) && (p[l] == '/' || p[l] == '\0'))
+		return (1);
+
+	return (0);
+}
+
+/*
+ * Mount null layer
+ */
+static int
+pefs_mount(struct mount *mp)
+{
+	struct vnode *lowerrootvp, *vp;
+	struct vnode *pm_rootvp;
+	struct nameidata nd, *ndp = &nd;
+	struct pefs_mount *pm;
+	char *from, *from_free;
+	int isvnunlocked = 0, len;
+	int opt_dircache, opt_asyncreclaim;
+	int error = 0;
+
+	PEFSDEBUG("pefs_mount(mp = %p)\n", (void *)mp);
+
+	if (mp->mnt_flag & MNT_ROOTFS)
+		return (EOPNOTSUPP);
+
+	if (vfs_filteropt(mp->mnt_optnew, pefs_opts))
+		return (EINVAL);
+
+	opt_dircache = -1;
+	if (vfs_flagopt(mp->mnt_optnew, "dircache", NULL, 0)) {
+		vfs_deleteopt(mp->mnt_optnew, "dircache");
+		opt_dircache = 1;
+	} else if (vfs_flagopt(mp->mnt_optnew, "nodircache", NULL, 0)) {
+		vfs_deleteopt(mp->mnt_optnew, "nodircache");
+		opt_dircache = 0;
+	}
+	opt_asyncreclaim = -1;
+	if (vfs_flagopt(mp->mnt_optnew, "asyncreclaim", NULL, 0)) {
+		vfs_deleteopt(mp->mnt_optnew, "asyncreclaim");
+		opt_asyncreclaim = 1;
+	}
+
+	if (mp->mnt_flag & MNT_UPDATE) {
+		error = EOPNOTSUPP;
+		if (vfs_flagopt(mp->mnt_optnew, "export", NULL, 0))
+			error = 0;
+		if (opt_dircache >= 0) {
+			pefs_opt_set(mp, opt_dircache, mp->mnt_data,
+			    PM_DIRCACHE, "dircache");
+			error = 0;
+		}
+		if (opt_asyncreclaim >= 0) {
+			pefs_opt_set(mp, opt_dircache, mp->mnt_data,
+			    PM_ASYNCRECLAIM, "asyncreclaim");
+			error = 0;
+		}
+		return (error);
+	}
+
+	/*
+	 * Get argument
+	 */
+	error = vfs_getopt(mp->mnt_optnew, "from", (void **)&from, &len);
+	if (error || from[len - 1] != '\0')
+		return (EINVAL);
+	vfs_mountedfrom(mp, from);
+
+	/*
+	 * Unlock lower node to avoid deadlock.
+	 * (XXX) VOP_ISLOCKED is needed?
+	 */
+	if ((mp->mnt_vnodecovered->v_op == &pefs_vnodeops) &&
+		VOP_ISLOCKED(mp->mnt_vnodecovered)) {
+		VOP_UNLOCK(mp->mnt_vnodecovered, 0);
+		isvnunlocked = 1;
+	}
+	/*
+	 * Find lower node
+	 */
+	NDINIT(ndp, LOOKUP, FOLLOW, UIO_SYSSPACE, from, curthread);
+	error = namei(ndp);
+
+	if (error == 0) {
+		from_free = NULL;
+		error = vn_fullpath(curthread, ndp->ni_vp, &from,
+		    &from_free);
+		if (error == 0)
+			vfs_mountedfrom(mp, from);
+		else
+			error = 0;
+		free(from_free, M_TEMP);
+	}
+	/*
+	 * Re-lock vnode.
+	 */
+	if (isvnunlocked && !VOP_ISLOCKED(mp->mnt_vnodecovered))
+		vn_lock(mp->mnt_vnodecovered, LK_EXCLUSIVE | LK_RETRY);
+
+	if (error != 0)
+		return (error);
+	NDFREE(ndp, NDF_ONLY_PNBUF);
+
+	/*
+	 * Sanity check on lower vnode
+	 */
+	lowerrootvp = ndp->ni_vp;
+	vn_lock(lowerrootvp, LK_EXCLUSIVE | LK_RETRY);
+	if ((lowerrootvp->v_iflag & VI_DOOMED) != 0) {
+		PEFSDEBUG("pefs_mount: target vnode disappeared\n");
+		vput(lowerrootvp);
+		return (ENOENT);
+	}
+
+	/*
+	 * Check multi pefs mount to avoid `lock against myself' panic.
+	 */
+	if (lowerrootvp->v_mount->mnt_vfc == mp->mnt_vfc) {
+		PEFSDEBUG("pefs_mount: multi pefs mount\n");
+		vput(lowerrootvp);
+		return (EDEADLK);
+	}
+
+	/*
+	 * Check paths are not nested
+	 */
+	if ((lowerrootvp != mp->mnt_vnodecovered) &&
+	    (subdir(mp->mnt_stat.f_mntfromname, mp->mnt_stat.f_mntonname) ||
+	    subdir(mp->mnt_stat.f_mntonname, mp->mnt_stat.f_mntfromname))) {
+		PEFSDEBUG("pefs_mount: %s and %s are nested paths\n",
+		    mp->mnt_stat.f_mntfromname, mp->mnt_stat.f_mntonname);
+		vput(lowerrootvp);
+		return (EDEADLK);
+	}
+
+	pm = (struct pefs_mount *)malloc(sizeof(struct pefs_mount), M_PEFSMNT,
+	    M_WAITOK | M_ZERO);
+
+	mtx_init(&pm->pm_keys_lock, "pefs_mount lock", NULL, MTX_DEF);
+	TAILQ_INIT(&pm->pm_keys);
+
+	/*
+	 * Save reference to underlying FS
+	 */
+	pm->pm_lowervfs = lowerrootvp->v_mount;
+	if (lowerrootvp == mp->mnt_vnodecovered)
+		pm->pm_flags |= PM_ROOT_CANRECURSE;
+	pefs_opt_set(mp, opt_dircache, pm, PM_DIRCACHE, "dircache");
+	pefs_opt_set(mp, opt_asyncreclaim, pm, PM_ASYNCRECLAIM, "asyncreclaim");
+
+	/*
+	 * Save reference.  Each mount also holds
+	 * a reference on the root vnode.
+	 */
+	vp = NULL;
+	error = pefs_node_get_nokey(mp, lowerrootvp, &vp);
+	/*
+	 * Make sure the node alias worked
+	 */
+	if (error != 0) {
+		vput(lowerrootvp);
+		free(pm, M_PEFSMNT);
+		return (error);
+	}
+
+	/*
+	 * Keep a held reference to the root vnode.
+	 * It is vrele'd in pefs_unmount.
+	 */
+	pm_rootvp = vp;
+	pm_rootvp->v_vflag |= VV_ROOT;
+	pm->pm_rootvp = pm_rootvp;
+
+	/*
+	 * Unlock the node (either the lower or the alias)
+	 */
+	VOP_UNLOCK(vp, 0);
+
+	if (PEFS_LOWERVP(pm_rootvp)->v_mount->mnt_flag & MNT_LOCAL) {
+		MNT_ILOCK(mp);
+		mp->mnt_flag |= MNT_LOCAL;
+		MNT_IUNLOCK(mp);
+	}
+#if __FreeBSD_version < 1000021
+	MNT_ILOCK(mp);
+	mp->mnt_kern_flag |= lowerrootvp->v_mount->mnt_kern_flag & MNTK_MPSAFE;
+	MNT_IUNLOCK(mp);
+#endif
+	mp->mnt_data =  pm;
+	vfs_getnewfsid(mp);
+
+	PEFSDEBUG("pefs_mount: lower %s, alias at %s\n",
+		mp->mnt_stat.f_mntfromname, mp->mnt_stat.f_mntonname);
+	return (0);
+}
+
+/*
+ * Free reference to null layer
+ */
+static int
+pefs_unmount(struct mount *mp, int mntflags)
+{
+	struct pefs_mount *pm;
+	int error;
+	int flags = 0;
+
+	PEFSDEBUG("pefs_unmount: mp = %p\n", (void *)mp);
+
+	if (mntflags & MNT_FORCE)
+		flags |= FORCECLOSE;
+
+	/* There is 1 extra root vnode reference (pm_rootvp). */
+	error = vflush(mp, 1, flags, curthread);
+	if (error != 0)
+		return (error);
+
+	/*
+	 * Finally, throw away the pefs_mount structure
+	 */
+	pm = VFS_TO_PEFS(mp);
+	mp->mnt_data = 0;
+	pefs_key_remove_all(pm);
+	mtx_destroy(&pm->pm_keys_lock);
+	free(pm, M_PEFSMNT);
+	return (0);
+}
+
+static int
+pefs_root(struct mount *mp, int flags, struct vnode **vpp)
+{
+	struct vnode *vp;
+
+	/*
+	 * Return locked reference to root.
+	 */
+	vp = VFS_TO_PEFS(mp)->pm_rootvp;
+	VREF(vp);
+
+	vn_lock(vp, flags | LK_RETRY);
+	*vpp = vp;
+	return (0);
+}
+
+static int
+pefs_quotactl(struct mount *mp, int cmd, uid_t uid, void *arg)
+{
+	return (VFS_QUOTACTL(VFS_TO_PEFS(mp)->pm_lowervfs, cmd, uid, arg));
+}
+
+static int
+pefs_statfs(struct mount *mp, struct statfs *sbp)
+{
+	int error;
+	struct statfs mstat;
+
+	bzero(&mstat, sizeof(mstat));
+
+	error = VFS_STATFS(VFS_TO_PEFS(mp)->pm_lowervfs, &mstat);
+	if (error != 0)
+		return (error);
+
+	/* now copy across the "interesting" information and fake the rest */
+	sbp->f_type = mstat.f_type;
+	sbp->f_flags = mstat.f_flags;
+	sbp->f_bsize = mstat.f_bsize;
+	sbp->f_iosize = mstat.f_iosize;
+	sbp->f_blocks = mstat.f_blocks;
+	sbp->f_bfree = mstat.f_bfree;
+	sbp->f_bavail = mstat.f_bavail;
+	sbp->f_files = mstat.f_files;
+	sbp->f_ffree = mstat.f_ffree;
+	return (0);
+}
+
+static int
+pefs_sync(struct mount *mp, int waitfor)
+{
+	/*
+	 * XXX - Assumes no data cached at null layer.
+	 */
+	return (0);
+}
+
+static int
+pefs_vget(struct mount *mp, ino_t ino, int flags, struct vnode **vpp)
+{
+	int error;
+	error = VFS_VGET(VFS_TO_PEFS(mp)->pm_lowervfs, ino, flags, vpp);
+	if (error != 0)
+		return (error);
+
+	return (pefs_node_get_lookupkey(mp, *vpp, vpp, curthread->td_ucred));
+}
+
+static int
+#if __FreeBSD_version >= 900038
+pefs_fhtovp(struct mount *mp, struct fid *fidp, int flags, struct vnode **vpp)
+#else
+pefs_fhtovp(struct mount *mp, struct fid *fidp, struct vnode **vpp)
+#endif
+{
+	int error;
+
+#if __FreeBSD_version >= 900038
+	error = VFS_FHTOVP(VFS_TO_PEFS(mp)->pm_lowervfs, fidp, flags, vpp);
+#else
+	error = VFS_FHTOVP(VFS_TO_PEFS(mp)->pm_lowervfs, fidp, vpp);
+#endif /* __FreeBSD_version */
+	if (error != 0)
+		return (error);
+
+	error = pefs_node_get_lookupkey(mp, *vpp, vpp, curthread->td_ucred);
+	if (error != 0)
+		return (error);
+	vnode_create_vobject(*vpp, 0, curthread);
+	return (error);
+}
+
+static int
+pefs_extattrctl(struct mount *mp, int cmd, struct vnode *filename_vp,
+    int namespace, const char *attrname)
+{
+	return (VFS_EXTATTRCTL(VFS_TO_PEFS(mp)->pm_lowervfs, cmd, filename_vp,
+	    namespace, attrname));
+}
+
+
+static struct vfsops pefs_vfsops = {
+	.vfs_extattrctl =	pefs_extattrctl,
+	.vfs_fhtovp =		pefs_fhtovp,
+	.vfs_init =		pefs_init,
+	.vfs_mount =		pefs_mount,
+	.vfs_quotactl =		pefs_quotactl,
+	.vfs_root =		pefs_root,
+	.vfs_statfs =		pefs_statfs,
+	.vfs_sync =		pefs_sync,
+	.vfs_uninit =		pefs_uninit,
+	.vfs_unmount =		pefs_unmount,
+	.vfs_vget =		pefs_vget,
+};
+
+VFS_SET(pefs_vfsops, pefs, VFCF_LOOPBACK);
+MODULE_DEPEND(pefs, crypto, 1, 1, 1);
+#ifdef PEFS_AESNI
+MODULE_DEPEND(pefs, aesni, 1, 1, 1);
+#endif
diff --git sys/fs/pefs/pefs_vnops.c sys/fs/pefs/pefs_vnops.c
new file mode 100644
index 0000000..523eef9
--- /dev/null
+++ sys/fs/pefs/pefs_vnops.c
@@ -0,0 +1,2674 @@
+/*-
+ * Copyright (c) 1992, 1993 The Regents of the University of California.
+ * Copyright (c) 2009 Gleb Kurtsou <gleb@FreeBSD.org>
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * John Heidemann of the UCLA Ficus project.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/conf.h>
+#include <sys/ioccom.h>
+#include <sys/fcntl.h>
+#include <sys/kernel.h>
+#include <sys/lock.h>
+#include <sys/malloc.h>
+#include <sys/mount.h>
+#include <sys/mutex.h>
+#include <sys/namei.h>
+#include <sys/priv.h>
+#include <sys/rwlock.h>
+#include <sys/sf_buf.h>
+#include <sys/stat.h>
+#include <sys/sysctl.h>
+#include <sys/sx.h>
+#include <sys/vnode.h>
+#include <sys/dirent.h>
+#include <sys/limits.h>
+#include <sys/proc.h>
+#include <sys/sched.h>
+#include <sys/unistd.h>
+#include <vm/vm.h>
+#include <vm/vm_extern.h>
+#include <vm/vm_object.h>
+#include <vm/vm_page.h>
+#include <vm/vm_pager.h>
+#include <vm/vnode_pager.h>
+
+#include <fs/pefs/pefs.h>
+#include <fs/pefs/pefs_dircache.h>
+
+#define	DIRENT_MINSIZE		(sizeof(struct dirent) - (MAXNAMLEN + 1))
+#define	DIRENT_MAXSIZE		(sizeof(struct dirent))
+
+CTASSERT(PEFS_SECTOR_SIZE == PAGE_SIZE);
+
+struct pefs_enccn {
+	struct componentname	pec_cn;
+	void			*pec_buf;
+	struct pefs_tkey	pec_tkey;
+};
+
+static int	pefs_read_int(struct vnode *vp, struct uio *uio, int ioflag,
+		    struct ucred *cred, u_quad_t fsize);
+static int	pefs_write_int(struct vnode *vp, struct uio *uio, int ioflag,
+		    struct ucred *cred, u_quad_t nsize);
+
+static __inline u_long
+pefs_getgen(struct vnode *vp, struct ucred *cred)
+{
+	struct vattr va;
+	int error;
+
+	error = VOP_GETATTR(PEFS_LOWERVP(vp), &va, cred);
+	if (error != 0)
+		return (0);
+
+	return (va.va_gen);
+}
+
+static __inline int
+pefs_tkey_cmp(struct pefs_tkey *a, struct pefs_tkey *b)
+{
+	int r;
+
+	r = (intptr_t)a->ptk_key - (intptr_t)b->ptk_key;
+	if (r == 0)
+		r = memcmp(a->ptk_tweak, b->ptk_tweak, PEFS_TWEAK_SIZE);
+
+	return (r);
+}
+
+static __inline int
+pefs_cache_active(struct vnode *vp)
+{
+	struct pefs_mount *pm = VFS_TO_PEFS(vp->v_mount);
+
+	return (pefs_dircache_enable &&
+	    (pm->pm_flags & PM_DIRCACHE) != 0);
+}
+
+static struct pefs_dircache_entry *
+pefs_cache_dirent(struct pefs_dircache *pd, struct dirent *de,
+    struct pefs_ctx *ctx, struct pefs_key *pk)
+{
+	struct pefs_dircache_entry *cache;
+	struct pefs_tkey ptk;
+	char buf[MAXNAMLEN + 1];
+	int name_len;
+
+	cache = pefs_dircache_enclookup(pd, de->d_name, de->d_namlen);
+	if (cache != NULL)
+		pefs_dircache_update(cache);
+	else {
+		name_len = pefs_name_decrypt(ctx, pk, &ptk,
+		    de->d_name, de->d_namlen, buf, sizeof(buf));
+		if (name_len <= 0)
+			return (NULL);
+		cache = pefs_dircache_insert(pd, &ptk,
+		    buf, name_len, de->d_name, de->d_namlen);
+	}
+
+	return (cache);
+}
+
+static __inline int
+pefs_name_skip(char *name, int namelen)
+{
+	if (name[0] == '.' &&
+	    (namelen == 1 || (namelen == 2 && name[1] == '.')))
+		return (1);
+	return (0);
+}
+
+static __inline void
+pefs_enccn_init(struct pefs_enccn *pec)
+{
+	pec->pec_buf = NULL;
+	pec->pec_cn.cn_flags = 0;
+}
+
+static __inline void
+pefs_enccn_alloc(struct pefs_enccn *pec, struct componentname *cnp)
+{
+	KASSERT(pec->pec_buf == NULL, ("pefs_enccn_alloc: buffer reuse\n"));
+	pec->pec_buf = uma_zalloc(namei_zone, M_WAITOK);
+	pec->pec_cn = *cnp;
+	pec->pec_cn.cn_flags |= HASBUF;
+	pec->pec_cn.cn_pnbuf = pec->pec_buf;
+	pec->pec_cn.cn_nameptr = pec->pec_buf;
+	pec->pec_cn.cn_consume = 0;
+	pec->pec_cn.cn_namelen = 0;
+}
+
+static __inline void
+pefs_enccn_free(struct pefs_enccn *pec)
+{
+	if (pec->pec_buf != NULL) {
+		KASSERT(pec->pec_buf == pec->pec_cn.cn_pnbuf &&
+		    pec->pec_buf == pec->pec_cn.cn_nameptr,
+		    ("pefs_enccn_free: invalid buffer\n"));
+		KASSERT(pec->pec_cn.cn_flags & HASBUF,
+		    ("pefs_enccn_free: buffer is already freed\n"));
+		uma_zfree(namei_zone, pec->pec_buf);
+		pec->pec_buf = NULL;
+		pec->pec_cn.cn_flags = 0;
+		pec->pec_cn.cn_pnbuf = NULL;
+		pec->pec_cn.cn_nameptr = NULL;
+	}
+}
+
+static void
+pefs_enccn_set(struct pefs_enccn *pec, struct pefs_tkey *ptk, char *encname,
+    int encname_len, struct componentname *cnp)
+{
+	MPASS(pec != NULL && cnp != NULL);
+
+	if (encname_len >= MAXPATHLEN)
+		panic("pefs_enccn_set: invalid encrypted name length: %d",
+		    encname_len);
+
+	pefs_enccn_alloc(pec, cnp);
+	if (ptk != NULL && ptk->ptk_key != NULL)
+		pec->pec_tkey = *ptk;
+	else
+		pec->pec_tkey.ptk_key = NULL;
+	memcpy(pec->pec_buf, encname, encname_len);
+	((char *) pec->pec_buf)[encname_len] = '\0';
+	pec->pec_cn.cn_namelen = encname_len;
+}
+
+static int
+pefs_enccn_create(struct pefs_enccn *pec, struct pefs_key *pk, char *tweak,
+    struct componentname *cnp)
+{
+	int r;
+
+	MPASS(pec != NULL && cnp != NULL && pk != NULL);
+	MPASS((cnp->cn_flags & ISDOTDOT) == 0);
+	MPASS(pefs_name_skip(cnp->cn_nameptr, cnp->cn_namelen) == 0);
+
+	pefs_enccn_alloc(pec, cnp);
+	if (tweak == NULL)
+		arc4rand(pec->pec_tkey.ptk_tweak, PEFS_TWEAK_SIZE, 0);
+	else
+		memcpy(pec->pec_tkey.ptk_tweak, tweak, PEFS_TWEAK_SIZE);
+	pec->pec_tkey.ptk_key = pk;
+	r = pefs_name_encrypt(NULL, &pec->pec_tkey, cnp->cn_nameptr,
+	    cnp->cn_namelen, pec->pec_buf, MAXPATHLEN);
+	if (r <= 0) {
+		pefs_enccn_free(pec);
+		if (r == 0)
+			return (EINVAL);
+		return (-r);
+	}
+	pec->pec_cn.cn_namelen = r;
+
+	return (0);
+}
+
+static int
+pefs_enccn_create_node(struct pefs_enccn *pec, struct vnode *dvp,
+    struct componentname *cnp)
+{
+	struct pefs_key *dpk;
+	int error;
+
+	dpk = pefs_node_key(VP_TO_PN(dvp));
+	error = pefs_enccn_create(pec, dpk, NULL, cnp);
+	pefs_key_release(dpk);
+
+	return (error);
+}
+
+static void
+pefs_enccn_parsedir(struct pefs_dircache *pd, struct pefs_ctx *ctx,
+    struct pefs_key *pk, void *mem, size_t sz, char *name, size_t name_len,
+    struct pefs_dircache_entry **retval)
+{
+	struct pefs_dircache_entry *cache;
+	struct dirent *de;
+
+	PEFSDEBUG("pefs_enccn_parsedir: lookup %.*s\n", (int)name_len, name);
+	cache = NULL;
+	for (de = (struct dirent*) mem; sz > DIRENT_MINSIZE;
+			sz -= de->d_reclen,
+			de = (struct dirent *)(((caddr_t)de) + de->d_reclen)) {
+		MPASS(de->d_reclen <= sz);
+		if (de->d_reclen == 0)
+			break;
+		if (de->d_type == DT_WHT || de->d_fileno == 0)
+			continue;
+		if (pefs_name_skip(de->d_name, de->d_namlen))
+			continue;
+
+		cache = pefs_cache_dirent(pd, de, ctx, pk);
+		if (cache != NULL && *retval == NULL &&
+		    cache->pde_namelen == name_len &&
+		    memcmp(name, cache->pde_name, name_len) == 0) {
+			*retval = cache;
+		}
+	}
+}
+
+static int
+pefs_enccn_lookup(struct pefs_enccn *pec, struct vnode *dvp,
+    struct componentname *cnp)
+{
+	struct uio *uio;
+	struct vnode *ldvp = PEFS_LOWERVP(dvp);
+	struct pefs_node *dpn = VP_TO_PN(dvp);
+	struct pefs_chunk pc;
+	struct pefs_ctx *ctx;
+	struct pefs_dircache_entry *cache;
+	struct pefs_key *dpn_key;
+	off_t offset;
+	u_long dgen;
+	int eofflag, error;
+
+	MPASS(pec != NULL && dvp != NULL && cnp != NULL);
+
+	if ((cnp->cn_flags & ISDOTDOT) ||
+	    pefs_name_skip(cnp->cn_nameptr, cnp->cn_namelen)) {
+		pefs_enccn_set(pec, NULL, cnp->cn_nameptr, cnp->cn_namelen,
+		    cnp);
+		return (0);
+	}
+
+	PEFSDEBUG("pefs_enccn_lookup: name=%.*s op=%d\n",
+	    (int)cnp->cn_namelen, cnp->cn_nameptr, (int) cnp->cn_nameiop);
+
+	error = 0;
+	dgen = pefs_getgen(dvp, cnp->cn_cred);
+	pefs_dircache_lock(dpn->pn_dircache);
+	if (pefs_cache_active(dvp) &&
+	    pefs_dircache_valid(dpn->pn_dircache, dgen)) {
+		cache = pefs_dircache_lookup(dpn->pn_dircache,
+		    cnp->cn_nameptr, cnp->cn_namelen);
+		goto out;
+	}
+
+	offset = 0;
+	eofflag = 0;
+	cache = NULL;
+	ctx = pefs_ctx_get();
+	pefs_chunk_create(&pc, dpn, PEFS_SECTOR_SIZE);
+	dpn_key = pefs_node_key(dpn);
+	pefs_dircache_beginupdate(dpn->pn_dircache, dgen);
+	while (!eofflag) {
+		uio = pefs_chunk_uio(&pc, offset, UIO_READ);
+		error = VOP_READDIR(ldvp, uio, cnp->cn_cred, &eofflag,
+		    NULL, NULL);
+		if (error != 0)
+			break;
+		offset = uio->uio_offset;
+
+		if (pc.pc_size == uio->uio_resid)
+			break;
+		pefs_chunk_setsize(&pc, pc.pc_size - uio->uio_resid);
+		pefs_enccn_parsedir(dpn->pn_dircache, ctx, dpn_key,
+		    pc.pc_base, pc.pc_size, cnp->cn_nameptr, cnp->cn_namelen,
+		    &cache);
+		pefs_chunk_restore(&pc);
+	}
+	pefs_dircache_endupdate(dpn->pn_dircache);
+
+	pefs_ctx_free(ctx);
+	pefs_key_release(dpn_key);
+	pefs_chunk_free(&pc, dpn);
+out:
+	if (cache != NULL && error == 0)
+		pefs_enccn_set(pec, &cache->pde_tkey,
+		    cache->pde_encname, cache->pde_encnamelen, cnp);
+	else if (cache == NULL && error == 0)
+		error = ENOENT;
+
+	pefs_dircache_unlock(dpn->pn_dircache);
+
+	return (error);
+}
+
+static int
+pefs_enccn_get(struct pefs_enccn *pec, struct vnode *dvp, struct vnode *vp,
+    struct componentname *cnp)
+{
+	struct pefs_node *dpn = VP_TO_PN(dvp);
+	struct pefs_node *pn = VP_TO_PN(vp);
+	struct pefs_dircache_entry *cache;
+	int error;
+
+	if ((pn->pn_flags & PN_HASKEY) == 0) {
+		pefs_enccn_set(pec, NULL, cnp->cn_nameptr, cnp->cn_namelen,
+		    cnp);
+		return (0);
+	}
+
+	if (pefs_cache_active(dvp)) {
+		pefs_dircache_lock(dpn->pn_dircache);
+		/* Do not check if cache valid check keys are equal instead */
+		cache = pefs_dircache_lookup(dpn->pn_dircache,
+		    cnp->cn_nameptr, cnp->cn_namelen);
+		if (cache != NULL &&
+		    pefs_tkey_cmp(&cache->pde_tkey, &pn->pn_tkey) == 0) {
+			pefs_enccn_set(pec, &pn->pn_tkey,
+			    cache->pde_encname, cache->pde_encnamelen, cnp);
+			pefs_dircache_unlock(dpn->pn_dircache);
+			return (0);
+		}
+		pefs_dircache_unlock(dpn->pn_dircache);
+	}
+
+	error = pefs_enccn_create(pec, pn->pn_tkey.ptk_key,
+	    pn->pn_tkey.ptk_tweak, cnp);
+	PEFSDEBUG("pefs_enccn_get: create: %s -> %s\n",
+	    cnp->cn_nameptr, pec->pec_cn.cn_nameptr);
+	return (error);
+}
+
+#ifdef PEFS_DEBUG_EXTRA
+static void
+__pefs_enccn_assert_noent(struct vnode *dvp, struct componentname *cnp,
+    const char *file, int line)
+{
+	struct pefs_enccn enccn;
+	int error;
+
+	pefs_enccn_init(&enccn);
+	error = pefs_enccn_lookup(&enccn, dvp, cnp);
+
+	if (error != ENOENT)
+		panic("pefs_enccn assertion failed: %s:%d: "
+		    "unexpected error %d: %*s\n",
+		    file, line, error, (int)cnp->cn_namelen, cnp->cn_nameptr);
+	pefs_enccn_free(&enccn);
+}
+
+#define	PEFS_ENCCN_ASSERT_NOENT(dvp, cnp)	\
+		__pefs_enccn_assert_noent((dvp), (cnp), __FILE__, __LINE__);
+#else
+#define	PEFS_ENCCN_ASSERT_NOENT(dvp, cnp)	\
+		do { } while(0)
+#endif /* PEFS_DEBUG_EXTRA */
+
+#define	PEFS_FLUSHKEY_ALL		1
+
+/*
+ * Recycle vnodes with key pk.
+ *
+ * pk == NULL => recycle vnodes without key
+ * flags & PEFS_FLUSHKEY_ALL => recycle all vnodes with key
+ */
+static int
+pefs_flushkey(struct mount *mp, struct thread *td, int flags,
+    struct pefs_key *pk)
+{
+	struct vnode *vp, *rootvp, *mvp;
+	struct pefs_node *pn;
+	int error;
+
+	vflush(mp, 0, 0, td);
+	rootvp = VFS_TO_PEFS(mp)->pm_rootvp;
+#if __FreeBSD_version >= 1000025
+loop:
+	MNT_VNODE_FOREACH_ACTIVE(vp, mp, mvp) {
+		if ((vp->v_type != VREG && vp->v_type != VDIR) ||
+		    vp == rootvp) {
+			VI_UNLOCK(vp);
+			continue;
+		}
+		error = vget(vp, LK_EXCLUSIVE | LK_INTERLOCK, td);
+		if (error != 0) {
+			if (error == ENOENT) {
+				MNT_VNODE_FOREACH_ACTIVE_ABORT(mp, mvp);
+				goto loop;
+			}
+			continue;
+		}
+		pn = VP_TO_PN(vp);
+		if (((pn->pn_flags & PN_HASKEY) != 0 &&
+		    ((flags & PEFS_FLUSHKEY_ALL) != 0 ||
+		    pn->pn_tkey.ptk_key == pk)) ||
+		    ((pn->pn_flags & PN_HASKEY) == 0 && pk == NULL)) {
+			vgone(vp);
+		}
+		vput(vp);
+	}
+#else
+	MNT_ILOCK(mp);
+loop:
+	MNT_VNODE_FOREACH(vp, mp, mvp) {
+		if ((vp->v_type != VREG && vp->v_type != VDIR) || vp == rootvp)
+			continue;
+		VI_LOCK(vp);
+		pn = VP_TO_PN(vp);
+		if (((pn->pn_flags & PN_HASKEY) &&
+		    ((flags & PEFS_FLUSHKEY_ALL) ||
+		    pn->pn_tkey.ptk_key == pk)) ||
+		    ((pn->pn_flags & PN_HASKEY) == 0 && pk == NULL)) {
+			vholdl(vp);
+			MNT_IUNLOCK(mp);
+			error = vn_lock(vp, LK_INTERLOCK | LK_EXCLUSIVE);
+			if (error != 0) {
+				vdrop(vp);
+				MNT_ILOCK(mp);
+				MNT_VNODE_FOREACH_ABORT_ILOCKED(mp, mvp);
+				goto loop;
+			}
+			PEFSDEBUG("pefs_flushkey: pk=%p, vp=%p\n", pk, vp);
+			vgone(vp);
+			VOP_UNLOCK(vp, 0);
+			vdrop(vp);
+			MNT_ILOCK(mp);
+		} else
+			VI_UNLOCK(vp);
+	}
+	MNT_IUNLOCK(mp);
+#endif
+
+	cache_purgevfs(mp);
+	return (0);
+}
+
+static int
+pefs_lookup(struct vop_cachedlookup_args *ap)
+{
+	struct componentname *cnp = ap->a_cnp;
+	struct vnode *vp = NULL;
+	struct vnode *lvp = NULL;
+	struct vnode *dvp = ap->a_dvp;
+	struct vnode *ldvp = PEFS_LOWERVP(dvp);
+	struct pefs_enccn enccn;
+	struct pefs_node *dpn = VP_TO_PN(dvp);
+	uint64_t flags = cnp->cn_flags;
+	int nokey_lookup, skip_lookup;
+	int error;
+
+	PEFSDEBUG("pefs_lookup: op=%lx, name=%.*s\n",
+	    cnp->cn_nameiop, (int)cnp->cn_namelen, cnp->cn_nameptr);
+
+	pefs_enccn_init(&enccn);
+
+	if ((flags & ISLASTCN) &&
+	    ((dvp->v_mount->mnt_flag & MNT_RDONLY) || pefs_no_keys(dvp)) &&
+	    (cnp->cn_nameiop != LOOKUP))
+		return (EROFS);
+
+	nokey_lookup = 0;
+	skip_lookup = (flags & ISDOTDOT) ||
+	    pefs_name_skip(cnp->cn_nameptr, cnp->cn_namelen);
+	if (((dpn->pn_flags & PN_HASKEY) == 0 || skip_lookup)) {
+		error = VOP_LOOKUP(ldvp, &lvp, cnp);
+		if (skip_lookup || error == 0 ||
+		    pefs_no_keys(dvp))
+			nokey_lookup = 1;
+	}
+
+	if (!nokey_lookup) {
+		error = pefs_enccn_lookup(&enccn, dvp, cnp);
+		if (error == ENOENT && (cnp->cn_flags & ISLASTCN) &&
+		    (cnp->cn_nameiop == CREATE || cnp->cn_nameiop == RENAME ||
+		    (cnp->cn_nameiop == DELETE &&
+		    (cnp->cn_flags & DOWHITEOUT) &&
+		    (cnp->cn_flags & ISWHITEOUT)))) {
+			/*
+			 * Some file systems (like ufs) update internal inode
+			 * fields during VOP_LOOKUP which are later used by
+			 * VOP_CREATE, VOP_MKDIR, etc. That's why we can't
+			 * return EJUSTRETURN here and have to perform
+			 * VOP_LOOKUP(ldvp).
+			 * Attention should also be paid not to unlock dvp.
+			 *
+			 * XXX We also need to have a valid encrypted cnp. Real
+			 * encrypted cnp will be created anyway, encrypted name
+			 * length should just be the same here.
+			 */
+			error = pefs_enccn_create_node(&enccn, dvp, cnp);
+		}
+
+		if (error == 0) {
+			error = VOP_LOOKUP(ldvp, &lvp, &enccn.pec_cn);
+			if (error == 0 || error == EJUSTRETURN)
+				cnp->cn_flags = (cnp->cn_flags & HASBUF) |
+				    (enccn.pec_cn.cn_flags & ~HASBUF);
+			if (error != 0)
+				PEFSDEBUG("pefs_lookup: lower error = %d\n",
+				    error);
+		} else
+			PEFSDEBUG("pefs_lookup: pefs_enccn_lookup error = %d\n",
+			    error);
+	}
+
+	if ((error == 0 || error == EJUSTRETURN) && (flags & ISLASTCN) &&
+	    cnp->cn_nameiop != LOOKUP)
+		cnp->cn_flags |= SAVENAME;
+	if (error == ENOENT && (cnp->cn_flags & MAKEENTRY) &&
+	    cnp->cn_nameiop != CREATE)
+		cache_enter(dvp, NULLVP, cnp);
+	else if ((error == 0 || error == EJUSTRETURN) && lvp != NULL) {
+		if (ldvp == lvp) {
+			*ap->a_vpp = dvp;
+			VREF(dvp);
+			vrele(lvp);
+		} else {
+			if (nokey_lookup)
+				error = pefs_node_get_nokey(dvp->v_mount, lvp,
+				    &vp);
+			else
+				error = pefs_node_get_haskey(dvp->v_mount, lvp,
+				    &vp, &enccn.pec_tkey);
+			if (error != 0) {
+				vput(lvp);
+			} else {
+				*ap->a_vpp = vp;
+				if ((cnp->cn_flags & MAKEENTRY) &&
+				    cnp->cn_nameiop != CREATE)
+					cache_enter(dvp, vp, cnp);
+			}
+		}
+	} else
+		*ap->a_vpp = NULL;
+
+	if (!nokey_lookup)
+		pefs_enccn_free(&enccn);
+
+	PEFSDEBUG("pefs_lookup: op=%lx, name=%.*s error=%d vp=%p\n",
+	    cnp->cn_nameiop, (int)cnp->cn_namelen, cnp->cn_nameptr, error,
+	    *ap->a_vpp);
+
+	return (error);
+}
+
+static int
+pefs_open(struct vop_open_args *ap)
+{
+	struct vnode *vp = ap->a_vp;
+	struct vnode *lvp = PEFS_LOWERVP(vp);
+	struct pefs_node *pn = VP_TO_PN(vp);
+	int error;
+
+	if (pefs_no_keys(vp) && (ap->a_mode & (FWRITE | O_APPEND)))
+		return (EROFS);
+
+	error = VOP_OPEN(lvp, ap->a_mode, ap->a_cred, ap->a_td, ap->a_fp);
+	if (error == 0) {
+		if ((pn->pn_flags & PN_HASKEY) == 0)
+			vp->v_object = lvp->v_object;
+		else
+			vnode_create_vobject(vp, 0, ap->a_td);
+	}
+	return (error);
+}
+
+static int
+pefs_truncate(struct vnode *vp, u_quad_t nsize, struct ucred *cred)
+{
+	struct vnode *lvp = PEFS_LOWERVP(vp);
+	struct vattr va;
+	struct uio *puio;
+	struct pefs_node *pn = VP_TO_PN(vp);
+	struct pefs_chunk pc;
+	u_quad_t osize, diff;
+	size_t oskip, nskip;
+	int error;
+
+	MPASS(vp->v_type == VREG);
+	MPASS(pn->pn_flags & PN_HASKEY);
+
+	error = VOP_GETATTR(lvp, &va, cred);
+	if (error != 0)
+		return (error);
+	osize = va.va_size;
+
+	if (nsize == osize)
+		return (0);
+
+	if ((va.va_flags & (IMMUTABLE | APPEND)) != 0)
+		return (EPERM);
+
+	if (VOP_ISLOCKED(vp) != LK_EXCLUSIVE) {
+		vn_lock(vp, LK_UPGRADE | LK_RETRY);
+		error = VOP_GETATTR(lvp, &va, cred);
+		if (error != 0)
+			return (error);
+		osize = va.va_size;
+		if (nsize == osize)
+			return (0);
+	}
+
+	PEFSDEBUG("pefs_truncate: old size 0x%jx, new size 0x%jx\n",
+	    osize, nsize);
+
+	oskip = osize & PEFS_SECTOR_MASK;
+	nskip = nsize & PEFS_SECTOR_MASK;
+	pefs_chunk_create(&pc, pn, PEFS_SECTOR_SIZE);
+
+	if (nsize < osize && nskip != 0) {
+		pefs_chunk_setsize(&pc, nskip);
+		puio = pefs_chunk_uio(&pc, nsize - nskip, UIO_READ);
+		PEFSDEBUG("pefs_truncate: shrinking file: "
+		    "offset=0x%jx, resid=0x%jx\n",
+		    puio->uio_offset, puio->uio_resid);
+		error = pefs_read_int(vp, puio, IO_UNIT, cred, osize);
+		if (error != 0)
+			goto out;
+		MPASS(puio->uio_resid == 0);
+		puio = pefs_chunk_uio(&pc, nsize - nskip, UIO_WRITE);
+		error = pefs_write_int(vp, puio, IO_UNIT, cred, nsize - nskip);
+		if (error != 0)
+			goto out;
+	}
+
+	VATTR_NULL(&va);
+	va.va_size = nsize;
+	error = VOP_SETATTR(lvp, &va, cred);
+	if (error != 0)
+		goto out;
+	vnode_pager_setsize(vp, nsize);
+
+	if (nsize < osize)
+		goto out;
+
+	diff = nsize - osize;
+	if (oskip != 0 || diff < PEFS_SECTOR_SIZE) {
+		pefs_chunk_setsize(&pc, qmin(PEFS_SECTOR_SIZE - oskip, diff));
+		pefs_chunk_zero(&pc);
+		puio = pefs_chunk_uio(&pc, osize, UIO_WRITE);
+		PEFSDEBUG("pefs_truncate: extending file: "
+		    "offset=0x%jx, resid=0x%jx\n",
+		    puio->uio_offset, puio->uio_resid);
+		error = pefs_write_int(vp, puio, IO_UNIT, cred, osize);
+		if (error != 0 || pc.pc_size == diff)
+			goto out;
+	}
+
+	if (nskip != 0) {
+		pefs_chunk_setsize(&pc, nskip);
+		pefs_chunk_zero(&pc);
+		puio = pefs_chunk_uio(&pc, nsize - nskip, UIO_WRITE);
+		PEFSDEBUG("pefs_truncate: extending file: "
+		    "offset=0x%jx, resid=0x%jx\n",
+		    puio->uio_offset, puio->uio_resid);
+		error = pefs_write_int(vp, puio, IO_UNIT, cred, nsize - nskip);
+	}
+
+out:
+	pefs_chunk_free(&pc, pn);
+
+	return (error);
+}
+
+/*
+ * Setattr call. Disallow write attempts if the layer is mounted read-only.
+ */
+static int
+pefs_setattr(struct vop_setattr_args *ap)
+{
+	struct vnode *vp = ap->a_vp;
+	struct ucred *cred = ap->a_cred;
+	struct vattr *vap = ap->a_vap;
+	int error;
+
+	if ((vap->va_flags != VNOVAL || vap->va_uid != (uid_t)VNOVAL ||
+	    vap->va_gid != (gid_t)VNOVAL || vap->va_atime.tv_sec != VNOVAL ||
+	    vap->va_mtime.tv_sec != VNOVAL || vap->va_mode != (mode_t)VNOVAL) &&
+	    (vp->v_mount->mnt_flag & MNT_RDONLY || pefs_no_keys(vp)))
+		return (EROFS);
+
+	if (vap->va_size != VNOVAL) {
+		switch (vp->v_type) {
+		case VDIR:
+			return (EISDIR);
+		case VCHR:
+		case VBLK:
+		case VSOCK:
+		case VFIFO:
+			if (vap->va_flags != VNOVAL)
+				return (EOPNOTSUPP);
+			return (0);
+		case VREG:
+		case VLNK:
+			/*
+			 * Disallow write attempts if the file system is
+			 * mounted read-only.
+			 */
+			if ((vp->v_mount->mnt_flag & MNT_RDONLY) ||
+			    pefs_no_keys(vp))
+				return (EROFS);
+			/* Bypass size change for node without key */
+			if ((VP_TO_PN(vp)->pn_flags & PN_HASKEY) == 0)
+				break;
+			if (vp->v_type == VREG)
+				error = pefs_truncate(vp, vap->va_size, cred);
+			else
+				error = EOPNOTSUPP; /* TODO */
+			if (error != 0)
+				return (error);
+			vnode_pager_setsize(vp, vap->va_size);
+			break;
+		default:
+			return (EOPNOTSUPP);
+		}
+	}
+
+	return (VOP_SETATTR(PEFS_LOWERVP(vp), vap, cred));
+}
+
+/*
+ *  We handle getattr only to change the fsid.
+ */
+static int
+pefs_getattr(struct vop_getattr_args *ap)
+{
+	struct vnode *vp = ap->a_vp;
+	struct vattr *vap = ap->a_vap;
+	int error;
+
+	error = VOP_GETATTR(PEFS_LOWERVP(vp), vap, ap->a_cred);
+	if (error != 0)
+		return (error);
+
+	vap->va_fsid = vp->v_mount->mnt_stat.f_fsid.val[0];
+	if (vap->va_type == VLNK)
+		vap->va_size = PEFS_NAME_PTON_SIZE(vap->va_size);
+	return (0);
+}
+
+/*
+ * Handle to disallow write access if mounted read-only.
+ */
+static int
+pefs_access_checkmode(struct vnode *vp, accmode_t accmode)
+{
+	/*
+	 * Disallow write attempts on read-only layers;
+	 * unless the file is a socket, fifo, or a block or
+	 * character device resident on the file system.
+	 */
+	if (accmode & VWRITE) {
+		switch (vp->v_type) {
+		case VDIR:
+		case VLNK:
+		case VREG:
+			if ((vp->v_mount->mnt_flag & MNT_RDONLY) != 0 ||
+			    pefs_no_keys(vp))
+				return (EROFS);
+			break;
+		default:
+			break;
+		}
+	}
+
+	return (0);
+}
+
+static int
+pefs_access(struct vop_access_args *ap)
+{
+	struct vnode *vp = ap->a_vp;
+	accmode_t accmode = ap->a_accmode;
+	int error;
+
+	error = pefs_access_checkmode(vp, accmode);
+	if (error != 0)
+		return (error);
+	error = VOP_ACCESS(PEFS_LOWERVP(vp), accmode, ap->a_cred, ap->a_td);
+	return (error);
+}
+
+static int
+pefs_accessx(struct vop_accessx_args *ap)
+{
+	struct vnode *vp = ap->a_vp;
+	accmode_t accmode = ap->a_accmode;
+	int error;
+
+	error = pefs_access_checkmode(vp, accmode);
+	if (error != 0)
+		return (error);
+	error = VOP_ACCESSX(PEFS_LOWERVP(vp), accmode, ap->a_cred, ap->a_td);
+	return (error);
+}
+
+static int
+pefs_getacl(struct vop_getacl_args *ap)
+{
+	struct vnode *vp = ap->a_vp;
+	struct vnode *lvp = PEFS_LOWERVP(vp);
+	int error;
+
+	ap->a_vp = lvp;
+	error = VOP_GETACL_AP(ap);
+	ap->a_vp = vp;
+	return (error);
+}
+
+static int
+pefs_close(struct vop_close_args *ap)
+{
+	struct vnode *vp = ap->a_vp;
+	struct vnode *lvp = PEFS_LOWERVP(vp);
+	int error;
+
+	ap->a_vp = lvp;
+	error = VOP_CLOSE_AP(ap);
+	ap->a_vp = vp;
+	return (error);
+}
+
+static int
+pefs_isemptydir_parsedir(void *mem, size_t sz)
+{
+	struct dirent *de;
+
+	for (de = (struct dirent*) mem; sz > DIRENT_MINSIZE;
+			sz -= de->d_reclen,
+			de = (struct dirent *)(((caddr_t)de) + de->d_reclen)) {
+		MPASS(de->d_reclen <= sz);
+		if (de->d_reclen == 0)
+			break;
+		if (de->d_type == DT_WHT || de->d_fileno == 0)
+			continue;
+		if (de->d_name[0] == '.' && (de->d_namlen == 1 ||
+		    (de->d_namlen == 2 && de->d_name[1] == '.')))
+			continue;
+		return (ENOTEMPTY);
+	}
+	return (0);
+}
+
+static int
+pefs_isemptydir(struct vnode *dvp, struct ucred *cred)
+{
+	struct vnode *ldvp = PEFS_LOWERVP(dvp);
+	struct uio *uio;
+	struct pefs_node *dpn = VP_TO_PN(dvp);
+	struct pefs_chunk pc;
+	off_t offset;
+	int eofflag, error;
+
+	MPASS(dvp->v_type == VDIR);
+
+	offset = 0;
+	eofflag = 0;
+	error = 0;
+	ldvp = PEFS_LOWERVP(dvp);
+	pefs_chunk_create(&pc, dpn, PEFS_SECTOR_SIZE);
+	while (!eofflag) {
+		uio = pefs_chunk_uio(&pc, offset, UIO_READ);
+		error = VOP_READDIR(ldvp, uio, cred, &eofflag, NULL, NULL);
+		if (error != 0)
+			break;
+		offset = uio->uio_offset;
+		if (pc.pc_size == uio->uio_resid)
+			break;
+		pefs_chunk_setsize(&pc, pc.pc_size - uio->uio_resid);
+		error = pefs_isemptydir_parsedir(pc.pc_base, pc.pc_size);
+		if (error != 0)
+			break;
+		pefs_chunk_restore(&pc);
+	}
+	pefs_chunk_free(&pc, dpn);
+	return (error);
+}
+
+static int
+pefs_rename(struct vop_rename_args *ap)
+{
+	struct vnode *fdvp = ap->a_fdvp;
+	struct vnode *lfdvp = PEFS_LOWERVP(fdvp);
+	struct vnode *fvp = ap->a_fvp;
+	struct vnode *lfvp = PEFS_LOWERVP(fvp);
+	struct vnode *tdvp = ap->a_tdvp;
+	struct vnode *ltdvp = PEFS_LOWERVP(tdvp);
+	struct vnode *tvp = ap->a_tvp;
+	struct vnode *ltvp = (tvp == NULL ? NULL : PEFS_LOWERVP(tvp));
+	struct componentname *fcnp = ap->a_fcnp;
+	struct componentname *tcnp = ap->a_tcnp;
+	struct pefs_enccn fenccn;
+	struct pefs_enccn tenccn;
+	struct pefs_enccn txenccn;
+	int error;
+
+	KASSERT(tcnp->cn_flags & (SAVENAME | SAVESTART),
+	    ("pefs_rename: no name"));
+	KASSERT(fcnp->cn_flags & (SAVENAME | SAVESTART),
+	    ("pefs_rename: no name"));
+
+	pefs_enccn_init(&fenccn);
+	pefs_enccn_init(&tenccn);
+	pefs_enccn_init(&txenccn);
+
+	/* Check for cross-device rename. */
+	if ((fvp->v_mount != tdvp->v_mount) ||
+	    (tvp && (fvp->v_mount != tvp->v_mount))) {
+		error = EXDEV;
+		goto out_locked;
+	}
+
+	/* Handle '.' and '..' rename attempt */
+	if ((fcnp->cn_namelen == 1 && fcnp->cn_nameptr[0] == '.') ||
+	    (fcnp->cn_flags & ISDOTDOT) || (tcnp->cn_flags & ISDOTDOT) ||
+	    fdvp == fvp) {
+		error = EINVAL;
+		goto out_locked;
+	}
+
+	if (pefs_no_keys(tdvp)) {
+		error = EROFS;
+		goto out_locked;
+	}
+
+	if ((VP_TO_PN(fvp)->pn_flags & PN_HASKEY) == 0) {
+		PEFSDEBUG("pefs_rename: source !HASKEY: %s\n",
+		    fcnp->cn_nameptr);
+		if ((VP_TO_PN(tdvp)->pn_flags & PN_HASKEY) == 0) {
+			PEFSDEBUG("pefs_rename: target dir !HASKEY: %s\n",
+			    tcnp->cn_nameptr);
+			/* Allow unencrypted to unencrypted rename. */
+			vref(lfdvp);
+			vref(lfvp);
+			vref(ltdvp);
+			if (ltvp != NULL)
+				vref(ltvp);
+			error = VOP_RENAME(lfdvp, lfvp, fcnp, ltdvp, ltvp,
+			    tcnp);
+			goto out_unlocked;
+		}
+		/* Target directory is encrypted. Files should be recreated. */
+		error = EXDEV;
+		goto out_locked;
+	}
+
+	error = pefs_enccn_get(&fenccn, fdvp, fvp, fcnp);
+	if (error != 0)
+		goto out_locked;
+	error = pefs_enccn_create(&tenccn, fenccn.pec_tkey.ptk_key,
+	    fenccn.pec_tkey.ptk_tweak, tcnp);
+	if (error != 0)
+		goto out_locked;
+
+	if (tvp != NULL) {
+		if (fvp->v_type == VDIR && tvp->v_type != VDIR) {
+			error = ENOTDIR;
+			goto out_locked;
+		} else if (fvp->v_type != VDIR && tvp->v_type == VDIR) {
+			error = EISDIR;
+			goto out_locked;
+		} else {
+			/*
+			 * We end up having 2 files with same name but
+			 * different tweaks/keys. If target is directory verify
+			 * it's empty. Set ltvp to zero here because we rename
+			 * to new name and then remove old one.
+			 */
+			if (tvp->v_type == VDIR) {
+				error = pefs_isemptydir(tvp, tcnp->cn_cred);
+				if (error != 0)
+					goto out_locked;
+			}
+
+			error = pefs_enccn_get(&txenccn, tdvp, tvp, tcnp);
+			if (error != 0)
+				goto out_locked;
+
+			ltvp = NULL;
+			VP_TO_PN(tvp)->pn_flags |= PN_WANTRECYCLE;
+			cache_purge(tvp);
+			VOP_UNLOCK(tvp, 0);
+
+			error = VOP_LOOKUP(ltdvp, &ltvp, &tenccn.pec_cn);
+			if (error == 0)
+				panic("pefs_rename: "
+				    "dummy rename target exists");
+			error = 0;
+		}
+	}
+
+	MPASS(ltvp == NULL);
+	MPASS(error == 0);
+	ASSERT_VOP_LOCKED(ltdvp, "pefs_rename");
+
+	vref(lfdvp);
+	vref(lfvp);
+	vref(ltdvp);
+
+	error = VOP_RENAME(lfdvp, lfvp, &fenccn.pec_cn, ltdvp, NULL,
+	    &tenccn.pec_cn);
+
+	if (error == 0) {
+		if (tvp != NULL) {
+			/*
+			 * Remove dummy target file.
+			 */
+			ASSERT_VOP_UNLOCKED(tdvp, "pefs_rename");
+			ASSERT_VOP_UNLOCKED(tvp, "pefs_rename");
+			vn_lock(tdvp, LK_EXCLUSIVE | LK_RETRY);
+			txenccn.pec_cn.cn_nameiop = DELETE;
+			error = VOP_LOOKUP(ltdvp, &ltvp, &txenccn.pec_cn);
+			if (error == 0) {
+				if (tvp->v_type != VDIR)
+					error = VOP_REMOVE(ltdvp, ltvp,
+					    &txenccn.pec_cn);
+				else
+					error = VOP_RMDIR(ltdvp, ltvp,
+					    &txenccn.pec_cn);
+				PEFSDEBUG("pefs_rename: remove old: %s\n",
+				    txenccn.pec_cn.cn_nameptr);
+				vput(ltvp);
+			}
+			VOP_UNLOCK(tdvp, 0);
+		}
+		cache_purge(fdvp);
+		cache_purge(fvp);
+	}
+
+out_unlocked:
+	ASSERT_VOP_UNLOCKED(tdvp, "pefs_rename");
+	vrele(fdvp);
+	vrele(fvp);
+	vrele(tdvp);
+	if (tvp != NULL)
+		vrele(tvp);
+	goto out;
+
+out_locked:
+	if (tdvp == tvp)
+		vrele(tdvp);
+	else
+		vput(tdvp);
+	if (tvp != NULL)
+		vput(tvp);
+	vrele(fdvp);
+	vrele(fvp);
+
+out:
+	pefs_enccn_free(&tenccn);
+	pefs_enccn_free(&txenccn);
+	pefs_enccn_free(&fenccn);
+
+	return (error);
+}
+
+/*
+ * We need to process our own vnode lock and then clear the
+ * interlock flag as it applies only to our vnode, not the
+ * vnodes below us on the stack.
+ */
+static int
+pefs_lock(struct vop_lock1_args *ap)
+{
+	struct vnode *vp = ap->a_vp;
+	int flags = ap->a_flags;
+	struct pefs_mount *pm;
+	struct pefs_node *pn;
+	struct vnode *lvp;
+	int error;
+
+
+	if ((flags & LK_INTERLOCK) == 0) {
+		VI_LOCK(vp);
+		ap->a_flags = flags |= LK_INTERLOCK;
+	}
+	pn = (struct pefs_node *)vp->v_data;
+	/*
+	 * If we're still active we must ask the lower layer to
+	 * lock as ffs has special lock considerations in it's
+	 * vop lock.
+	 */
+	if (pn != NULL && (lvp = pn->pn_lowervp) != NULL) {
+		if (vp->v_mount != NULL) {
+			pm = VFS_TO_PEFS(vp->v_mount);
+			if (pm != NULL &&
+			    (pm->pm_flags & PM_ROOT_CANRECURSE) &&
+			    pm->pm_rootvp == vp)
+				ap->a_flags = flags |= LK_CANRECURSE;
+		}
+		VI_LOCK_FLAGS(lvp, MTX_DUPOK);
+		VI_UNLOCK(vp);
+		/*
+		 * We have to hold the vnode here to solve a potential
+		 * reclaim race.  If we're forcibly vgone'd while we
+		 * still have refs, a thread could be sleeping inside
+		 * the lowervp's vop_lock routine.  When we vgone we will
+		 * drop our last ref to the lowervp, which would allow it
+		 * to be reclaimed.  The lowervp could then be recycled,
+		 * in which case it is not legal to be sleeping in it's VOP.
+		 * We prevent it from being recycled by holding the vnode
+		 * here.
+		 */
+		vholdl(lvp);
+		error = VOP_LOCK(lvp, flags);
+
+		/*
+		 * We might have slept to get the lock and someone might have
+		 * cleaned our vnode already, switching vnode lock from one in
+		 * lowervp to v_lock in our own vnode structure.  Handle this
+		 * case by reacquiring correct lock in requested mode.
+		 */
+		if (vp->v_data == NULL && error == 0) {
+			ap->a_flags &= ~(LK_TYPE_MASK | LK_INTERLOCK);
+			switch (flags & LK_TYPE_MASK) {
+			case LK_SHARED:
+				ap->a_flags |= LK_SHARED;
+				break;
+			case LK_UPGRADE:
+			case LK_EXCLUSIVE:
+				ap->a_flags |= LK_EXCLUSIVE;
+				break;
+			default:
+				panic("pefs_lock: "
+				    "unsupported lock request %d\n",
+				    ap->a_flags);
+			}
+			VOP_UNLOCK(lvp, 0);
+			error = vop_stdlock(ap);
+		}
+		vdrop(lvp);
+	} else
+		error = vop_stdlock(ap);
+
+	return (error);
+}
+
+/*
+ * We need to process our own vnode unlock and then clear the
+ * interlock flag as it applies only to our vnode, not the
+ * vnodes below us on the stack.
+ */
+static int
+pefs_unlock(struct vop_unlock_args *ap)
+{
+	struct vnode *vp = ap->a_vp;
+	int flags = ap->a_flags;
+	int mtxlkflag = 0;
+	struct pefs_node *pn;
+	struct vnode *lvp;
+	int error;
+
+	if ((flags & LK_INTERLOCK) != 0)
+		mtxlkflag = 1;
+	else if (mtx_owned(VI_MTX(vp)) == 0) {
+		VI_LOCK(vp);
+		mtxlkflag = 2;
+	}
+	pn = (struct pefs_node *)vp->v_data;
+	if (pn != NULL && (lvp = pn->pn_lowervp) != NULL) {
+		VI_LOCK_FLAGS(lvp, MTX_DUPOK);
+		flags |= LK_INTERLOCK;
+		vholdl(lvp);
+		VI_UNLOCK(vp);
+		error = VOP_UNLOCK(lvp, flags);
+		vdrop(lvp);
+		if (mtxlkflag == 0)
+			VI_LOCK(vp);
+	} else {
+		if (mtxlkflag == 2)
+			VI_UNLOCK(vp);
+		error = vop_stdunlock(ap);
+	}
+
+	return (error);
+}
+
+static int
+pefs_inactive(struct vop_inactive_args *ap)
+{
+	struct vnode *vp = ap->a_vp;
+	struct pefs_node *pn = VP_TO_PN(vp);
+
+	/*
+	 * Buffers can be still be in use because they are protected only by
+	 * vnode interlock.
+	 * Free remaining buffers in pefs_reclaim.
+	 */
+	pefs_node_buf_free(pn);
+
+	if ((pn->pn_flags & PN_HASKEY) && vp->v_object != NULL) {
+		if (vp->v_object->resident_page_count > 0)
+			PEFSDEBUG("pefs_inactive: vobject has dirty pages: "
+			    "vp=%p count=%d\n",
+			    vp, vp->v_object->resident_page_count);
+#if __FreeBSD_version >= 1000030
+		VM_OBJECT_WLOCK(vp->v_object);
+		vm_object_page_clean(vp->v_object, 0, 0, OBJPC_SYNC);
+		VM_OBJECT_WUNLOCK(vp->v_object);
+#else
+		VM_OBJECT_LOCK(vp->v_object);
+		vm_object_page_clean(vp->v_object, 0, 0, OBJPC_SYNC);
+		VM_OBJECT_UNLOCK(vp->v_object);
+#endif
+	}
+
+	if ((pn->pn_flags & PN_WANTRECYCLE) || (pn->pn_flags & PN_HASKEY) == 0)
+#if __FreeBSD_version >= 1000011
+		vrecycle(vp);
+#else
+		vrecycle(vp, ap->a_td);
+#endif
+
+	return (0);
+}
+
+static int
+pefs_reclaim(struct vop_reclaim_args *ap)
+{
+	struct vnode *vp = ap->a_vp;
+	struct pefs_node *pn = VP_TO_PN(vp);
+	struct vnode *lowervp = pn->pn_lowervp;
+
+	PEFSDEBUG("pefs_reclaim: vp=%p\n", vp);
+
+	if (pn->pn_flags & PN_HASKEY)
+		vnode_destroy_vobject(vp);
+	else
+		vp->v_object = NULL;
+	cache_purge(vp);
+
+	/*
+	 * Use the interlock to protect the clearing of v_data to
+	 * prevent faults in pefs_lock().
+	 */
+
+	pefs_node_buf_free(pn);
+	VI_LOCK(vp);
+#ifdef INVARIANTS
+	if ((pn->pn_flags & (PN_LOCKBUF_SMALL | PN_LOCKBUF_LARGE)) != 0)
+		printf("pefs_reclaim: node buffer leaked: vp: %p\n", vp);
+#endif
+	vp->v_data = NULL;
+	vp->v_vnlock = &vp->v_lock;
+	pn->pn_lowervp = NULL;
+	pn->pn_lowervp_dead = lowervp;
+	lockmgr(vp->v_vnlock, LK_EXCLUSIVE | LK_INTERLOCK, VI_MTX(vp));
+	if (lowervp == NULL)
+		panic("pefs_reclaim: reclaiming a node with no lowervp");
+	VOP_UNLOCK(lowervp, 0);
+
+	/* Asynchronously release lower vnode and free pefs node. */
+	pefs_node_asyncfree(pn);
+
+	return (0);
+}
+
+static int
+pefs_print(struct vop_print_args *ap)
+{
+	struct vnode *vp = ap->a_vp;
+	struct pefs_node *pn = VP_TO_PN(vp);
+
+	printf("\tvp=%p, lowervp=%p, flags=%04d\n", vp,
+	    pn->pn_lowervp, pn->pn_flags);
+	return (0);
+}
+
+static int
+pefs_getwritemount(struct vop_getwritemount_args *ap)
+{
+	struct vnode *vp = ap->a_vp;
+	struct vnode *lowervp;
+	struct pefs_node *pn;
+
+	VI_LOCK(vp);
+	pn = VP_TO_PN(vp);
+	if (pn != NULL && (lowervp = pn->pn_lowervp) != NULL) {
+		VI_LOCK_FLAGS(lowervp, MTX_DUPOK);
+		VI_UNLOCK(vp);
+		vholdl(lowervp);
+		VI_UNLOCK(lowervp);
+		VOP_GETWRITEMOUNT(lowervp, ap->a_mpp);
+		vdrop(lowervp);
+	} else {
+		VI_UNLOCK(vp);
+		*(ap->a_mpp) = NULL;
+	}
+	return (0);
+}
+
+static int
+pefs_vptofh(struct vop_vptofh_args *ap)
+{
+	struct vnode *lvp = PEFS_LOWERVP(ap->a_vp);
+
+	return (VOP_VPTOFH(lvp, ap->a_fhp));
+}
+
+static void
+pefs_readdir_decrypt(struct pefs_dircache *pd, struct pefs_ctx *ctx,
+    struct pefs_key *pk, int dflags, void *mem, size_t *psize)
+{
+	struct pefs_dircache_entry *cache;
+	struct dirent *de, *de_next;
+	size_t sz;
+
+	for (de = (struct dirent*) mem, sz = *psize; sz > DIRENT_MINSIZE;
+	    de = de_next) {
+		MPASS(de->d_reclen <= sz);
+		if (de->d_reclen == 0)
+			break;
+		sz -= de->d_reclen;
+		de_next = (struct dirent *)(((caddr_t)de) + de->d_reclen);
+		if (de->d_type == DT_WHT || de->d_fileno == 0)
+			continue;
+		if (pefs_name_skip(de->d_name, de->d_namlen))
+			continue;
+		cache = pefs_cache_dirent(pd, de, ctx, pk);
+		if (cache != NULL) {
+			/* Do not change d_reclen */
+			MPASS(cache->pde_namelen + 1 <= de->d_namlen);
+			memcpy(de->d_name, cache->pde_name,
+			    cache->pde_namelen + 1);
+			de->d_namlen = cache->pde_namelen;
+		} else if (dflags & PN_HASKEY) {
+			*psize -= de->d_reclen;
+			memcpy(de, de_next, sz);
+			de_next = de;
+		}
+	}
+}
+
+static int
+pefs_readdir(struct vop_readdir_args *ap)
+{
+	struct vnode *vp = ap->a_vp;
+	struct vnode *lvp = PEFS_LOWERVP(vp);
+	struct uio *uio = ap->a_uio;
+	struct ucred *cred = ap->a_cred;
+	int *eofflag = ap->a_eofflag;
+	struct uio *puio;
+	struct pefs_node *pn = VP_TO_PN(vp);
+	struct pefs_key *pn_key;
+	struct pefs_chunk pc;
+	struct pefs_ctx *ctx;
+	size_t mem_size;
+	u_long gen;
+	int error;
+	int r_ncookies = 0, r_ncookies_max = 0, ncookies = 0;
+	u_long *r_cookies = NULL, *cookies = NULL;
+	int *a_ncookies;
+	u_long **a_cookies;
+
+	if (pefs_no_keys(vp)) {
+		error = VOP_READDIR(lvp, uio, cred, eofflag, ap->a_ncookies,
+		    ap->a_cookies);
+		return (error);
+	}
+
+	if (ap->a_ncookies == NULL || ap->a_cookies == NULL) {
+		a_ncookies = NULL;
+		a_cookies = NULL;
+	} else {
+		a_ncookies = &ncookies;
+		a_cookies = &cookies;
+	}
+
+	gen = pefs_getgen(vp, cred);
+	ctx = pefs_ctx_get();
+	pefs_chunk_create(&pc, pn, qmin(uio->uio_resid, DFLTPHYS));
+	pn_key = pefs_node_key(pn);
+	pefs_dircache_lock(pn->pn_dircache);
+	if (!pefs_dircache_valid(pn->pn_dircache, gen) && uio->uio_offset != 0)
+		gen = 0;
+	pefs_dircache_beginupdate(pn->pn_dircache, gen);
+	while (1) {
+		if (uio->uio_resid < pc.pc_size)
+			pefs_chunk_setsize(&pc, uio->uio_resid);
+		puio = pefs_chunk_uio(&pc, uio->uio_offset, uio->uio_rw);
+		error = VOP_READDIR(lvp, puio, cred, eofflag,
+		    a_ncookies, a_cookies);
+		if (error != 0)
+			break;
+
+		if (pc.pc_size == puio->uio_resid)
+			break;
+		pefs_chunk_setsize(&pc, pc.pc_size - puio->uio_resid);
+		mem_size = pc.pc_size;
+		if (*eofflag == 0)
+			pefs_dircache_abortupdate(pn->pn_dircache);
+		pefs_readdir_decrypt(pn->pn_dircache, ctx, pn_key, pn->pn_flags,
+		    pc.pc_base, &mem_size);
+		pefs_chunk_setsize(&pc, mem_size);
+		error = pefs_chunk_copy(&pc, 0, uio);
+		if (error != 0)
+			break;
+		uio->uio_offset = puio->uio_offset;
+
+		/* Finish if there is no need to merge cookies */
+		if ((*eofflag != 0 || uio->uio_resid < DIRENT_MAXSIZE) &&
+		    (a_cookies == NULL || r_cookies == NULL))
+			break;
+
+		if (a_cookies != NULL && ncookies != 0) {
+			KASSERT(cookies != NULL, ("cookies == NULL"));
+			if (r_cookies == NULL) {
+				/* Allocate buffer of maximum possible size */
+				r_ncookies_max = uio->uio_resid /
+				    DIRENT_MINSIZE;
+				r_ncookies_max += ncookies;
+				r_cookies = malloc(r_ncookies_max *
+				    sizeof(u_long),
+				    M_TEMP, M_WAITOK);
+			}
+			PEFSDEBUG("pefs_readdir: merge cookies %d + %d\n",
+			    r_ncookies, ncookies);
+			KASSERT(r_ncookies + ncookies <= r_ncookies_max,
+			    ("cookies buffer is too small"));
+			memcpy(r_cookies + r_ncookies, cookies,
+			    ncookies * sizeof(u_long));
+			r_ncookies += ncookies;
+			ncookies = 0;
+			free(cookies, M_TEMP);
+			cookies = NULL;
+		}
+
+		if (*eofflag != 0 || uio->uio_resid < DIRENT_MAXSIZE)
+			break;
+
+		pefs_chunk_restore(&pc);
+	}
+	if (*eofflag != 0 && error == 0)
+		pefs_dircache_endupdate(pn->pn_dircache);
+	else
+		pefs_dircache_abortupdate(pn->pn_dircache);
+
+	if (error == 0 && a_cookies != NULL) {
+		if (r_cookies != NULL) {
+			*ap->a_cookies = r_cookies;
+			*ap->a_ncookies = r_ncookies;
+		} else {
+			*ap->a_cookies = cookies;
+			*ap->a_ncookies = ncookies;
+		}
+	}
+
+	pefs_dircache_unlock(pn->pn_dircache);
+	pefs_ctx_free(ctx);
+	pefs_key_release(pn_key);
+	pefs_chunk_free(&pc, pn);
+
+	return (error);
+}
+
+static int
+pefs_mkdir(struct vop_mkdir_args *ap)
+{
+	struct vnode *dvp = ap->a_dvp;
+	struct vnode *lvp;
+	struct componentname *cnp = ap->a_cnp;
+	struct pefs_enccn enccn;
+	int error;
+
+	KASSERT(cnp->cn_flags & SAVENAME, ("pefs_mkdir: no name"));
+	if (pefs_no_keys(dvp))
+		return (EROFS);
+	pefs_enccn_init(&enccn);
+	PEFS_ENCCN_ASSERT_NOENT(dvp, cnp);
+	error = pefs_enccn_create_node(&enccn, dvp, cnp);
+	if (error != 0)
+		return (error);
+
+	error = VOP_MKDIR(PEFS_LOWERVP(dvp), &lvp, &enccn.pec_cn, ap->a_vap);
+	if (error == 0 && lvp != NULL) {
+		error = pefs_node_get_haskey(dvp->v_mount, lvp, ap->a_vpp,
+		    &enccn.pec_tkey);
+		if (error != 0)
+			vput(lvp);
+	}
+
+	pefs_enccn_free(&enccn);
+
+	return (error);
+}
+
+static int
+pefs_rmdir(struct vop_rmdir_args *ap)
+{
+	struct vnode *dvp = ap->a_dvp;
+	struct vnode *vp = ap->a_vp;
+	struct componentname *cnp = ap->a_cnp;
+	struct pefs_enccn enccn;
+	int error;
+
+	KASSERT(cnp->cn_flags & SAVENAME, ("pefs_rmdir: no name"));
+	if (pefs_no_keys(vp))
+		return (EROFS);
+	pefs_enccn_init(&enccn);
+	error = pefs_enccn_get(&enccn, dvp, vp, cnp);
+	if (error != 0)
+		return (error);
+
+	error = VOP_RMDIR(PEFS_LOWERVP(dvp), PEFS_LOWERVP(vp), &enccn.pec_cn);
+	VP_TO_PN(vp)->pn_flags |= PN_WANTRECYCLE;
+
+	pefs_enccn_free(&enccn);
+
+	if (error == 0) {
+		cache_purge(dvp);
+		cache_purge(vp);
+	}
+
+	return (error);
+}
+
+static int
+pefs_create(struct vop_create_args *ap)
+{
+	struct vnode *dvp = ap->a_dvp;
+	struct vnode *lvp;
+	struct componentname *cnp = ap->a_cnp;
+	struct pefs_enccn enccn;
+	int error;
+
+	KASSERT(cnp->cn_flags & SAVENAME, ("pefs_create: no name"));
+	if (pefs_no_keys(dvp))
+		return (EROFS);
+	pefs_enccn_init(&enccn);
+	PEFS_ENCCN_ASSERT_NOENT(dvp, cnp);
+	error = pefs_enccn_create_node(&enccn, dvp, cnp);
+	if (error != 0)
+		return (error);
+
+	error = VOP_CREATE(PEFS_LOWERVP(dvp), &lvp, &enccn.pec_cn, ap->a_vap);
+	if (error == 0 && lvp != NULL) {
+		error = pefs_node_get_haskey(dvp->v_mount, lvp, ap->a_vpp,
+		    &enccn.pec_tkey);
+		if (error != 0)
+			vput(lvp);
+	}
+
+	pefs_enccn_free(&enccn);
+
+	return (error);
+}
+
+static int
+pefs_remove(struct vop_remove_args *ap)
+{
+	struct vnode *dvp = ap->a_dvp;
+	struct vnode *vp = ap->a_vp;
+	struct componentname *cnp = ap->a_cnp;
+	struct pefs_enccn enccn;
+	int error;
+
+	KASSERT(cnp->cn_flags & SAVENAME, ("pefs_remove: no name"));
+	if (pefs_no_keys(dvp))
+		return (EROFS);
+	pefs_enccn_init(&enccn);
+	error = pefs_enccn_get(&enccn, dvp, vp, cnp);
+	if (error != 0)
+		return (error);
+
+	error = VOP_REMOVE(PEFS_LOWERVP(dvp), PEFS_LOWERVP(vp), &enccn.pec_cn);
+	VP_TO_PN(vp)->pn_flags |= PN_WANTRECYCLE;
+
+	pefs_enccn_free(&enccn);
+
+	if (error == 0)
+		cache_purge(vp);
+
+	return (error);
+}
+
+static int
+pefs_link(struct vop_link_args *ap)
+{
+	struct vnode *dvp = ap->a_tdvp;
+	struct vnode *vp = ap->a_vp;
+	struct componentname *cnp = ap->a_cnp;
+	struct pefs_node *pn = VP_TO_PN(vp);
+	struct pefs_enccn enccn;
+	int error;
+
+	KASSERT(cnp->cn_flags & SAVENAME, ("pefs_link: no name"));
+	if (dvp->v_mount != vp->v_mount)
+		return (EXDEV);
+	if ((pn->pn_flags & PN_HASKEY) == 0 || pefs_no_keys(vp))
+		return (EROFS);
+	pefs_enccn_init(&enccn);
+	PEFS_ENCCN_ASSERT_NOENT(ap->a_tdvp, cnp);
+	error = pefs_enccn_create(&enccn, pn->pn_tkey.ptk_key,
+	    pn->pn_tkey.ptk_tweak, cnp);
+	if (error != 0)
+		return (error);
+
+	error = VOP_LINK(PEFS_LOWERVP(dvp), PEFS_LOWERVP(vp), &enccn.pec_cn);
+
+	pefs_enccn_free(&enccn);
+
+	return (error);
+}
+
+static int
+pefs_symlink(struct vop_symlink_args *ap)
+{
+	struct vnode *dvp = ap->a_dvp;
+	struct vnode *ldvp = PEFS_LOWERVP(dvp);
+	struct vnode *lvp;
+	struct componentname *cnp = ap->a_cnp;
+	struct pefs_node *dpn = VP_TO_PN(dvp);
+	struct pefs_enccn enccn;
+	struct pefs_chunk pc;
+	char *target = ap->a_target;
+	char *enc_target, *penc_target;
+	size_t penc_target_len;
+	size_t target_len;
+	int error;
+
+	KASSERT(cnp->cn_flags & SAVENAME, ("pefs_symlink: no name"));
+	if (pefs_no_keys(dvp))
+		return (EROFS);
+
+	target_len = strlen(ap->a_target);
+	penc_target_len = PEFS_NAME_NTOP_SIZE(target_len) + 1;
+	if (penc_target_len > MAXPATHLEN)
+		return (ENAMETOOLONG);
+
+	pefs_enccn_init(&enccn);
+	PEFS_ENCCN_ASSERT_NOENT(dvp, cnp);
+	error = pefs_enccn_create_node(&enccn, dvp, cnp);
+	if (error != 0)
+		return (error);
+
+	pefs_chunk_create(&pc, dpn, target_len);
+	enc_target = pc.pc_base;
+	penc_target = malloc(penc_target_len, M_PEFSBUF, M_WAITOK);
+
+	memcpy(enc_target, target, target_len);
+	pefs_data_encrypt(&enccn.pec_tkey, 0, &pc);
+	error = pefs_name_ntop(enc_target, target_len, penc_target,
+	    penc_target_len);
+	if (error <= 0) {
+		PEFSDEBUG("pefs_symlink: pefs_name_ntop error=%d\n", error);
+		error = EIO;
+		goto out;
+	}
+
+	pefs_chunk_free(&pc, dpn);
+	enc_target = NULL;
+
+	error = VOP_SYMLINK(ldvp, &lvp, &enccn.pec_cn, ap->a_vap, penc_target);
+	if (error == 0) {
+		error = pefs_node_get_haskey(dvp->v_mount, lvp, ap->a_vpp,
+		    &enccn.pec_tkey);
+		if (error != 0)
+			vput(lvp);
+	}
+
+out:
+	pefs_enccn_free(&enccn);
+	free(penc_target, M_PEFSBUF);
+
+	return (error);
+}
+
+static int
+pefs_readlink(struct vop_readlink_args *ap)
+{
+	struct vnode *vp = ap->a_vp;
+	struct vnode *lvp = PEFS_LOWERVP(vp);
+	struct uio *uio = ap->a_uio;
+	struct uio *puio;
+	struct pefs_chunk pc;
+	struct pefs_node *pn = VP_TO_PN(vp);
+	ssize_t target_len;
+	int error;
+
+	if ((pn->pn_flags & PN_HASKEY) == 0)
+		return (VOP_READLINK(lvp, uio, ap->a_cred));
+
+	MPASS(uio->uio_offset == 0);
+	pefs_chunk_create(&pc, pn, MAXPATHLEN);
+	puio = pefs_chunk_uio(&pc, 0, uio->uio_rw);
+	error = VOP_READLINK(lvp, puio, ap->a_cred);
+	if (error == 0) {
+		target_len = pc.pc_size - puio->uio_resid;
+		target_len = pefs_name_pton(pc.pc_base, target_len, pc.pc_base,
+		    target_len);
+		if (target_len >= 0) {
+			pefs_chunk_setsize(&pc, target_len);
+			pefs_data_decrypt(&pn->pn_tkey, 0, &pc);
+			uiomove(pc.pc_base, target_len, uio);
+		} else
+			error = EIO;
+	}
+	pefs_chunk_free(&pc, pn);
+
+	return (error);
+}
+
+static int
+pefs_mknod(struct vop_mknod_args *ap)
+{
+	struct vnode *dvp = ap->a_dvp;
+	struct vnode *lvp;
+	struct componentname *cnp = ap->a_cnp;
+	struct pefs_enccn enccn;
+	int error;
+
+	if (pefs_no_keys(dvp))
+		return (EROFS);
+	pefs_enccn_init(&enccn);
+	PEFS_ENCCN_ASSERT_NOENT(dvp, cnp);
+	error = pefs_enccn_create_node(&enccn, dvp, cnp);
+	if (error != 0)
+		return (error);
+
+	error = VOP_MKNOD(PEFS_LOWERVP(dvp), &lvp, &enccn.pec_cn, ap->a_vap);
+	if (error == 0 && lvp != NULL) {
+		error = pefs_node_get_haskey(dvp->v_mount, lvp, ap->a_vpp,
+		    &enccn.pec_tkey);
+		if (error != 0)
+			vput(lvp);
+	}
+	pefs_enccn_free(&enccn);
+
+	return (error);
+}
+
+static __inline int
+pefs_getsize(struct vnode *vp, u_quad_t *sizep, struct ucred *cred)
+{
+	struct vattr va;
+	int error;
+
+	error = VOP_GETATTR(PEFS_LOWERVP(vp), &va, cred);
+	if (error == 0)
+		*sizep = va.va_size;
+
+	return (error);
+}
+
+static __inline int
+pefs_ismapped(struct vnode *vp)
+{
+	vm_object_t object = vp->v_object;
+
+	if (object == NULL)
+		return (0);
+
+	if (object->resident_page_count > 0 ||
+#if __FreeBSD_version >= 1000030
+	    !vm_object_cache_is_empty(object)
+#else
+	    object->cache != NULL
+#endif
+	    )
+		return (1);
+	return (0);
+}
+
+static int
+pefs_readmapped(struct vnode *vp, struct uio *uio, ssize_t bsize,
+    vm_page_t *mp)
+{
+	vm_page_t m;
+	vm_offset_t moffset;
+	ssize_t msize;
+	int error;
+
+	MPASS(bsize <= PEFS_SECTOR_SIZE);
+	*mp = NULL;
+	moffset = uio->uio_offset & PEFS_SECTOR_MASK;
+	msize = bsize - moffset;
+
+#if __FreeBSD_version >= 1000030
+	VM_OBJECT_WLOCK(vp->v_object);
+#else
+	VM_OBJECT_LOCK(vp->v_object);
+#endif
+lookupvpg:
+	m = vm_page_lookup(vp->v_object,
+	    OFF_TO_IDX(uio->uio_offset));
+	if (m != NULL && vm_page_is_valid(m, moffset, msize)) {
+#if __FreeBSD_version >= 900038
+		if ((m->oflags & VPO_BUSY) != 0) {
+			/*
+			 * Reference the page before unlocking and
+			 * sleeping so that the page daemon is less
+			 * likely to reclaim it.
+			 */
+#if __FreeBSD_version >= 900044
+			vm_page_aflag_set(m, PGA_REFERENCED);
+#else
+			vm_page_lock_queues();
+			vm_page_flag_set(m, PG_REFERENCED);
+#endif
+			vm_page_sleep(m, "pefsmr");
+			goto lookupvpg;
+		}
+#else
+		if (vm_page_sleep_if_busy(m, FALSE, "pefsmr"))
+			goto lookupvpg;
+#endif
+		vm_page_busy(m);
+#if __FreeBSD_version >= 1000030
+		VM_OBJECT_WUNLOCK(vp->v_object);
+#else
+		VM_OBJECT_UNLOCK(vp->v_object);
+#endif
+		PEFSDEBUG("pefs_read: mapped: "
+		    "offset=0x%jx moffset=0x%jx msize=0x%jx\n",
+		    uio->uio_offset, (intmax_t)moffset, (intmax_t)msize);
+		error = uiomove_fromphys(&m, moffset, msize, uio);
+#if __FreeBSD_version >= 1000030
+		VM_OBJECT_WLOCK(vp->v_object);
+		vm_page_wakeup(m);
+		VM_OBJECT_WUNLOCK(vp->v_object);
+#else
+		VM_OBJECT_LOCK(vp->v_object);
+		vm_page_wakeup(m);
+		VM_OBJECT_UNLOCK(vp->v_object);
+#endif
+		if (error != 0) {
+			MPASS(error != EJUSTRETURN);
+			return (error);
+		}
+		return (EJUSTRETURN);
+	}
+	if (m != NULL && uio->uio_segflg == UIO_NOCOPY) {
+#if __FreeBSD_version >= 900036
+		if ((m->oflags & VPO_BUSY) != 0) {
+			/*
+			 * Reference the page before unlocking and
+			 * sleeping so that the page daemon is less
+			 * likely to reclaim it.
+			 */
+#if __FreeBSD_version >= 900044
+			vm_page_aflag_set(m, PGA_REFERENCED);
+#else
+			vm_page_lock_queues();
+			vm_page_flag_set(m, PG_REFERENCED);
+#endif
+			vm_page_sleep(m, "pefsmr");
+			goto lookupvpg;
+		}
+#else
+		if (vm_page_sleep_if_busy(m, FALSE, "pefsmr"))
+			goto lookupvpg;
+#endif /* __FreeBSD_version */
+		vm_page_busy(m);
+		*mp = m;
+	}
+#if __FreeBSD_version >= 1000030
+	VM_OBJECT_WUNLOCK(vp->v_object);
+#else
+	VM_OBJECT_UNLOCK(vp->v_object);
+#endif
+	return (0);
+}
+
+static __inline ssize_t
+pefs_bufsize(struct uio *uio, ssize_t maxsize)
+{
+	return (qmin(roundup2(uio->uio_resid, PEFS_SECTOR_SIZE), maxsize));
+}
+
+static int
+pefs_read(struct vop_read_args *ap)
+{
+	struct vnode *vp = ap->a_vp;
+	struct vnode *lvp = PEFS_LOWERVP(vp);
+	struct uio *uio = ap->a_uio;
+	struct ucred *cred = ap->a_cred;
+	struct pefs_node *pn = VP_TO_PN(vp);
+	u_quad_t fsize;
+	int ioflag = ap->a_ioflag;
+	int error;
+
+	if (vp->v_type == VDIR)
+		return (EISDIR);
+	if ((pn->pn_flags & PN_HASKEY) == 0 || vp->v_type == VFIFO)
+		return (VOP_READ(lvp, uio, ioflag, cred));
+	if (vp->v_type != VREG)
+		return (EOPNOTSUPP);
+	if (uio->uio_resid == 0)
+		return (0);
+	if (uio->uio_offset < 0)
+		return (EINVAL);
+
+	error = pefs_getsize(vp, &fsize, cred);
+	if (error != 0)
+		return (error);
+
+	error = pefs_read_int(vp, uio, ioflag, cred, fsize);
+	return (error);
+}
+
+static int
+pefs_read_int(struct vnode *vp, struct uio *uio, int ioflag, struct ucred *cred,
+    u_quad_t fsize)
+{
+	struct vnode *lvp = PEFS_LOWERVP(vp);
+	struct uio *puio;
+	struct pefs_node *pn = VP_TO_PN(vp);
+	struct pefs_chunk pc;
+	struct sf_buf *sf;
+	vm_page_t m;
+	char *ma;
+	ssize_t bsize, bskip, done;
+	off_t poffset;
+	int error = 0, mapped, nocopy;
+
+	MPASS(vp->v_type == VREG);
+	MPASS(uio->uio_resid != 0);
+	MPASS(uio->uio_offset >= 0);
+
+	mapped = pefs_ismapped(vp);
+	if (mapped != 0)
+		bsize = PEFS_SECTOR_SIZE;
+	else
+		bsize = pefs_bufsize(uio, DFLTPHYS);
+
+	pefs_chunk_create(&pc, pn, bsize);
+	m = NULL;
+	nocopy = 0;
+	while (uio->uio_resid > 0 && uio->uio_offset < fsize) {
+		MPASS(nocopy == 0);
+		bskip = uio->uio_offset & PEFS_SECTOR_MASK;
+		poffset = uio->uio_offset - bskip;
+		bsize = pefs_bufsize(uio, bsize);
+		bsize = qmin(fsize - poffset, bsize);
+
+		if (mapped != 0) {
+			error = pefs_readmapped(vp, uio, bsize, &m);
+			if (error == EJUSTRETURN) {
+				error = 0;
+				continue;
+			} else if (error != 0)
+				break;
+			if (m != NULL && uio->uio_segflg == UIO_NOCOPY)
+				nocopy = 1;
+			else
+				MPASS(m == NULL);
+		}
+		pefs_chunk_setsize(&pc, bsize);
+
+		PEFSDEBUG("pefs_read: mapped=%d m=%d offset=0x%jx size=0x%zx\n",
+		    mapped, m != NULL, uio->uio_offset, bsize - bskip);
+		puio = pefs_chunk_uio(&pc, poffset, uio->uio_rw);
+		error = VOP_READ(lvp, puio, ioflag, cred);
+		if (error != 0)
+			break;
+
+		done = pc.pc_size - puio->uio_resid;
+		if (done <= bskip)
+			break;
+
+		/* XXX assert full buffer is read */
+		pefs_chunk_setsize(&pc, done);
+		pefs_data_decrypt(&pn->pn_tkey, poffset, &pc);
+		if (nocopy == 0) {
+			error = pefs_chunk_copy(&pc, bskip, uio);
+			if (error != 0)
+				break;
+		} else {
+			nocopy = 0;
+			sched_pin();
+			sf = sf_buf_alloc(m, SFB_CPUPRIVATE);
+			ma = (char *)sf_buf_kva(sf);
+			done -= bskip;
+			memcpy(ma + bskip, (char *)pc.pc_base + bskip, done);
+			uio->uio_offset += done;
+			uio->uio_resid -= done;
+			sf_buf_free(sf);
+			sched_unpin();
+#if __FreeBSD_version >= 1000030
+			VM_OBJECT_WLOCK(vp->v_object);
+			vm_page_wakeup(m);
+			VM_OBJECT_WUNLOCK(vp->v_object);
+#else
+			VM_OBJECT_LOCK(vp->v_object);
+			vm_page_wakeup(m);
+			VM_OBJECT_UNLOCK(vp->v_object);
+#endif
+		}
+	}
+	if (nocopy != 0) {
+#if __FreeBSD_version >= 1000030
+		VM_OBJECT_WLOCK(vp->v_object);
+		vm_page_wakeup(m);
+		VM_OBJECT_WUNLOCK(vp->v_object);
+#else
+		VM_OBJECT_LOCK(vp->v_object);
+		vm_page_wakeup(m);
+		VM_OBJECT_UNLOCK(vp->v_object);
+#endif
+	}
+	pefs_chunk_free(&pc, pn);
+
+	return (error);
+}
+
+static int
+pefs_writemapped(struct vnode *vp, struct uio *uio,
+    ssize_t bsize, char *pagebuf)
+{
+	struct sf_buf *sf;
+	char *ma;
+	vm_page_t m;
+	vm_offset_t moffset;
+	vm_pindex_t idx;
+	int error;
+
+	MPASS(bsize <= PEFS_SECTOR_SIZE);
+	moffset = uio->uio_offset & PEFS_SECTOR_MASK;
+
+#if __FreeBSD_version >= 1000030
+	VM_OBJECT_WLOCK(vp->v_object);
+#else
+	VM_OBJECT_LOCK(vp->v_object);
+#endif
+lookupvpg:
+	idx = OFF_TO_IDX(uio->uio_offset);
+	m = vm_page_lookup(vp->v_object, idx);
+	if (m != NULL && vm_page_is_valid(m, 0, bsize)) {
+#if __FreeBSD_version >= 900038
+		if ((m->oflags & VPO_BUSY) != 0) {
+			/*
+			 * Reference the page before unlocking and
+			 * sleeping so that the page daemon is less
+			 * likely to reclaim it.
+			 */
+#if __FreeBSD_version >= 900044
+			vm_page_aflag_set(m, PGA_REFERENCED);
+#else
+			vm_page_lock_queues();
+			vm_page_flag_set(m, PG_REFERENCED);
+#endif
+			vm_page_sleep(m, "pefsmw");
+			goto lookupvpg;
+		}
+		vm_page_busy(m);
+		vm_page_undirty(m);
+#else
+		if (vm_page_sleep_if_busy(m, FALSE, "pefsmw"))
+			goto lookupvpg;
+		vm_page_busy(m);
+		vm_page_lock_queues();
+		vm_page_undirty(m);
+		vm_page_unlock_queues();
+#endif
+#if __FreeBSD_version >= 1000030
+		VM_OBJECT_WUNLOCK(vp->v_object);
+#else
+		VM_OBJECT_UNLOCK(vp->v_object);
+#endif
+		PEFSDEBUG("pefs_write: mapped: "
+		    "offset=0x%jx moffset=0x%jx bsize=0x%zx\n",
+		    uio->uio_offset, (intmax_t)moffset, bsize);
+		sched_pin();
+		sf = sf_buf_alloc(m, SFB_CPUPRIVATE);
+		ma = (char *)sf_buf_kva(sf);
+		error = uiomove(ma + moffset, bsize - moffset, uio);
+		memcpy(pagebuf, ma, bsize);
+		sf_buf_free(sf);
+		sched_unpin();
+#if __FreeBSD_version >= 1000030
+		VM_OBJECT_WLOCK(vp->v_object);
+		vm_page_wakeup(m);
+		VM_OBJECT_WUNLOCK(vp->v_object);
+#else
+		VM_OBJECT_LOCK(vp->v_object);
+		vm_page_wakeup(m);
+		VM_OBJECT_UNLOCK(vp->v_object);
+#endif
+		if (error != 0) {
+			MPASS(error != EJUSTRETURN);
+			return (error);
+		}
+		return (EJUSTRETURN);
+	}
+#if __FreeBSD_version >= 1000030
+	if (vm_page_is_cached(vp->v_object, idx))
+#else
+	if (__predict_false(vp->v_object->cache != NULL))
+#endif
+	{
+		PEFSDEBUG("pefs_write: free cache: 0x%jx\n",
+		    uio->uio_offset - moffset);
+		vm_page_cache_free(vp->v_object, idx, idx + 1);
+	}
+	MPASS(m == NULL ||
+	    !vm_page_is_valid(m, moffset, bsize - moffset));
+#if __FreeBSD_version >= 1000030
+	VM_OBJECT_WUNLOCK(vp->v_object);
+#else
+	VM_OBJECT_UNLOCK(vp->v_object);
+#endif
+	return (0);
+}
+
+static int
+pefs_write(struct vop_write_args *ap)
+{
+	struct vnode *vp = ap->a_vp;
+	struct vnode *lvp = PEFS_LOWERVP(vp);
+	struct ucred *cred = ap->a_cred;
+	struct uio *uio = ap->a_uio;
+	struct pefs_node *pn = VP_TO_PN(vp);
+	u_quad_t fsize;
+	int ioflag = ap->a_ioflag;
+	int error;
+
+	if (vp->v_type == VDIR)
+		return (EISDIR);
+	if (vp->v_type == VFIFO)
+		return (VOP_WRITE(lvp, uio, ioflag, cred));
+	if (vp->v_type != VREG)
+		return (EOPNOTSUPP);
+	if (uio->uio_resid == 0)
+		return (0);
+	if (uio->uio_offset < 0)
+		return (EINVAL);
+
+	if ((pn->pn_flags & PN_HASKEY) == 0) {
+		if (pefs_no_keys(vp))
+			return (EROFS);
+		return (VOP_WRITE(lvp, uio, ioflag, cred));
+	}
+
+	error = pefs_getsize(vp, &fsize, cred);
+	if (error != 0)
+		return (error);
+
+	if (ioflag & IO_APPEND) {
+		uio->uio_offset = fsize;
+		ioflag &= ~IO_APPEND;
+	}
+
+	if (uio->uio_offset > fsize) {
+		error = pefs_truncate(vp, uio->uio_offset, cred);
+		if (error != 0)
+			return (error);
+		fsize = uio->uio_offset;
+	}
+
+	error = pefs_write_int(vp, uio, ioflag, cred, fsize);
+
+	return (error);
+}
+
+static int
+pefs_write_int(struct vnode *vp, struct uio *uio, int ioflag,
+    struct ucred *cred, u_quad_t fsize)
+{
+	struct vnode *lvp = PEFS_LOWERVP(vp);
+	struct uio *puio;
+	struct pefs_node *pn = VP_TO_PN(vp);
+	struct pefs_chunk pc;
+	u_quad_t nsize;
+	off_t poffset;
+	ssize_t bmaxsize, bsize, bskip;
+	int error = 0, mapped;
+
+	MPASS(vp->v_type == VREG);
+	MPASS(uio->uio_resid != 0);
+	MPASS(uio->uio_offset >= 0);
+
+	mapped = pefs_ismapped(vp);
+	if (mapped != 0)
+		bmaxsize = PEFS_SECTOR_SIZE;
+	else
+		bmaxsize = pefs_bufsize(uio, DFLTPHYS);
+	bsize = bmaxsize;
+
+	nsize = fsize;
+	MPASS(uio->uio_offset <= fsize);
+	if (uio->uio_offset + uio->uio_resid > nsize) {
+		PEFSDEBUG("pefs_write: extend: 0x%jx (old size: 0x%jx)\n",
+		    uio->uio_offset + uio->uio_resid, nsize);
+		nsize = uio->uio_offset + uio->uio_resid;
+		vnode_pager_setsize(vp, nsize);
+	}
+
+	pefs_chunk_create(&pc, pn, bsize);
+	while (uio->uio_resid > 0) {
+		bskip = uio->uio_offset & PEFS_SECTOR_MASK;
+		poffset = uio->uio_offset - bskip;
+		if (bskip != 0)
+			bsize = PEFS_SECTOR_SIZE;
+		else {
+			/* Exclude last incomplete page from the chunk */
+			bsize = rounddown(uio->uio_resid, PEFS_SECTOR_SIZE);
+			if (bsize == 0)
+				bsize = PEFS_SECTOR_SIZE;
+			bsize = qmin(bsize, bmaxsize);
+		}
+		bsize = qmin(nsize - poffset, bsize);
+		pefs_chunk_setsize(&pc, bsize);
+
+		if (mapped != 0) {
+			error = pefs_writemapped(vp, uio, bsize, pc.pc_base);
+			if (error == EJUSTRETURN) {
+				error = 0;
+				goto lower_update;
+			} else if (error != 0) {
+				PEFSDEBUG("pefs_write: mapped write error: "
+				    "offset=0x%jx resid=%0jx\n",
+				    uio->uio_offset, uio->uio_resid);
+				break;
+			}
+		}
+		if (bskip != 0 || (bskip + uio->uio_resid) < PEFS_SECTOR_SIZE) {
+			MPASS(pc.pc_size <= PEFS_SECTOR_SIZE);
+			puio = pefs_chunk_uio(&pc, poffset, UIO_READ);
+			if (poffset < fsize) {
+				error = pefs_read_int(vp, puio, IO_UNIT, cred,
+				    qmax(fsize, uio->uio_offset));
+				if (error != 0)
+					break;
+			}
+			if (puio->uio_resid != 0) {
+				PEFSDEBUG("pefs_write: clear buffer: "
+				    "resid=0x%jx fsize=0x%jx nsize=0x%jx "
+				    "poffset=0x%jx offset=0x%jx bsize=0x%jx\n",
+				    puio->uio_resid, fsize, nsize, poffset,
+				    uio->uio_offset, pc.pc_size);
+				MPASS(puio->uio_offset == fsize ||
+				    puio->uio_offset == poffset);
+				bzero(puio->uio_iov[0].iov_base,
+				    puio->uio_resid);
+			}
+		}
+		error = pefs_chunk_copy(&pc, bskip, uio);
+		if (error != 0) {
+			PEFSDEBUG("pefs_write: chunk copy error: "
+			    "offset=0x%jx resid=%0jx\n",
+			    uio->uio_offset, uio->uio_resid);
+			break;
+		}
+lower_update:
+		PEFSDEBUG("pefs_write: mapped=%d offset=0x%jx size=0x%jx\n",
+		    mapped, poffset + bskip, (intmax_t)bsize - bskip);
+		pefs_data_encrypt(&pn->pn_tkey, poffset, &pc);
+		puio = pefs_chunk_uio(&pc, poffset, uio->uio_rw);
+
+		/* IO_APPEND handled above to prevent offset change races. */
+		error = VOP_WRITE(lvp, puio, ioflag, cred);
+		if (error != 0) {
+			/*
+			 * XXX Original uio is not preserved thus can't be
+			 * restored. Cloning entire uio structure is too
+			 * inefficient. uio shouldn't be reused after error, but
+			 * uid_resid and uio_offset should remain valid.
+			 * Partially destroy uio, so that using it further
+			 * would result in panic.
+			 *
+			 * Correct solution is to implement uiocopy that
+			 * doesn't change uio and iovec.
+			 */
+			PEFSDEBUG("pefs_write: lower level write error: "
+			    "offset=0x%jx resid=%0jx\n",
+			    uio->uio_offset, uio->uio_resid);
+			uio->uio_iov = NULL;
+			uio->uio_iovcnt = 0;
+			uio->uio_rw = -1;
+			uio->uio_resid += uio->uio_offset - (poffset + bsize);
+			uio->uio_offset = poffset + bsize;
+			break;
+		}
+		MPASS(puio->uio_resid == 0);
+	}
+	pefs_chunk_free(&pc, pn);
+
+	return (error);
+}
+
+static int
+pefs_setkey(struct vnode *vp, struct pefs_key *pk, struct ucred *cred,
+    struct thread *td)
+{
+	struct vnode *dvp, *ldvp, *lvp;
+	struct componentname cn;
+	struct pefs_node *pn = VP_TO_PN(vp);
+	struct pefs_enccn fenccn, tenccn;
+	char *namebuf;
+	int error, namelen;
+
+	pefs_enccn_init(&fenccn);
+	pefs_enccn_init(&tenccn);
+	if ((pn->pn_flags & PN_HASKEY) == 0 || vp->v_type != VDIR ||
+	    pn->pn_tkey.ptk_key == pk) {
+		PEFSDEBUG("pefs_setkey failed: haskey=%d; type=%d; pk=%d\n",
+		    (pn->pn_flags & PN_HASKEY) == 0, vp->v_type != VDIR,
+		    pn->pn_tkey.ptk_key == pk);
+		return (EINVAL);
+	}
+
+	namebuf = malloc(MAXNAMLEN, M_PEFSBUF, M_WAITOK | M_ZERO);
+	namelen = MAXNAMLEN - 1;
+	dvp = vp;
+	vref(vp);
+	error = vn_vptocnp(&dvp, cred, namebuf, &namelen);
+	if (error != 0) {
+		PEFSDEBUG("pefs_setkey: vn_vptocnp failed: error=%d; vp=%p\n",
+		    error, vp);
+		free(namebuf, M_PEFSBUF);
+		return (error);
+	}
+	bzero(&cn, sizeof(cn));
+	cn.cn_thread = td;
+	cn.cn_cred = cred;
+	cn.cn_flags = LOCKPARENT | LOCKLEAF | ISLASTCN | SAVENAME;
+	cn.cn_lkflags = LK_EXCLUSIVE;
+	cn.cn_pnbuf = cn.cn_nameptr = namebuf + namelen;
+	cn.cn_namelen = MAXNAMLEN - 1 - namelen;
+
+	MPASS(dvp->v_mount == vp->v_mount);
+	vn_lock(dvp, LK_EXCLUSIVE | LK_RETRY);
+	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY);
+
+	error = VOP_ACCESS(vp, VWRITE, cred, td);
+	if (error == 0) {
+		cn.cn_nameiop = DELETE;
+		error = pefs_enccn_get(&fenccn, dvp, vp, &cn);
+	}
+	if (error != 0) {
+		VOP_UNLOCK(vp, 0);
+#if __FreeBSD_version >= 900501
+		vput(dvp); /* vref by vn_vptocnp */
+#else
+		VOP_UNLOCK(dvp, 0);
+		vdrop(dvp); /* vrele by vn_vptocnp */
+#endif
+		PEFSDEBUG("pefs_setkey: pefs_enccn_get failed: %d\n", error);
+		goto out;
+	}
+	cn.cn_nameiop = RENAME;
+	error = pefs_enccn_create(&tenccn, pk, NULL, &cn);
+	if (error != 0) {
+		VOP_UNLOCK(vp, 0);
+#if __FreeBSD_version >= 900501
+		vput(dvp); /* vref by vn_vptocnp */
+#else
+		VOP_UNLOCK(dvp, 0);
+		vdrop(dvp); /* vrele by vn_vptocnp */
+#endif
+		pefs_enccn_free(&fenccn);
+		goto out;
+	}
+	PEFSDEBUG("pefs_setkey: fromname=%s; key=%p\n",
+	    fenccn.pec_cn.cn_nameptr, fenccn.pec_tkey.ptk_key);
+	PEFSDEBUG("pefs_setkey: toname=%s; key=%p\n",
+	    tenccn.pec_cn.cn_nameptr, tenccn.pec_tkey.ptk_key);
+	ldvp = PEFS_LOWERVP(dvp);
+	VOP_UNLOCK(PEFS_LOWERVP(vp), 0);
+	error = VOP_LOOKUP(ldvp, &lvp, &fenccn.pec_cn);
+	if (error != 0) {
+		PEFSDEBUG("pefs_setkey: lookup faild: %s\n",
+		    fenccn.pec_cn.cn_nameptr);
+#if __FreeBSD_version >= 900501
+		vput(dvp); /* vref by vn_vptocnp */
+#else
+		VOP_UNLOCK(dvp, 0);
+		vdrop(dvp); /* vrele by vn_vptocnp */
+#endif
+		goto out_enccn;
+	}
+	MPASS(lvp == PEFS_LOWERVP(vp));
+	VOP_UNLOCK(PEFS_LOWERVP(vp), 0);
+	error = VOP_LOOKUP(ldvp, &lvp, &tenccn.pec_cn);
+	if (error != EJUSTRETURN) {
+		PEFSDEBUG("pefs_setkey: lookup faild: %s\n",
+		    tenccn.pec_cn.cn_nameptr);
+#if __FreeBSD_version >= 900501
+		vput(dvp); /* vref by vn_vptocnp */
+#else
+		VOP_UNLOCK(dvp, 0);
+		vdrop(dvp); /* vrele by vn_vptocnp */
+#endif
+		error = EBUSY;
+		goto out_enccn;
+	}
+	vref(ldvp);
+	vref(ldvp);
+	error = VOP_RENAME(ldvp, PEFS_LOWERVP(vp), &fenccn.pec_cn, ldvp, NULL,
+	    &tenccn.pec_cn);
+#if __FreeBSD_version >= 900501
+	vrele(dvp); /* vref by vn_vptocnp */
+#else
+	vdrop(dvp); /* vrele by vn_vptocnp */
+#endif
+	if (error == 0) {
+		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY);
+		vgone(vp);
+		VOP_UNLOCK(vp, 0);
+	}
+
+out_enccn:
+	pefs_enccn_free(&fenccn);
+	pefs_enccn_free(&tenccn);
+
+out:
+	free(namebuf, M_PEFSBUF);
+
+	return (error);
+}
+static int
+pefs_ioctl(struct vop_ioctl_args *ap)
+{
+	struct vnode *vp = ap->a_vp;
+	struct pefs_xkey *xk = ap->a_data;
+	struct ucred *cred = ap->a_cred;
+	struct thread *td = ap->a_td;
+	struct mount *mp = vp->v_mount;
+	struct pefs_mount *pm = VFS_TO_PEFS(mp);
+	struct pefs_node *pn;
+	struct pefs_key *pk;
+	int error = 0, i;
+
+	if (mp->mnt_cred->cr_uid != cred->cr_uid) {
+		error = priv_check_cred(cred, PRIV_VFS_ADMIN, 0);
+		if (error != 0 && (mp->mnt_flag & MNT_RDONLY) == 0) {
+			vn_lock(pm->pm_rootvp, LK_SHARED | LK_RETRY);
+			error = VOP_ACCESS(mp->mnt_vnodecovered, VWRITE,
+			    cred, td);
+			VOP_UNLOCK(pm->pm_rootvp, 0);
+		}
+		if (error != 0)
+			return (error);
+	}
+
+	/*
+	 * Recycle all unused vnodes after adding/deleting keys to cleanup
+	 * caches.
+	 */
+	switch (ap->a_command) {
+	case PEFS_GETKEY:
+		PEFSDEBUG("pefs_ioctl: get key: pm=%p, pxk_index=%d\n",
+		    pm, xk->pxk_index);
+		mtx_lock(&pm->pm_keys_lock);
+		i = 0;
+		TAILQ_FOREACH(pk, &pm->pm_keys, pk_entry) {
+			if (i++ == xk->pxk_index) {
+				memcpy(xk->pxk_keyid, pk->pk_keyid,
+				    PEFS_KEYID_SIZE);
+				xk->pxk_alg = pk->pk_algid;
+				xk->pxk_keybits = pk->pk_keybits;
+				break;
+			}
+		}
+		mtx_unlock(&pm->pm_keys_lock);
+		if (pk == NULL)
+			error = ENOENT;
+		break;
+	case PEFS_GETNODEKEY:
+		PEFSDEBUG("pefs_ioctl: get key: %8D\n", xk->pxk_keyid, "");
+		pn = VP_TO_PN(vp);
+		if ((pn->pn_flags & PN_HASKEY) != 0) {
+			mtx_lock(&pm->pm_keys_lock);
+			pk = pn->pn_tkey.ptk_key;
+			memcpy(xk->pxk_keyid, pk->pk_keyid, PEFS_KEYID_SIZE);
+			xk->pxk_alg = pk->pk_algid;
+			xk->pxk_keybits = pk->pk_keybits;
+			mtx_unlock(&pm->pm_keys_lock);
+		} else {
+			PEFSDEBUG("pefs_ioctl: key not found\n");
+			error = ENOENT;
+		}
+		break;
+	case PEFS_SETKEY:
+		PEFSDEBUG("pefs_ioctl: set key: %8D\n", xk->pxk_keyid, "");
+		mtx_lock(&pm->pm_keys_lock);
+		pk = pefs_key_lookup(pm, xk->pxk_keyid);
+		if (pk != NULL)
+			pefs_key_ref(pk);
+		mtx_unlock(&pm->pm_keys_lock);
+		if (pk != NULL) {
+			error = pefs_setkey(vp, pk, cred, td);
+			pefs_key_release(pk);
+		} else {
+			PEFSDEBUG("pefs_ioctl: key not found\n");
+			error = ENOENT;
+		}
+		break;
+	case PEFS_ADDKEY:
+		PEFSDEBUG("pefs_ioctl: add key: %8D\n", xk->pxk_keyid, "");
+		pk = pefs_key_get(xk->pxk_alg, xk->pxk_keybits, xk->pxk_key,
+		    xk->pxk_keyid);
+		if (pk == NULL) {
+			PEFSDEBUG("pefs_key_get: error\n");
+			error = ENOENT;
+			break;
+		}
+		error = pefs_key_add(pm, xk->pxk_index, pk);
+		if (error == 0)
+			pefs_flushkey(mp, td, 0, NULL);
+		else
+			pefs_key_release(pk);
+		break;
+	case PEFS_DELKEY:
+		PEFSDEBUG("pefs_ioctl: del key\n");
+		mtx_lock(&pm->pm_keys_lock);
+		pk = pefs_key_lookup(pm, xk->pxk_keyid);
+		if (pk != NULL) {
+			pefs_key_ref(pk);
+			pefs_key_remove(pm, pk);
+			mtx_unlock(&pm->pm_keys_lock);
+			pefs_flushkey(mp, td, 0, pk);
+			pefs_key_release(pk);
+		} else {
+			mtx_unlock(&pm->pm_keys_lock);
+			error = ENOENT;
+		}
+		break;
+	case PEFS_FLUSHKEYS:
+		PEFSDEBUG("pefs_ioctl: flush keys\n");
+		if (pefs_key_remove_all(pm))
+			pefs_flushkey(mp, td, PEFS_FLUSHKEY_ALL, NULL);
+		break;
+	default:
+		error = ENOTTY;
+		break;
+	};
+
+	return (error);
+}
+
+static int
+pefs_pathconf(struct vop_pathconf_args *ap)
+{
+	struct vnode *vp = ap->a_vp;
+	int error, v;
+
+	switch (ap->a_name) {
+	case _PC_MIN_HOLE_SIZE:
+		return (EINVAL);
+	}
+
+	error = VOP_PATHCONF(PEFS_LOWERVP(vp), ap->a_name, ap->a_retval);
+	if (error != 0)
+		return (error);
+
+	switch (ap->a_name) {
+	case _PC_NAME_MAX:
+		/*
+		 * ntop(csum + roundup(tweak + name, bs) = maxname
+		 * roundup(tweak + name, bs) = pton(maxname) - csum
+		 * name = rounddown(pton(maxname) - csum, bs) - tweak
+		 */
+		v = PEFS_NAME_PTON_SIZE(*ap->a_retval);
+		v = rounddown(v - PEFS_NAME_CSUM_SIZE, PEFS_NAME_BLOCK_SIZE);
+		v = v - PEFS_TWEAK_SIZE;
+		*ap->a_retval = v;
+		break;
+	case _PC_SYMLINK_MAX:
+		v = PEFS_NAME_PTON_SIZE(*ap->a_retval - 1);
+		*ap->a_retval = v;
+		break;
+	}
+
+	return (0);
+}
+
+/*
+ * Global vfs data structures
+ */
+struct vop_vector pefs_vnodeops = {
+	.vop_default =		&default_vnodeops,
+	.vop_access =		pefs_access,
+	.vop_accessx =		pefs_accessx,
+	.vop_getacl =		pefs_getacl,
+	.vop_close =		pefs_close,
+	.vop_getattr =		pefs_getattr,
+	.vop_getwritemount =	pefs_getwritemount,
+	.vop_inactive =		pefs_inactive,
+	.vop_islocked =		vop_stdislocked,
+	.vop_lock1 =		pefs_lock,
+	.vop_open =		pefs_open,
+	.vop_print =		pefs_print,
+	.vop_reclaim =		pefs_reclaim,
+	.vop_setattr =		pefs_setattr,
+	.vop_unlock =		pefs_unlock,
+	.vop_vptocnp =		vop_stdvptocnp,
+	.vop_vptofh =		pefs_vptofh,
+	.vop_cachedlookup =	pefs_lookup,
+	.vop_lookup =		vfs_cache_lookup,
+	.vop_mkdir =		pefs_mkdir,
+	.vop_rmdir =		pefs_rmdir,
+	.vop_create =		pefs_create,
+	.vop_remove =		pefs_remove,
+	.vop_rename =		pefs_rename,
+	.vop_link =		pefs_link,
+	.vop_mknod =		pefs_mknod,
+	.vop_readdir =		pefs_readdir,
+	.vop_symlink =		pefs_symlink,
+	.vop_readlink =		pefs_readlink,
+	.vop_read =		pefs_read,
+	.vop_write =		pefs_write,
+	.vop_strategy =		VOP_PANIC,
+	.vop_bmap =		VOP_EOPNOTSUPP,
+	.vop_getpages =		vop_stdgetpages,
+	.vop_putpages =		vop_stdputpages,
+	.vop_fsync =		vop_stdfsync,
+	.vop_ioctl =		pefs_ioctl,
+	.vop_pathconf =		pefs_pathconf,
+};
diff --git sys/fs/pefs/pefs_xbase64.c sys/fs/pefs/pefs_xbase64.c
new file mode 100644
index 0000000..97d47e3
--- /dev/null
+++ sys/fs/pefs/pefs_xbase64.c
@@ -0,0 +1,186 @@
+/*
+ * Copyright (c) 1996, 1998 by Internet Software Consortium.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
+ * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
+ * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
+ * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
+ * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+ * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+/*
+ * Portions Copyright (c) 1995 by International Business Machines, Inc.
+ *
+ * International Business Machines, Inc. (hereinafter called IBM) grants
+ * permission under its copyrights to use, copy, modify, and distribute this
+ * Software with or without fee, provided that the above copyright notice and
+ * all paragraphs of this notice appear in all copies, and that the name of IBM
+ * not be used in connection with the marketing of any product incorporating
+ * the Software or modifications thereof, without specific, written prior
+ * permission.
+ *
+ * To the extent it has a right to do so, IBM grants an immunity from suit
+ * under its patents, if any, for the use, sale or manufacture of products to
+ * the extent that such products are used for performing Domain Name System
+ * dynamic updates in TCP/IP networks by means of the Software.  No immunity is
+ * granted for any product per se or for any other function of any product.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", AND IBM DISCLAIMS ALL WARRANTIES,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE.  IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL,
+ * DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE, EVEN
+ * IF IBM IS APPRISED OF THE POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/lock.h>
+#include <sys/libkern.h>
+#include <sys/mount.h>
+#include <sys/vnode.h>
+
+#include <fs/pefs/pefs.h>
+
+#define	Assert(Cond)		(void)0
+
+/*
+ * Algorithm is standard base64 with few exceptions:
+ *  - file system friendly alphabet
+ *  - no paddings and whitespace skip
+ */
+static const char Base64[] =
+	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+_";
+
+int
+pefs_name_ntop(u_char const *src, size_t srclength,
+    char *target, size_t targsize)
+{
+	size_t datalength = 0;
+	u_char input[3];
+	u_char output[4];
+	size_t i;
+
+	while (2 < srclength) {
+		input[0] = *src++;
+		input[1] = *src++;
+		input[2] = *src++;
+		srclength -= 3;
+
+		output[0] = input[0] >> 2;
+		output[1] = ((input[0] & 0x03) << 4) + (input[1] >> 4);
+		output[2] = ((input[1] & 0x0f) << 2) + (input[2] >> 6);
+		output[3] = input[2] & 0x3f;
+		Assert(output[0] < 64);
+		Assert(output[1] < 64);
+		Assert(output[2] < 64);
+		Assert(output[3] < 64);
+
+		if (datalength + 4 > targsize)
+			return (-1);
+		target[datalength++] = Base64[output[0]];
+		target[datalength++] = Base64[output[1]];
+		target[datalength++] = Base64[output[2]];
+		target[datalength++] = Base64[output[3]];
+	}
+
+	/* Now we worry about padding. */
+	if (0 != srclength) {
+		/* Get what's left. */
+		input[0] = input[1] = input[2] = '\0';
+		for (i = 0; i < srclength; i++)
+			input[i] = *src++;
+
+		output[0] = input[0] >> 2;
+		output[1] = ((input[0] & 0x03) << 4) + (input[1] >> 4);
+		output[2] = ((input[1] & 0x0f) << 2) + (input[2] >> 6);
+		Assert(output[0] < 64);
+		Assert(output[1] < 64);
+		Assert(output[2] < 64);
+
+		if (datalength + 2 > targsize)
+			return (-1);
+		target[datalength++] = Base64[output[0]];
+		target[datalength++] = Base64[output[1]];
+		if (srclength == 2) {
+			if (datalength + 1 > targsize)
+				return (-1);
+			target[datalength++] = Base64[output[2]];
+		}
+	}
+	if (datalength >= targsize || datalength == 0)
+		return (-1);
+	target[datalength] = '\0';	/* Returned value doesn't count \0. */
+	return (datalength);
+}
+
+int
+pefs_name_pton(char const *src, size_t srclen, u_char *target, size_t targsize)
+{
+	int tarindex, state, ch;
+	char *pos;
+
+	state = 0;
+	tarindex = 0;
+
+	while ((ch = *src++) != '\0' && srclen-- > 0) {
+		if (target && (size_t)tarindex >= targsize)
+			return (-1);
+
+		pos = strchr(Base64, ch);
+		if (pos == 0)		/* A non-base64 character. */
+			return (-1);
+
+		switch (state) {
+		case 0:
+			if (target) {
+				target[tarindex] = (pos - Base64) << 2;
+			}
+			state = 1;
+			break;
+		case 1:
+			if (target) {
+				target[tarindex]   |=  (pos - Base64) >> 4;
+				if ((size_t)tarindex + 1 < targsize)
+					target[tarindex+1] =
+					    ((pos - Base64) & 0x0f) << 4 ;
+			}
+			tarindex++;
+			state = 2;
+			break;
+		case 2:
+			if (target) {
+				target[tarindex]   |=  (pos - Base64) >> 2;
+				if ((size_t)tarindex + 1 < targsize)
+					target[tarindex+1] =
+					    ((pos - Base64) & 0x03) << 6;
+			}
+			tarindex++;
+			state = 3;
+			break;
+		case 3:
+			if (target) {
+				target[tarindex] |= (pos - Base64);
+			}
+			tarindex++;
+			state = 0;
+			break;
+		default:
+			return (-1);
+		}
+	}
+
+	if (tarindex == 0)
+		return (-1);
+	return (tarindex);
+}
+
diff --git sys/fs/pefs/pefs_xts.c sys/fs/pefs/pefs_xts.c
new file mode 100644
index 0000000..c52fb33
--- /dev/null
+++ sys/fs/pefs/pefs_xts.c
@@ -0,0 +1,208 @@
+/*
+ * Copyright (c) 2007, 2008 University of Tsukuba
+ * Copyright (c) 2010 Gleb Kurtsou <gleb@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. Neither the name of the University of Tsukuba nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/param.h>
+#include <sys/endian.h>
+
+#include <fs/pefs/pefs_crypto.h>
+
+#ifdef _KERNEL
+#include <sys/libkern.h>
+#else
+#include <string.h>
+#endif
+
+#define	XTS_BLK_BYTES		16
+#define	XTS_BLK_MASK		(XTS_BLK_BYTES - 1)
+
+static __inline void
+xor128(void *dst, const void *src1, const void *src2)
+{
+	const uint64_t *s1 = (const uint64_t *)src1;
+	const uint64_t *s2 = (const uint64_t *)src2;
+	uint64_t *d = (uint64_t *)dst;
+
+	d[0] = s1[0] ^ s2[0];
+	d[1] = s1[1] ^ s2[1];
+}
+
+static __inline int
+shl128(uint64_t *d, const uint64_t *s)
+{
+	int c0, c1;
+
+	c0 = s[0] & (1ULL << 63) ? 1 : 0;
+	c1 = s[1] & (1ULL << 63) ? 1 : 0;
+	d[0] = s[0] << 1;
+	d[1] = s[1] << 1 | c0;
+
+	return (c1);
+}
+
+static __inline void
+gf_mul128(uint64_t *dst, const uint64_t *src)
+{
+	static const uint8_t gf_128_fdbk = 0x87;
+	int carry;
+
+	carry = shl128(dst, src);
+	if (carry != 0)
+		((uint8_t *)dst)[0] ^= gf_128_fdbk;
+}
+
+static __inline void
+xts_fullblock(algop_crypt_t *data_crypt, const struct pefs_session *ses,
+    const struct pefs_ctx *data_ctx,
+    uint64_t *tweak, const uint8_t *src, uint8_t *dst)
+{
+	xor128(dst, src, tweak);
+	data_crypt(ses, data_ctx, dst, dst);
+	xor128(dst, dst, tweak);
+	gf_mul128(tweak, tweak);
+}
+
+static __inline void
+xts_lastblock(algop_crypt_t *data_crypt, const struct pefs_session *ses,
+    const struct pefs_ctx *data_ctx,
+    uint64_t *tweak, const uint8_t *src, uint8_t *dst, int len)
+{
+	uint8_t b[XTS_BLK_BYTES];
+
+	dst -= XTS_BLK_BYTES;			/* m - 1 */
+	memcpy(b, dst, XTS_BLK_BYTES);
+	memcpy(b, src, len);
+	memcpy(dst + XTS_BLK_BYTES, dst, len);
+
+	xor128(dst, b, tweak);
+	data_crypt(ses, data_ctx, dst, dst);
+	xor128(dst, dst, tweak);
+}
+
+static __inline void
+xts_smallblock(const struct pefs_alg *alg, const struct pefs_session *ses,
+    const struct pefs_ctx *data_ctx,
+    uint64_t *tweak, const uint8_t *src, uint8_t *dst, int len)
+{
+	uint8_t buf[XTS_BLK_BYTES], *p;
+
+	/*
+	 * Encryption/decryption of sectors smaller then 128 bits is not defined
+	 * by IEEE P1619 standard.
+	 * To work around it encrypt such sector in CTR mode.
+	 * CTR tweak (counter) value is XTS-tweak xor'ed with block length, i.e.
+	 * entire small block has to be reencrypted after length change.
+	 */
+	memset(buf, len, XTS_BLK_BYTES);
+	xor128(buf, buf, tweak);
+	alg->pa_encrypt(ses, data_ctx, buf, buf);
+	for (p = buf; len > 0; len--)
+		*(dst++) = *(src++) ^ *(p++);
+}
+
+static __inline void
+xts_start(const struct pefs_alg *alg, const struct pefs_session *ses,
+    const struct pefs_ctx *tweak_ctx,
+    uint64_t *tweak, uint64_t sector, const uint8_t *xtweak)
+{
+	tweak[0] = htole64(sector);
+	tweak[1] = *((const uint64_t *)xtweak);
+
+	/* encrypt the tweak */
+	alg->pa_encrypt(ses, tweak_ctx, (uint8_t *)tweak, (uint8_t *)tweak);
+}
+
+void
+pefs_xts_block_encrypt(const struct pefs_alg *alg,
+    const struct pefs_session *ses,
+    const struct pefs_ctx *tweak_ctx, const struct pefs_ctx *data_ctx,
+    uint64_t sector, const uint8_t *xtweak, int len,
+    const uint8_t *src, uint8_t *dst)
+{
+	uint64_t tweak[XTS_BLK_BYTES / 8];
+
+	xts_start(alg, ses, tweak_ctx, tweak, sector, xtweak);
+
+	if (len < XTS_BLK_BYTES) {
+		xts_smallblock(alg, ses, data_ctx, tweak, src, dst, len);
+		return;
+	}
+
+	while (len >= XTS_BLK_BYTES) {
+		xts_fullblock(alg->pa_encrypt, ses, data_ctx, tweak, src, dst);
+		dst += XTS_BLK_BYTES;
+		src += XTS_BLK_BYTES;
+		len -= XTS_BLK_BYTES;
+	}
+
+	if (len != 0)
+		xts_lastblock(alg->pa_encrypt, ses, data_ctx, tweak,
+		    src, dst, len);
+}
+
+void
+pefs_xts_block_decrypt(const struct pefs_alg *alg,
+    const struct pefs_session *ses,
+    const struct pefs_ctx *tweak_ctx, const struct pefs_ctx *data_ctx,
+    uint64_t sector, const uint8_t *xtweak, int len,
+    const uint8_t *src, uint8_t *dst)
+{
+	uint64_t tweak[XTS_BLK_BYTES / 8];
+	uint64_t prevtweak[XTS_BLK_BYTES / 8];
+
+	xts_start(alg, ses, tweak_ctx, tweak, sector, xtweak);
+
+	if (len < XTS_BLK_BYTES) {
+		xts_smallblock(alg, ses, data_ctx, tweak, src, dst, len);
+		return;
+	}
+
+	if ((len & XTS_BLK_MASK) != 0)
+		len -= XTS_BLK_BYTES;
+
+	while (len >= XTS_BLK_BYTES) {
+		xts_fullblock(alg->pa_decrypt, ses, data_ctx, tweak, src, dst);
+		dst += XTS_BLK_BYTES;
+		src += XTS_BLK_BYTES;
+		len -= XTS_BLK_BYTES;
+	}
+
+	if (len != 0) {
+		len += XTS_BLK_BYTES;
+		prevtweak[0] = tweak[0];
+		prevtweak[1] = tweak[1];
+		gf_mul128(tweak, tweak);
+		xts_fullblock(alg->pa_decrypt, ses, data_ctx, tweak, src, dst);
+		dst += XTS_BLK_BYTES;
+		src += XTS_BLK_BYTES;
+		len -= XTS_BLK_BYTES;
+		xts_lastblock(alg->pa_decrypt, ses, data_ctx, prevtweak,
+		    src, dst, len);
+	}
+}
diff --git sys/fs/pefs/vmac.c sys/fs/pefs/vmac.c
new file mode 100644
index 0000000..47de01a
--- /dev/null
+++ sys/fs/pefs/vmac.c
@@ -0,0 +1,648 @@
+/* --------------------------------------------------------------------------
+ * VMAC and VHASH Implementation by Ted Krovetz (tdk@acm.org) and Wei Dai.
+ * This implementation is herby placed in the public domain.
+ * The authors offers no warranty. Use at your own risk.
+ * Please send bug reports to the authors.
+ * Last modified: 17 APR 08, 1700 PDT
+ * ----------------------------------------------------------------------- */
+
+#include <sys/param.h>
+#include <sys/endian.h>
+#include <sys/stdint.h>
+
+#include <crypto/rijndael/rijndael.h>
+#include <crypto/rijndael/rijndael_local.h>
+
+#include <fs/pefs/vmac.h>
+
+#if defined(__x86_64__) || defined(__ia64__) || defined(__sparc64__)
+#define VMAC_ARCH_64 1
+#else
+#define VMAC_ARCH_64 0
+#endif
+
+#if _BYTE_ORDER == _LITTLE_ENDIAN
+#define VMAC_ARCH_BIG_ENDIAN 0
+#else
+#define VMAC_ARCH_BIG_ENDIAN 1
+#endif
+
+#define aes_encryption(in,out,int_key)                  \
+	    	rijndaelEncrypt((u32 *)(int_key),           \
+	                        ((VMAC_KEY_LEN/32)+6),      \
+	    				    (u8 *)(in), (u8 *)(out))
+#define aes_key_setup(user_key,int_key)                 \
+	    	rijndaelKeySetupEnc((u32 *)(int_key),       \
+	    	                    (u8 *)(user_key), \
+	    	                    VMAC_KEY_LEN)
+
+/* ----------------------------------------------------------------------- */
+/* Constants and masks                                                     */
+
+const uint64_t p64   = UINT64_C(0xfffffffffffffeff);  /* 2^64 - 257 prime  */
+const uint64_t m62   = UINT64_C(0x3fffffffffffffff);  /* 62-bit mask       */
+const uint64_t m63   = UINT64_C(0x7fffffffffffffff);  /* 63-bit mask       */
+const uint64_t m64   = UINT64_C(0xffffffffffffffff);  /* 64-bit mask       */
+const uint64_t mpoly = UINT64_C(0x1fffffff1fffffff);  /* Poly key mask     */
+
+/* ----------------------------------------------------------------------- *
+ * The following routines are used in this implementation. They are
+ * written via macros to simulate zero-overhead call-by-reference.
+ * All have default implemantations for when they are not defined in an
+ * architecture-specific manner.
+ *
+ * MUL64: 64x64->128-bit multiplication
+ * PMUL64: assumes top bits cleared on inputs
+ * ADD128: 128x128->128-bit addition
+ * GET_REVERSED_64: load and byte-reverse 64-bit word  
+ * ----------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------- */
+/* Default implementations, if not defined above                           */
+/* ----------------------------------------------------------------------- */
+
+#ifndef ADD128
+#define ADD128(rh,rl,ih,il)                                              \
+    {   uint64_t _il = (il);                                             \
+        (rl) += (_il);                                                   \
+        if ((rl) < (_il)) (rh)++;                                        \
+        (rh) += (ih);                                                    \
+    }
+#endif
+
+#ifndef MUL32
+#define MUL32(i1,i2)    ((uint64_t)(uint32_t)(i1)*(uint32_t)(i2))
+#endif
+
+#ifndef PMUL64              /* rh may not be same as i1 or i2 */
+#define PMUL64(rh,rl,i1,i2) /* Assumes m doesn't overflow     */         \
+    {   uint64_t _i1 = (i1), _i2 = (i2);                                 \
+        uint64_t m = MUL32(_i1,_i2>>32) + MUL32(_i1>>32,_i2);            \
+        rh         = MUL32(_i1>>32,_i2>>32);                             \
+        rl         = MUL32(_i1,_i2);                                     \
+        ADD128(rh,rl,(m >> 32),(m << 32));                               \
+    }
+#endif
+
+#ifndef MUL64
+#define MUL64(rh,rl,i1,i2)                                               \
+    {   uint64_t _i1 = (i1), _i2 = (i2);                                 \
+        uint64_t m1= MUL32(_i1,_i2>>32);                                 \
+        uint64_t m2= MUL32(_i1>>32,_i2);                                 \
+        rh         = MUL32(_i1>>32,_i2>>32);                             \
+        rl         = MUL32(_i1,_i2);                                     \
+        ADD128(rh,rl,(m1 >> 32),(m1 << 32));                             \
+        ADD128(rh,rl,(m2 >> 32),(m2 << 32));                             \
+    }
+#endif
+
+#ifndef GET_REVERSED_64
+#define GET_REVERSED_64(p) bswap64(*(uint64_t *)(p)) 
+#endif
+
+/* ----------------------------------------------------------------------- */
+
+#if (VMAC_PREFER_BIG_ENDIAN)
+#  define get64PE get64BE
+#else
+#  define get64PE get64LE
+#endif
+
+#if (VMAC_ARCH_BIG_ENDIAN)
+#  define get64BE(ptr) (*(uint64_t *)(ptr))
+#  define get64LE(ptr) GET_REVERSED_64(ptr)
+#else /* assume little-endian */
+#  define get64BE(ptr) GET_REVERSED_64(ptr)
+#  define get64LE(ptr) (*(uint64_t *)(ptr))
+#endif
+
+
+/* --------------------------------------------------------------------- *
+ * For highest performance the L1 NH and L2 polynomial hashes should be
+ * carefully implemented to take advantage of one's target architechture.
+ * Here these two hash functions are defined multiple time; once for
+ * 64-bit architectures, once for 32-bit SSE2 architectures, and once
+ * for the rest (32-bit) architectures.
+ * For each, nh_16 *must* be defined (works on multiples of 16 bytes).
+ * Optionally, nh_vmac_nhbytes can be defined (for multiples of
+ * VMAC_NHBYTES), and nh_16_2 and nh_vmac_nhbytes_2 (versions that do two
+ * NH computations at once).
+ * --------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------- */
+#if VMAC_ARCH_64
+/* ----------------------------------------------------------------------- */
+
+#define nh_16(mp, kp, nw, rh, rl)                                            \
+{   int i; uint64_t th, tl;                                                  \
+    rh = rl = 0;                                                             \
+    for (i = 0; i < nw; i+= 2) {                                             \
+        MUL64(th,tl,get64PE((mp)+i  )+(kp)[i  ],get64PE((mp)+i+1)+(kp)[i+1]);\
+        ADD128(rh,rl,th,tl);                                                 \
+    }                                                                        \
+}
+#define nh_16_2(mp, kp, nw, rh, rl, rh1, rl1)                                \
+{   int i; uint64_t th, tl;                                                  \
+    rh1 = rl1 = rh = rl = 0;                                                 \
+    for (i = 0; i < nw; i+= 2) {                                             \
+        MUL64(th,tl,get64PE((mp)+i  )+(kp)[i  ],get64PE((mp)+i+1)+(kp)[i+1]);\
+        ADD128(rh,rl,th,tl);                                                 \
+        MUL64(th,tl,get64PE((mp)+i  )+(kp)[i+2],get64PE((mp)+i+1)+(kp)[i+3]);\
+        ADD128(rh1,rl1,th,tl);                                               \
+    }                                                                        \
+}
+
+#if (VMAC_NHBYTES >= 64) /* These versions do 64-bytes of message at a time */
+#define nh_vmac_nhbytes(mp, kp, nw, rh, rl)                                  \
+{   int i; uint64_t th, tl;                                                  \
+    rh = rl = 0;                                                             \
+    for (i = 0; i < nw; i+= 8) {                                             \
+        MUL64(th,tl,get64PE((mp)+i  )+(kp)[i  ],get64PE((mp)+i+1)+(kp)[i+1]);\
+        ADD128(rh,rl,th,tl);                                                 \
+        MUL64(th,tl,get64PE((mp)+i+2)+(kp)[i+2],get64PE((mp)+i+3)+(kp)[i+3]);\
+        ADD128(rh,rl,th,tl);                                                 \
+        MUL64(th,tl,get64PE((mp)+i+4)+(kp)[i+4],get64PE((mp)+i+5)+(kp)[i+5]);\
+        ADD128(rh,rl,th,tl);                                                 \
+        MUL64(th,tl,get64PE((mp)+i+6)+(kp)[i+6],get64PE((mp)+i+7)+(kp)[i+7]);\
+        ADD128(rh,rl,th,tl);                                                 \
+    }                                                                        \
+}
+#define nh_vmac_nhbytes_2(mp, kp, nw, rh, rl, rh1, rl1)                      \
+{   int i; uint64_t th, tl;                                                  \
+    rh1 = rl1 = rh = rl = 0;                                                 \
+    for (i = 0; i < nw; i+= 8) {                                             \
+        MUL64(th,tl,get64PE((mp)+i  )+(kp)[i  ],get64PE((mp)+i+1)+(kp)[i+1]);\
+        ADD128(rh,rl,th,tl);                                                 \
+        MUL64(th,tl,get64PE((mp)+i  )+(kp)[i+2],get64PE((mp)+i+1)+(kp)[i+3]);\
+        ADD128(rh1,rl1,th,tl);                                               \
+        MUL64(th,tl,get64PE((mp)+i+2)+(kp)[i+2],get64PE((mp)+i+3)+(kp)[i+3]);\
+        ADD128(rh,rl,th,tl);                                                 \
+        MUL64(th,tl,get64PE((mp)+i+2)+(kp)[i+4],get64PE((mp)+i+3)+(kp)[i+5]);\
+        ADD128(rh1,rl1,th,tl);                                               \
+        MUL64(th,tl,get64PE((mp)+i+4)+(kp)[i+4],get64PE((mp)+i+5)+(kp)[i+5]);\
+        ADD128(rh,rl,th,tl);                                                 \
+        MUL64(th,tl,get64PE((mp)+i+4)+(kp)[i+6],get64PE((mp)+i+5)+(kp)[i+7]);\
+        ADD128(rh1,rl1,th,tl);                                               \
+        MUL64(th,tl,get64PE((mp)+i+6)+(kp)[i+6],get64PE((mp)+i+7)+(kp)[i+7]);\
+        ADD128(rh,rl,th,tl);                                                 \
+        MUL64(th,tl,get64PE((mp)+i+6)+(kp)[i+8],get64PE((mp)+i+7)+(kp)[i+9]);\
+        ADD128(rh1,rl1,th,tl);                                               \
+    }                                                                        \
+}
+#endif
+
+#define poly_step(ah, al, kh, kl, mh, ml)                   \
+{   uint64_t t1h, t1l, t2h, t2l, t3h, t3l, z=0;             \
+    /* compute ab*cd, put bd into result registers */       \
+    PMUL64(t3h,t3l,al,kh);                                  \
+    PMUL64(t2h,t2l,ah,kl);                                  \
+    PMUL64(t1h,t1l,ah,2*kh);                                \
+    PMUL64(ah,al,al,kl);                                    \
+    /* add 2 * ac to result */                              \
+    ADD128(ah,al,t1h,t1l);                                  \
+    /* add together ad + bc */                              \
+    ADD128(t2h,t2l,t3h,t3l);                                \
+    /* now (ah,al), (t2l,2*t2h) need summing */             \
+    /* first add the high registers, carrying into t2h */   \
+    ADD128(t2h,ah,z,t2l);                                   \
+    /* double t2h and add top bit of ah */                  \
+    t2h = 2 * t2h + (ah >> 63);                             \
+    ah &= m63;                                              \
+    /* now add the low registers */                         \
+    ADD128(ah,al,mh,ml);                                    \
+    ADD128(ah,al,z,t2h);                                    \
+}
+
+/* ----------------------------------------------------------------------- */
+#else /* not VMAC_ARCH_64 and not SSE2 */
+/* ----------------------------------------------------------------------- */
+
+#ifndef nh_16
+#define nh_16(mp, kp, nw, rh, rl)                                       \
+{   uint64_t t1,t2,m1,m2,t;                                             \
+    int i;                                                              \
+    rh = rl = t = 0;                                                    \
+    for (i = 0; i < nw; i+=2)  {                                        \
+        t1  = get64PE(mp+i) + kp[i];                                    \
+        t2  = get64PE(mp+i+1) + kp[i+1];                                \
+        m2  = MUL32(t1 >> 32, t2);                                      \
+        m1  = MUL32(t1, t2 >> 32);                                      \
+        ADD128(rh,rl,MUL32(t1 >> 32,t2 >> 32),MUL32(t1,t2));            \
+        rh += (uint64_t)(uint32_t)(m1 >> 32) + (uint32_t)(m2 >> 32);    \
+        t  += (uint64_t)(uint32_t)m1 + (uint32_t)m2;                    \
+    }                                                                   \
+    ADD128(rh,rl,(t >> 32),(t << 32));                                  \
+}
+#endif
+
+static void poly_step_func(uint64_t *ahi, uint64_t *alo, const uint64_t *kh,
+               const uint64_t *kl, const uint64_t *mh, const uint64_t *ml)                  
+{
+
+#if VMAC_ARCH_BIG_ENDIAN
+#define INDEX_HIGH 0
+#define INDEX_LOW 1
+#else
+#define INDEX_HIGH 1
+#define INDEX_LOW 0
+#endif
+
+#define a0 *(((uint32_t*)alo)+INDEX_LOW)
+#define a1 *(((uint32_t*)alo)+INDEX_HIGH)
+#define a2 *(((uint32_t*)ahi)+INDEX_LOW)
+#define a3 *(((uint32_t*)ahi)+INDEX_HIGH)
+#define k0 *(((const uint32_t*)kl)+INDEX_LOW)
+#define k1 *(((const uint32_t*)kl)+INDEX_HIGH)
+#define k2 *(((const uint32_t*)kh)+INDEX_LOW)
+#define k3 *(((const uint32_t*)kh)+INDEX_HIGH)
+
+    uint64_t p, q, t;
+    uint32_t t2;
+
+    p = MUL32(a3, k3);
+    p += p;
+	p += *(const uint64_t *)mh;
+    p += MUL32(a0, k2);
+    p += MUL32(a1, k1);
+    p += MUL32(a2, k0);
+    t = (uint32_t)(p);
+    p >>= 32;
+    p += MUL32(a0, k3);
+    p += MUL32(a1, k2);
+    p += MUL32(a2, k1);
+    p += MUL32(a3, k0);
+    t |= ((uint64_t)((uint32_t)p & 0x7fffffff)) << 32;
+    p >>= 31;
+    p += (uint64_t)(((const uint32_t*)ml)[INDEX_LOW]);
+    p += MUL32(a0, k0);
+    q =  MUL32(a1, k3);
+    q += MUL32(a2, k2);
+    q += MUL32(a3, k1);
+    q += q;
+    p += q;
+    t2 = (uint32_t)(p);
+    p >>= 32;
+    p += (uint64_t)(((const uint32_t*)ml)[INDEX_HIGH]);
+    p += MUL32(a0, k1);
+    p += MUL32(a1, k0);
+    q =  MUL32(a2, k3);
+    q += MUL32(a3, k2);
+    q += q;
+    p += q;
+    *(uint64_t *)(alo) = (p << 32) | t2;
+    p >>= 32;
+    *(uint64_t *)(ahi) = p + t;
+
+#undef a0
+#undef a1
+#undef a2
+#undef a3
+#undef k0
+#undef k1
+#undef k2
+#undef k3
+}
+
+#define poly_step(ah, al, kh, kl, mh, ml)   \
+        poly_step_func(&(ah), &(al), &(kh), &(kl), &(mh), &(ml))
+
+/* ----------------------------------------------------------------------- */
+#endif  /* end of specialized NH and poly definitions */
+/* ----------------------------------------------------------------------- */
+
+/* At least nh_16 is defined. Defined others as needed  here               */
+#ifndef nh_16_2
+#define nh_16_2(mp, kp, nw, rh, rl, rh2, rl2)                           \
+    nh_16(mp, kp, nw, rh, rl);                                          \
+    nh_16(mp, ((kp)+2), nw, rh2, rl2);
+#endif
+#ifndef nh_vmac_nhbytes
+#define nh_vmac_nhbytes(mp, kp, nw, rh, rl)                             \
+    nh_16(mp, kp, nw, rh, rl)
+#endif
+#ifndef nh_vmac_nhbytes_2
+#define nh_vmac_nhbytes_2(mp, kp, nw, rh, rl, rh2, rl2)                 \
+    nh_vmac_nhbytes(mp, kp, nw, rh, rl);                                \
+    nh_vmac_nhbytes(mp, ((kp)+2), nw, rh2, rl2);
+#endif
+
+/* ----------------------------------------------------------------------- */
+
+void vhash_abort(vmac_ctx_t *ctx)
+{
+    ctx->polytmp[0] = ctx->polykey[0] ;
+    ctx->polytmp[1] = ctx->polykey[1] ;
+    #if (VMAC_TAG_LEN == 128)
+    ctx->polytmp[2] = ctx->polykey[2] ;
+    ctx->polytmp[3] = ctx->polykey[3] ;
+    #endif
+    ctx->first_block_processed = 0;
+}
+
+/* ----------------------------------------------------------------------- */
+static uint64_t l3hash(uint64_t p1, uint64_t p2,
+                       uint64_t k1, uint64_t k2, uint64_t len)
+{
+    uint64_t rh, rl, t, z=0;
+
+    /* fully reduce (p1,p2)+(len,0) mod p127 */
+    t = p1 >> 63;
+    p1 &= m63;
+    ADD128(p1, p2, len, t);
+    /* At this point, (p1,p2) is at most 2^127+(len<<64) */
+    t = (p1 > m63) + ((p1 == m63) && (p2 == m64));
+    ADD128(p1, p2, z, t);
+    p1 &= m63;
+
+    /* compute (p1,p2)/(2^64-2^32) and (p1,p2)%(2^64-2^32) */
+    t = p1 + (p2 >> 32);
+    t += (t >> 32);
+    t += (uint32_t)t > 0xfffffffeu;
+    p1 += (t >> 32);
+    p2 += (p1 << 32);
+
+    /* compute (p1+k1)%p64 and (p2+k2)%p64 */
+    p1 += k1;
+    p1 += (0 - (p1 < k1)) & 257;
+    p2 += k2;
+    p2 += (0 - (p2 < k2)) & 257;
+
+    /* compute (p1+k1)*(p2+k2)%p64 */
+    MUL64(rh, rl, p1, p2);
+    t = rh >> 56;
+    ADD128(t, rl, z, rh);
+    rh <<= 8;
+    ADD128(t, rl, z, rh);
+    t += t << 8;
+    rl += t;
+    rl += (0 - (rl < t)) & 257;
+    rl += (0 - (rl > p64-1)) & 257;
+    return rl;
+}
+
+/* ----------------------------------------------------------------------- */
+
+void vhash_update(unsigned char *m,
+                  unsigned int   mbytes, /* Pos multiple of VMAC_NHBYTES */
+                  vmac_ctx_t    *ctx)
+{
+    uint64_t rh, rl, *mptr;
+    const uint64_t *kptr = (uint64_t *)ctx->nhkey;
+    int i;
+    uint64_t ch, cl;
+    uint64_t pkh = ctx->polykey[0];
+    uint64_t pkl = ctx->polykey[1];
+    #if (VMAC_TAG_LEN == 128)
+    uint64_t ch2, cl2, rh2, rl2;
+    uint64_t pkh2 = ctx->polykey[2];
+    uint64_t pkl2 = ctx->polykey[3];
+    #endif
+
+    mptr = (uint64_t *)m;
+    i = mbytes / VMAC_NHBYTES;  /* Must be non-zero */
+
+    ch = ctx->polytmp[0];
+    cl = ctx->polytmp[1];
+    #if (VMAC_TAG_LEN == 128)
+    ch2 = ctx->polytmp[2];
+    cl2 = ctx->polytmp[3];
+    #endif
+    
+    if ( ! ctx->first_block_processed) {
+        ctx->first_block_processed = 1;
+        #if (VMAC_TAG_LEN == 64)
+        nh_vmac_nhbytes(mptr,kptr,VMAC_NHBYTES/8,rh,rl);
+        #else
+        nh_vmac_nhbytes_2(mptr,kptr,VMAC_NHBYTES/8,rh,rl,rh2,rl2);
+        rh2 &= m62;
+        ADD128(ch2,cl2,rh2,rl2);
+        #endif
+        rh &= m62;
+        ADD128(ch,cl,rh,rl);
+        mptr += (VMAC_NHBYTES/sizeof(uint64_t));
+        i--;
+    }
+
+    while (i--) {
+        #if (VMAC_TAG_LEN == 64)
+        nh_vmac_nhbytes(mptr,kptr,VMAC_NHBYTES/8,rh,rl);
+        #else
+        nh_vmac_nhbytes_2(mptr,kptr,VMAC_NHBYTES/8,rh,rl,rh2,rl2);
+        rh2 &= m62;
+        poly_step(ch2,cl2,pkh2,pkl2,rh2,rl2);
+        #endif
+        rh &= m62;
+        poly_step(ch,cl,pkh,pkl,rh,rl);
+        mptr += (VMAC_NHBYTES/sizeof(uint64_t));
+    }
+
+    ctx->polytmp[0] = ch;
+    ctx->polytmp[1] = cl;
+    #if (VMAC_TAG_LEN == 128)
+    ctx->polytmp[2] = ch2;
+    ctx->polytmp[3] = cl2;
+    #endif
+}
+
+/* ----------------------------------------------------------------------- */
+
+uint64_t vhash(unsigned char m[],
+          unsigned int mbytes,
+          uint64_t *tagl,
+          vmac_ctx_t *ctx)
+{
+    uint64_t rh, rl, *mptr;
+    const uint64_t *kptr = (uint64_t *)ctx->nhkey;
+    int i, remaining;
+    uint64_t ch, cl;
+    uint64_t pkh = ctx->polykey[0];
+    uint64_t pkl = ctx->polykey[1];
+    #if (VMAC_TAG_LEN == 128)
+        uint64_t ch2, cl2, rh2, rl2;
+        uint64_t pkh2 = ctx->polykey[2];
+        uint64_t pkl2 = ctx->polykey[3];
+    #endif
+
+    mptr = (uint64_t *)m;
+    i = mbytes / VMAC_NHBYTES;
+    remaining = mbytes % VMAC_NHBYTES;
+
+    if (ctx->first_block_processed)
+    {
+        ch = ctx->polytmp[0];
+        cl = ctx->polytmp[1];
+        #if (VMAC_TAG_LEN == 128)
+        ch2 = ctx->polytmp[2];
+        cl2 = ctx->polytmp[3];
+        #endif
+    }
+    else if (i)
+    {
+        #if (VMAC_TAG_LEN == 64)
+        nh_vmac_nhbytes(mptr,kptr,VMAC_NHBYTES/8,ch,cl);
+        #else
+        nh_vmac_nhbytes_2(mptr,kptr,VMAC_NHBYTES/8,ch,cl,ch2,cl2);
+        ch2 &= m62;
+        ADD128(ch2,cl2,pkh2,pkl2);
+        #endif
+        ch &= m62;
+        ADD128(ch,cl,pkh,pkl);
+        mptr += (VMAC_NHBYTES/sizeof(uint64_t));
+        i--;
+    }
+    else if (remaining)
+    {
+        #if (VMAC_TAG_LEN == 64)
+        nh_16(mptr,kptr,2*((remaining+15)/16),ch,cl);
+        #else
+        nh_16_2(mptr,kptr,2*((remaining+15)/16),ch,cl,ch2,cl2);
+        ch2 &= m62;
+        ADD128(ch2,cl2,pkh2,pkl2);
+        #endif
+        ch &= m62;
+        ADD128(ch,cl,pkh,pkl);
+        mptr += (VMAC_NHBYTES/sizeof(uint64_t));
+        goto do_l3;
+    }
+    else /* Empty String */
+    {
+        ch = pkh; cl = pkl;
+        #if (VMAC_TAG_LEN == 128)
+        ch2 = pkh2; cl2 = pkl2;
+        #endif
+        goto do_l3;
+    }
+
+    while (i--) {
+        #if (VMAC_TAG_LEN == 64)
+        nh_vmac_nhbytes(mptr,kptr,VMAC_NHBYTES/8,rh,rl);
+        #else
+        nh_vmac_nhbytes_2(mptr,kptr,VMAC_NHBYTES/8,rh,rl,rh2,rl2);
+        rh2 &= m62;
+        poly_step(ch2,cl2,pkh2,pkl2,rh2,rl2);
+        #endif
+        rh &= m62;
+        poly_step(ch,cl,pkh,pkl,rh,rl);
+        mptr += (VMAC_NHBYTES/sizeof(uint64_t));
+    }
+    if (remaining) {
+        #if (VMAC_TAG_LEN == 64)
+        nh_16(mptr,kptr,2*((remaining+15)/16),rh,rl);
+        #else
+        nh_16_2(mptr,kptr,2*((remaining+15)/16),rh,rl,rh2,rl2);
+        rh2 &= m62;
+        poly_step(ch2,cl2,pkh2,pkl2,rh2,rl2);
+        #endif
+        rh &= m62;
+        poly_step(ch,cl,pkh,pkl,rh,rl);
+    }
+
+do_l3:
+    vhash_abort(ctx);
+    remaining *= 8;
+#if (VMAC_TAG_LEN == 128)
+    *tagl = l3hash(ch2, cl2, ctx->l3key[2], ctx->l3key[3],remaining);
+#endif
+    return l3hash(ch, cl, ctx->l3key[0], ctx->l3key[1],remaining);
+}
+
+/* ----------------------------------------------------------------------- */
+
+uint64_t vmac(unsigned char m[],
+         unsigned int mbytes,
+         const unsigned char n[16],
+         uint64_t *tagl,
+         vmac_ctx_t *ctx)
+{
+#if (VMAC_TAG_LEN == 64)
+    uint64_t *in_n, *out_p;
+    uint64_t p, h;
+    int i;
+    
+    #if VMAC_CACHE_NONCES
+    in_n = ctx->cached_nonce;
+    out_p = ctx->cached_aes;
+    #else
+    uint64_t tmp[2];
+    in_n = out_p = tmp;
+    #endif
+
+    i = n[15] & 1;
+    #if VMAC_CACHE_NONCES
+    if ((*(const uint64_t *)(n+8) != in_n[1]) ||
+        (*(const uint64_t *)(n  ) != in_n[0])) {
+    #endif
+    
+        in_n[0] = *(const uint64_t *)(n  );
+        in_n[1] = *(const uint64_t *)(n+8);
+        ((unsigned char *)in_n)[15] &= 0xFE;
+        aes_encryption(in_n, out_p, &ctx->cipher_key);
+
+    #if VMAC_CACHE_NONCES
+        ((unsigned char *)in_n)[15] |= (unsigned char)(1-i);
+    }
+    #endif
+    p = get64BE(out_p + i);
+    h = vhash(m, mbytes, (uint64_t *)0, ctx);
+    return p + h;
+#else
+    uint64_t tmp[2];
+    uint64_t th,tl;
+    aes_encryption(n, (unsigned char *)tmp, &ctx->cipher_key);
+    th = vhash(m, mbytes, &tl, ctx);
+    th += get64BE(tmp);
+    *tagl = tl + get64BE(tmp+1);
+    return th;
+#endif
+}
+
+/* ----------------------------------------------------------------------- */
+
+void vmac_set_key(unsigned char user_key[], vmac_ctx_t *ctx)
+{
+    uint64_t in[2] = {0}, out[2];
+    unsigned i;
+    aes_key_setup(user_key, &ctx->cipher_key);
+    
+    /* Fill nh key */
+    ((unsigned char *)in)[0] = 0x80; 
+    for (i = 0; i < sizeof(ctx->nhkey)/8; i+=2) {
+        aes_encryption((unsigned char *)in, (unsigned char *)out,
+                                                         &ctx->cipher_key);
+        ctx->nhkey[i  ] = get64BE(out);
+        ctx->nhkey[i+1] = get64BE(out+1);
+        ((unsigned char *)in)[15] += 1;
+    }
+
+    /* Fill poly key */
+    ((unsigned char *)in)[0] = 0xC0; 
+    in[1] = 0;
+    for (i = 0; i < sizeof(ctx->polykey)/8; i+=2) {
+        aes_encryption((unsigned char *)in, (unsigned char *)out,
+                                                         &ctx->cipher_key);
+        ctx->polytmp[i  ] = ctx->polykey[i  ] = get64BE(out) & mpoly;
+        ctx->polytmp[i+1] = ctx->polykey[i+1] = get64BE(out+1) & mpoly;
+        ((unsigned char *)in)[15] += 1;
+    }
+
+    /* Fill ip key */
+    ((unsigned char *)in)[0] = 0xE0;
+    in[1] = 0;
+    for (i = 0; i < sizeof(ctx->l3key)/8; i+=2) {
+        do {
+            aes_encryption((unsigned char *)in, (unsigned char *)out,
+                                                         &ctx->cipher_key);
+            ctx->l3key[i  ] = get64BE(out);
+            ctx->l3key[i+1] = get64BE(out+1);
+            ((unsigned char *)in)[15] += 1;
+        } while (ctx->l3key[i] >= p64 || ctx->l3key[i+1] >= p64);
+    }
+    
+    /* Invalidate nonce/aes cache and reset other elements */
+    #if (VMAC_TAG_LEN == 64) && (VMAC_CACHE_NONCES)
+    ctx->cached_nonce[0] = (uint64_t)-1; /* Ensure illegal nonce */
+    ctx->cached_nonce[1] = (uint64_t)0;  /* Ensure illegal nonce */
+    #endif
+    ctx->first_block_processed = 0;
+}
+
diff --git sys/fs/pefs/vmac.h sys/fs/pefs/vmac.h
new file mode 100644
index 0000000..419a814
--- /dev/null
+++ sys/fs/pefs/vmac.h
@@ -0,0 +1,96 @@
+#ifndef __VMAC_H
+#define __VMAC_H
+
+/* --------------------------------------------------------------------------
+ * VMAC and VHASH Implementation by Ted Krovetz (tdk@acm.org) and Wei Dai.
+ * This implementation is herby placed in the public domain.
+ * The authors offers no warranty. Use at your own risk.
+ * Please send bug reports to the authors.
+ * Last modified: 17 APR 08, 1700 PDT
+ * ----------------------------------------------------------------------- */
+
+/* --------------------------------------------------------------------------
+ * User definable settings.
+ * ----------------------------------------------------------------------- */
+#define VMAC_TAG_LEN   64 /* Must be 64 or 128 - 64 sufficient for most    */
+#define VMAC_KEY_LEN  128 /* Must be 128, 192 or 256                       */
+#define VMAC_NHBYTES  128 /* Must 2^i for any 3 < i < 13. Standard = 128   */
+#define VMAC_PREFER_BIG_ENDIAN  0  /* Prefer non-x86 */
+
+#define VMAC_CACHE_NONCES 0 /* Set to non-zero to cause caching            */
+                            /* of consecutive nonces on 64-bit tags        */
+
+/* --------------------------------------------------------------------- */
+
+typedef struct {
+	uint64_t nhkey  [(VMAC_NHBYTES/8)+2*(VMAC_TAG_LEN/64-1)];
+	uint64_t polykey[2*VMAC_TAG_LEN/64];
+	uint64_t l3key  [2*VMAC_TAG_LEN/64];
+	uint64_t polytmp[2*VMAC_TAG_LEN/64];
+	uint32_t cipher_key[4*(VMAC_KEY_LEN/32+7)];
+	#if (VMAC_TAG_LEN == 64) && (VMAC_CACHE_NONCES)
+	uint64_t cached_nonce[2];
+	uint64_t cached_aes[2];
+	#endif
+	int first_block_processed;
+} vmac_ctx_t;
+
+/* --------------------------------------------------------------------------
+ *                        <<<<< USAGE NOTES >>>>>
+ *
+ * Given msg m (mbytes in length) and nonce buffer n
+ * this function returns a tag as its output. The tag is returned as
+ * a number. When VMAC_TAG_LEN == 64, the 'return'ed integer is the tag,
+ * and *tagl is meaningless. When VMAC_TAG_LEN == 128 the tag is the
+ * number y * 2^64 + *tagl where y is the function's return value.
+ * If you want to consider tags to be strings, then you must do so with
+ * an agreed upon endian orientation for interoperability, and convert
+ * the results appropriately. VHASH hashes m without creating any tag.
+ * Consecutive substrings forming a prefix of a message may be passed
+ * to vhash_update, with vhash or vmac being called with the remainder
+ * to produce the output.
+ *
+ * Requirements:
+ * - On 32-bit architectures with SSE2 instructions, ctx and m MUST be
+ *   begin on 16-byte memory boundaries.
+ * - m MUST be your message followed by zeroes to the nearest 16-byte
+ *   boundary. If m is a length multiple of 16 bytes, then it is already
+ *   at a 16-byte boundary and needs no padding. mbytes should be your
+ *   message length without any padding. 
+ * - The first bit of the nonce buffer n must be 0. An i byte nonce, is made
+ *   as the first 16-i bytes of n being zero, and the final i the nonce.
+ * - vhash_update MUST have mbytes be a positive multiple of VMAC_NHBYTES
+ * ----------------------------------------------------------------------- */
+
+#define vmac_update vhash_update
+
+void vhash_update(unsigned char m[],
+          unsigned int mbytes,
+          vmac_ctx_t *ctx);
+
+uint64_t vmac(unsigned char m[],
+         unsigned int mbytes,
+         const unsigned char n[16],
+         uint64_t *tagl,
+         vmac_ctx_t *ctx);
+
+uint64_t vhash(unsigned char m[],
+          unsigned int mbytes,
+          uint64_t *tagl,
+          vmac_ctx_t *ctx);
+
+/* --------------------------------------------------------------------------
+ * When passed a VMAC_KEY_LEN bit user_key, this function initialazies ctx.
+ * ----------------------------------------------------------------------- */
+
+void vmac_set_key(unsigned char user_key[], vmac_ctx_t *ctx);
+
+/* --------------------------------------------------------------------------
+ * This function aborts current hash and resets ctx, ready for a new message.
+ * ----------------------------------------------------------------------- */
+
+void vhash_abort(vmac_ctx_t *ctx);
+
+/* --------------------------------------------------------------------- */
+
+#endif /* __VMAC_H */
diff --git sys/modules/Makefile sys/modules/Makefile
index 410be23..9df79af 100644
--- sys/modules/Makefile
+++ sys/modules/Makefile
@@ -250,6 +250,7 @@ SUBDIR=	\
 	${_pccard} \
 	${_pcfclock} \
 	pcn \
+	pefs \
 	${_pf} \
 	${_pflog} \
 	${_pfsync} \
diff --git sys/modules/pefs/Makefile sys/modules/pefs/Makefile
new file mode 100644
index 0000000..6e821aa
--- /dev/null
+++ sys/modules/pefs/Makefile
@@ -0,0 +1,23 @@
+# $FreeBSD$
+
+.PATH:	${.CURDIR}/../../fs/pefs
+
+KMOD=	pefs
+SRCS=	vnode_if.h \
+	pefs_subr.c pefs_vfsops.c pefs_vnops.c pefs_xbase64.c pefs_crypto.c \
+	pefs_dircache.c \
+	pefs_xts.c vmac.c
+
+.if ${MACHINE_CPUARCH} == "i386" || ${MACHINE_CPUARCH} == "amd64"
+SRCS+=	pefs_aesni.c
+CFLAGS+= -DPEFS_AESNI
+.endif
+
+CFLAGS+= -I${.CURDIR}/../../
+
+# Temporally build crypto/hmac into pefs module
+.PATH:	${.CURDIR}/../../crypto/hmac
+
+SRCS+=	hmac.c
+
+.include <bsd.kmod.mk>
